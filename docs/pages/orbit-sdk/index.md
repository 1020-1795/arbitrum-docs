# arbitrum-docs

## Namespaces

- [utils](modules/utils.md)

## Type Aliases

### ChainConfig

 **ChainConfig**: `Object`

#### Type declaration

| Name | Type |
| :------ | :------ |
| `arbitrum` | [`ChainConfigArbitrumParams`](modules.md#chainconfigarbitrumparams) |
| `berlinBlock` | `number` |
| `byzantiumBlock` | `number` |
| `chainId` | `number` |
| `clique` | \{ `epoch`: `number` ; `period`: `number`  } |
| `clique.epoch` | `number` |
| `clique.period` | `number` |
| `constantinopleBlock` | `number` |
| `daoForkBlock` | ``null`` |
| `daoForkSupport` | `boolean` |
| `eip150Block` | `number` |
| `eip150Hash` | `string` |
| `eip155Block` | `number` |
| `eip158Block` | `number` |
| `homesteadBlock` | `number` |
| `istanbulBlock` | `number` |
| `londonBlock` | `number` |
| `muirGlacierBlock` | `number` |
| `petersburgBlock` | `number` |

#### Defined in

[src/types/ChainConfig.ts:14](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/types/ChainConfig.ts#L14)

___

### ChainConfigArbitrumParams

 **ChainConfigArbitrumParams**: `Object`

#### Type declaration

| Name | Type |
| :------ | :------ |
| `AllowDebugPrecompiles` | `boolean` |
| `DataAvailabilityCommittee` | `boolean` |
| `EnableArbOS` | `boolean` |
| `GenesisBlockNum` | `number` |
| `InitialArbOSVersion` | `number` |
| `InitialChainOwner` | `Address` |
| `MaxCodeSize` | `number` |
| `MaxInitCodeSize` | `number` |

#### Defined in

[src/types/ChainConfig.ts:3](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/types/ChainConfig.ts#L3)

___

### CoreContracts

 **CoreContracts**: `Object`

#### Type declaration

| Name | Type |
| :------ | :------ |
| `adminProxy` | `Address` |
| `bridge` | `Address` |
| `challengeManager` | `Address` |
| `deployedAtBlockNumber` | `number` |
| `inbox` | `Address` |
| `nativeToken` | `Address` |
| `outbox` | `Address` |
| `rollup` | `Address` |
| `rollupEventInbox` | `Address` |
| `sequencerInbox` | `Address` |
| `upgradeExecutor` | `Address` |
| `validatorUtils` | `Address` |
| `validatorWalletCreator` | `Address` |

#### Defined in

[src/types/CoreContracts.ts:3](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/types/CoreContracts.ts#L3)

___

### CreateRollupEnoughCustomFeeTokenAllowanceParams

 **CreateRollupEnoughCustomFeeTokenAllowanceParams**: `Prettify`\<`WithRollupCreatorAddressOverride`\<\{ `account`: `Address` ; `nativeToken`: `Address` ; `publicClient`: `PublicClient`  }\>\>

#### Defined in

[src/createRollupEnoughCustomFeeTokenAllowance.ts:10](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/createRollupEnoughCustomFeeTokenAllowance.ts#L10)

___

### CreateRollupFetchTransactionHashParams

 **CreateRollupFetchTransactionHashParams**: `Object`

#### Type declaration

| Name | Type |
| :------ | :------ |
| `publicClient` | `PublicClient` |
| `rollup` | `Address` |

#### Defined in

[src/createRollupFetchTransactionHash.ts:17](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/createRollupFetchTransactionHash.ts#L17)

___

### CreateRollupFunctionInputs

 **CreateRollupFunctionInputs**: `GetFunctionArgs`\<typeof `rollupCreator.abi`, ``"createRollup"``\>[``"args"``]

#### Defined in

[src/types/createRollupTypes.ts:5](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/types/createRollupTypes.ts#L5)

___

### CreateRollupParams

 **CreateRollupParams**: `Pick`\<[`CreateRollupFunctionInputs`](modules.md#createrollupfunctioninputs)[``0``], `RequiredKeys`\> & `Partial`\<`Omit`\<[`CreateRollupFunctionInputs`](modules.md#createrollupfunctioninputs)[``0``], `RequiredKeys`\>\>

#### Defined in

[src/types/createRollupTypes.ts:12](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/types/createRollupTypes.ts#L12)

___

### CreateRollupPrepareConfigParams

 **CreateRollupPrepareConfigParams**: `Pick`\<[`CreateRollupPrepareConfigResult`](modules.md#createrollupprepareconfigresult), `RequiredKeys`\> & `Partial`\<`Omit`\<[`CreateRollupPrepareConfigResult`](modules.md#createrollupprepareconfigresult) \| ``"chainConfig"``, `RequiredKeys`\>\> & \{ `chainConfig?`: [`ChainConfig`](modules.md#chainconfig)  }

#### Defined in

[src/createRollupPrepareConfig.ts:11](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/createRollupPrepareConfig.ts#L11)

___

### CreateRollupPrepareConfigResult

 **CreateRollupPrepareConfigResult**: [`CreateRollupFunctionInputs`](modules.md#createrollupfunctioninputs)[``0``][``"config"``]

#### Defined in

[src/createRollupPrepareConfig.ts:9](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/createRollupPrepareConfig.ts#L9)

___

### CreateRollupPrepareCustomFeeTokenApprovalTransactionRequestParams

 **CreateRollupPrepareCustomFeeTokenApprovalTransactionRequestParams**: `Prettify`\<`WithRollupCreatorAddressOverride`\<\{ `account`: `Address` ; `amount?`: `bigint` ; `nativeToken`: `Address` ; `publicClient`: `PublicClient`  }\>\>

#### Defined in

[src/createRollupPrepareCustomFeeTokenApprovalTransactionRequest.ts:11](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/createRollupPrepareCustomFeeTokenApprovalTransactionRequest.ts#L11)

___

### CreateRollupPrepareTransactionRequestParams

 **CreateRollupPrepareTransactionRequestParams**: `Prettify`\<`WithRollupCreatorAddressOverride`\<\{ `account`: `Address` ; `gasOverrides?`: `TransactionRequestGasOverrides` ; `params`: [`CreateRollupParams`](modules.md#createrollupparams) ; `publicClient`: `PublicClient`  }\>\>

#### Defined in

[src/createRollupPrepareTransactionRequest.ts:30](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/createRollupPrepareTransactionRequest.ts#L30)

___

### CreateRollupTransaction

 **CreateRollupTransaction**: `Transaction` & \{ `getInputs`: () => readonly [\{ `batchPoster`: \`0x$\{string}\` ; `config`: \{ `baseStake`: `bigint` ; `chainConfig`: `string` ; `chainId`: `bigint` ; `confirmPeriodBlocks`: `bigint` ; `extraChallengeTimeBlocks`: `bigint` ; `genesisBlockNum`: `bigint` ; `loserStakeEscrow`: \`0x$\{string}\` ; `owner`: \`0x$\{string}\` ; `sequencerInboxMaxTimeVariation`: \{ `delayBlocks`: `bigint` ; `delaySeconds`: `bigint` ; `futureBlocks`: `bigint` ; `futureSeconds`: `bigint`  } ; `stakeToken`: \`0x$\{string}\` ; `wasmModuleRoot`: \`0x$\{string}\`  } ; `deployFactoriesToL2`: `boolean` ; `maxDataSize`: `bigint` ; `maxFeePerGasForRetryables`: `bigint` ; `nativeToken`: \`0x$\{string}\` ; `validators`: readonly \`0x$\{string}\`[]  }]  }

#### Defined in

[src/createRollupPrepareTransaction.ts:13](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/createRollupPrepareTransaction.ts#L13)

___

### CreateRollupTransactionReceipt

 **CreateRollupTransactionReceipt**: `TransactionReceipt` & \{ `getCoreContracts`: () => [`CoreContracts`](modules.md#corecontracts)  }

#### Defined in

[src/createRollupPrepareTransactionReceipt.ts:30](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/createRollupPrepareTransactionReceipt.ts#L30)

___

### CreateTokenBridgeEnoughCustomFeeTokenAllowanceParams

 **CreateTokenBridgeEnoughCustomFeeTokenAllowanceParams**: `Prettify`\<`WithTokenBridgeCreatorAddressOverride`\<\{ `nativeToken`: `Address` ; `owner`: `Address` ; `publicClient`: `PublicClient`  }\>\>

#### Defined in

[src/createTokenBridgeEnoughCustomFeeTokenAllowance.ts:10](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/createTokenBridgeEnoughCustomFeeTokenAllowance.ts#L10)

___

### CreateTokenBridgePrepareCustomFeeTokenApprovalTransactionRequestParams

 **CreateTokenBridgePrepareCustomFeeTokenApprovalTransactionRequestParams**: `Prettify`\<`WithTokenBridgeCreatorAddressOverride`\<\{ `amount?`: `bigint` ; `nativeToken`: `Address` ; `owner`: `Address` ; `publicClient`: `PublicClient`  }\>\>

#### Defined in

[src/createTokenBridgePrepareCustomFeeTokenApprovalTransactionRequest.ts:10](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/createTokenBridgePrepareCustomFeeTokenApprovalTransactionRequest.ts#L10)

___

### CreateTokenBridgePrepareTransactionRequestParams

 **CreateTokenBridgePrepareTransactionRequestParams**: `Prettify`\<`WithTokenBridgeCreatorAddressOverride`\<\{ `account`: `Address` ; `gasOverrides?`: `TransactionRequestGasOverrides` ; `orbitChainPublicClient`: `PublicClient` ; `params`: \{ `rollup`: `Address` ; `rollupOwner`: `Address`  } ; `parentChainPublicClient`: `PublicClient` ; `retryableGasOverrides?`: `TransactionRequestRetryableGasOverrides`  }\>\>

#### Defined in

[src/createTokenBridgePrepareTransactionRequest.ts:26](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/createTokenBridgePrepareTransactionRequest.ts#L26)

___

### NodeConfig

 **NodeConfig**: `Object`

Nitro node configuration options

#### Type declaration

| Name | Type | Description |
| :------ | :------ | :------ |
| `auth?` | \{ `addr?`: `string` ; `api?`: `string`[] ; `jwtsecret?`: `string` ; `origins?`: `string`[] ; `port?`: `number`  } | - |
| `auth.addr?` | `string` | AUTH-RPC server listening interface (default "127.0.0.1") |
| `auth.api?` | `string`[] | APIs offered over the AUTH-RPC interface (default [validation]) |
| `auth.jwtsecret?` | `string` | Path to file holding JWT secret (32B hex) |
| `auth.origins?` | `string`[] | Origins from which to accept AUTH requests (default [localhost]) |
| `auth.port?` | `number` | AUTH-RPC server listening port (default 8549) |
| `blocks-reexecutor?` | \{ `blocks-per-thread?`: `number` ; `enable?`: `boolean` ; `end-block?`: `number` ; `mode?`: `string` ; `room?`: `number` ; `start-block?`: `number`  } | - |
| `blocks-reexecutor.blocks-per-thread?` | `number` | minimum number of blocks to execute per thread. When mode is random this acts as the size of random block range sample (default 10000) |
| `blocks-reexecutor.enable?` | `boolean` | enables re-execution of a range of blocks against historic state |
| `blocks-reexecutor.end-block?` | `number` | last block number of the block range for re-execution |
| `blocks-reexecutor.mode?` | `string` | mode to run the blocks-reexecutor on. Valid modes full and random. full - execute all the blocks in the given range. random - execute a random sample range of blocks with in a given range (default "random") |
| `blocks-reexecutor.room?` | `number` | number of threads to parallelize blocks re-execution (default 10) |
| `blocks-reexecutor.start-block?` | `number` | first block number of the block range for re-execution |
| `chain?` | \{ `dev-wallet?`: \{ `account?`: `string` ; `only-create-key?`: `boolean` ; `password?`: `string` ; `pathname?`: `string` ; `private-key?`: `string`  } ; `id?`: `number` ; `info-files?`: `string`[] ; `info-ipfs-download-path?`: `string` ; `info-ipfs-url?`: `string` ; `info-json?`: `string` ; `name?`: `string`  } | - |
| `chain.dev-wallet?` | \{ `account?`: `string` ; `only-create-key?`: `boolean` ; `password?`: `string` ; `pathname?`: `string` ; `private-key?`: `string`  } | - |
| `chain.dev-wallet.account?` | `string` | account to use (default is first account in keystore) |
| `chain.dev-wallet.only-create-key?` | `boolean` | if true, creates new key then exits |
| `chain.dev-wallet.password?` | `string` | wallet passphrase (default "PASSWORD_NOT_SET") |
| `chain.dev-wallet.pathname?` | `string` | pathname for wallet |
| `chain.dev-wallet.private-key?` | `string` | private key for wallet |
| `chain.id?` | `number` | L2 chain ID (determines Arbitrum network) |
| `chain.info-files?` | `string`[] | L2 chain info json files |
| `chain.info-ipfs-download-path?` | `string` | path to save temp downloaded file (default "/tmp/") |
| `chain.info-ipfs-url?` | `string` | url to download chain info file |
| `chain.info-json?` | `string` | L2 chain info in json string format |
| `chain.name?` | `string` | L2 chain name (determines Arbitrum network) |
| `conf?` | \{ `dump?`: `boolean` ; `env-prefix?`: `string` ; `file?`: `string`[] ; `reload-interval?`: `string` ; `s3?`: \{ `access-key?`: `string` ; `bucket?`: `string` ; `object-key?`: `string` ; `region?`: `string` ; `secret-key?`: `string`  } ; `string?`: `string`  } | - |
| `conf.dump?` | `boolean` | print out currently active configuration file |
| `conf.env-prefix?` | `string` | environment variables with given prefix will be loaded as configuration values |
| `conf.file?` | `string`[] | name of configuration file |
| `conf.reload-interval?` | `string` | how often to reload configuration (0=disable periodic reloading) |
| `conf.s3?` | \{ `access-key?`: `string` ; `bucket?`: `string` ; `object-key?`: `string` ; `region?`: `string` ; `secret-key?`: `string`  } | - |
| `conf.s3.access-key?` | `string` | S3 access key |
| `conf.s3.bucket?` | `string` | S3 bucket |
| `conf.s3.object-key?` | `string` | S3 object key |
| `conf.s3.region?` | `string` | S3 region |
| `conf.s3.secret-key?` | `string` | S3 secret key |
| `conf.string?` | `string` | configuration as JSON string |
| `execution?` | \{ `caching?`: \{ `archive?`: `boolean` ; `block-age?`: `string` ; `block-count?`: `number` ; `database-cache?`: `number` ; `max-amount-of-gas-to-skip-state-saving?`: `number` ; `max-number-of-blocks-to-skip-state-saving?`: `number` ; `snapshot-cache?`: `number` ; `snapshot-restore-gas-limit?`: `number` ; `trie-clean-cache?`: `number` ; `trie-dirty-cache?`: `number` ; `trie-time-limit?`: `string`  } ; `dangerous?`: \{ `reorg-to-block?`: `number`  } ; `enable-prefetch-block?`: `boolean` ; `forwarder?`: \{ `connection-timeout?`: `string` ; `idle-connection-timeout?`: `string` ; `max-idle-connections?`: `number` ; `redis-url?`: `string` ; `retry-interval?`: `string` ; `update-interval?`: `string`  } ; `forwarding-target?`: `string` ; `parent-chain-reader?`: \{ `dangerous?`: \{ `wait-for-tx-approval-safe-poll?`: `string`  } ; `enable?`: `boolean` ; `old-header-timeout?`: `string` ; `poll-interval?`: `string` ; `poll-only?`: `boolean` ; `subscribe-err-interval?`: `string` ; `tx-timeout?`: `string` ; `use-finality-data?`: `boolean`  } ; `recording-database?`: \{ `trie-clean-cache?`: `number` ; `trie-dirty-cache?`: `number`  } ; `rpc?`: \{ `allow-method?`: `string`[] ; `arbdebug?`: \{ `block-range-bound?`: `number` ; `timeout-queue-bound?`: `number`  } ; `bloom-bits-blocks?`: `number` ; `bloom-confirms?`: `number` ; `classic-redirect?`: `string` ; `classic-redirect-timeout?`: `string` ; `evm-timeout?`: `string` ; `feehistory-max-block-count?`: `number` ; `filter-log-cache-size?`: `number` ; `filter-timeout?`: `string` ; `gas-cap?`: `number` ; `max-recreate-state-depth?`: `number` ; `tx-allow-unprotected?`: `boolean` ; `tx-fee-cap?`: `number`  } ; `secondary-forwarding-target?`: `string`[] ; `sequencer?`: \{ `enable?`: `boolean` ; `forwarder?`: \{ `connection-timeout?`: `string` ; `idle-connection-timeout?`: `string` ; `max-idle-connections?`: `number` ; `redis-url?`: `string` ; `retry-interval?`: `string` ; `update-interval?`: `string`  } ; `max-acceptable-timestamp-delta?`: `string` ; `max-block-speed?`: `string` ; `max-revert-gas-reject?`: `number` ; `max-tx-data-size?`: `number` ; `nonce-cache-size?`: `number` ; `nonce-failure-cache-expiry?`: `string` ; `nonce-failure-cache-size?`: `number` ; `queue-size?`: `number` ; `queue-timeout?`: `string` ; `sender-whitelist?`: `string`  } ; `tx-lookup-limit?`: `number` ; `tx-pre-checker?`: \{ `required-state-age?`: `number` ; `required-state-max-blocks?`: `number` ; `strictness?`: `number`  }  } | - |
| `execution.caching?` | \{ `archive?`: `boolean` ; `block-age?`: `string` ; `block-count?`: `number` ; `database-cache?`: `number` ; `max-amount-of-gas-to-skip-state-saving?`: `number` ; `max-number-of-blocks-to-skip-state-saving?`: `number` ; `snapshot-cache?`: `number` ; `snapshot-restore-gas-limit?`: `number` ; `trie-clean-cache?`: `number` ; `trie-dirty-cache?`: `number` ; `trie-time-limit?`: `string`  } | - |
| `execution.caching.archive?` | `boolean` | retain past block state |
| `execution.caching.block-age?` | `string` | minimum age of recent blocks to keep in memory (default 30m0s) |
| `execution.caching.block-count?` | `number` | minimum number of recent blocks to keep in memory (default 128) |
| `execution.caching.database-cache?` | `number` | amount of memory in megabytes to cache database contents with (default 2048) |
| `execution.caching.max-amount-of-gas-to-skip-state-saving?` | `number` | maximum amount of gas in blocks to skip saving state to Persistent storage (archive node only) -- warning: this option seems to cause issues |
| `execution.caching.max-number-of-blocks-to-skip-state-saving?` | `number` | maximum number of blocks to skip state saving to persistent storage (archive node only) -- warning: this option seems to cause issues |
| `execution.caching.snapshot-cache?` | `number` | amount of memory in megabytes to cache state snapshots with (default 400) |
| `execution.caching.snapshot-restore-gas-limit?` | `number` | maximum gas rolled back to recover snapshot (default 300000000000) |
| `execution.caching.trie-clean-cache?` | `number` | amount of memory in megabytes to cache unchanged state trie nodes with (default 600) |
| `execution.caching.trie-dirty-cache?` | `number` | amount of memory in megabytes to cache state diffs against disk with (larger cache lowers database growth) (default 1024) |
| `execution.caching.trie-time-limit?` | `string` | maximum block processing time before trie is written to hard-disk (default 1h0m0s) |
| `execution.dangerous?` | \{ `reorg-to-block?`: `number`  } | - |
| `execution.dangerous.reorg-to-block?` | `number` | DANGEROUS! forces a reorg to an old block height. To be used for testing only. -1 to disable (default -1) |
| `execution.enable-prefetch-block?` | `boolean` | enable prefetching of blocks (default true) |
| `execution.forwarder?` | \{ `connection-timeout?`: `string` ; `idle-connection-timeout?`: `string` ; `max-idle-connections?`: `number` ; `redis-url?`: `string` ; `retry-interval?`: `string` ; `update-interval?`: `string`  } | - |
| `execution.forwarder.connection-timeout?` | `string` | total time to wait before cancelling connection (default 30s) |
| `execution.forwarder.idle-connection-timeout?` | `string` | time until idle connections are closed (default 15s) |
| `execution.forwarder.max-idle-connections?` | `number` | maximum number of idle connections to keep open (default 1) |
| `execution.forwarder.redis-url?` | `string` | the Redis URL to recomend target via |
| `execution.forwarder.retry-interval?` | `string` | minimal time between update retries (default 100ms) |
| `execution.forwarder.update-interval?` | `string` | forwarding target update interval (default 1s) |
| `execution.forwarding-target?` | `string` | transaction forwarding target URL, or "null" to disable forwarding (iff not sequencer) |
| `execution.parent-chain-reader?` | \{ `dangerous?`: \{ `wait-for-tx-approval-safe-poll?`: `string`  } ; `enable?`: `boolean` ; `old-header-timeout?`: `string` ; `poll-interval?`: `string` ; `poll-only?`: `boolean` ; `subscribe-err-interval?`: `string` ; `tx-timeout?`: `string` ; `use-finality-data?`: `boolean`  } | - |
| `execution.parent-chain-reader.dangerous?` | \{ `wait-for-tx-approval-safe-poll?`: `string`  } | - |
| `execution.parent-chain-reader.dangerous.wait-for-tx-approval-safe-poll?` | `string` | Dangerous! only meant to be used by system tests |
| `execution.parent-chain-reader.enable?` | `boolean` | enable reader connection (default true) |
| `execution.parent-chain-reader.old-header-timeout?` | `string` | warns if the latest l1 block is at least this old (default 5m0s) |
| `execution.parent-chain-reader.poll-interval?` | `string` | interval when polling endpoint (default 15s) |
| `execution.parent-chain-reader.poll-only?` | `boolean` | do not attempt to subscribe to header events |
| `execution.parent-chain-reader.subscribe-err-interval?` | `string` | interval for subscribe error (default 5m0s) |
| `execution.parent-chain-reader.tx-timeout?` | `string` | timeout when waiting for a transaction (default 5m0s) |
| `execution.parent-chain-reader.use-finality-data?` | `boolean` | use l1 data about finalized/safe blocks (default true) |
| `execution.recording-database?` | \{ `trie-clean-cache?`: `number` ; `trie-dirty-cache?`: `number`  } | - |
| `execution.recording-database.trie-clean-cache?` | `number` | like trie-clean-cache for the separate, recording database (used for validation) (default 16) |
| `execution.recording-database.trie-dirty-cache?` | `number` | like trie-dirty-cache for the separate, recording database (used for validation) (default 1024) |
| `execution.rpc?` | \{ `allow-method?`: `string`[] ; `arbdebug?`: \{ `block-range-bound?`: `number` ; `timeout-queue-bound?`: `number`  } ; `bloom-bits-blocks?`: `number` ; `bloom-confirms?`: `number` ; `classic-redirect?`: `string` ; `classic-redirect-timeout?`: `string` ; `evm-timeout?`: `string` ; `feehistory-max-block-count?`: `number` ; `filter-log-cache-size?`: `number` ; `filter-timeout?`: `string` ; `gas-cap?`: `number` ; `max-recreate-state-depth?`: `number` ; `tx-allow-unprotected?`: `boolean` ; `tx-fee-cap?`: `number`  } | - |
| `execution.rpc.allow-method?` | `string`[] | list of whitelisted rpc methods |
| `execution.rpc.arbdebug?` | \{ `block-range-bound?`: `number` ; `timeout-queue-bound?`: `number`  } | - |
| `execution.rpc.arbdebug.block-range-bound?` | `number` | bounds the number of blocks arbdebug calls may return (default 256) |
| `execution.rpc.arbdebug.timeout-queue-bound?` | `number` | bounds the length of timeout queues arbdebug calls may return (default 512) |
| `execution.rpc.bloom-bits-blocks?` | `number` | number of blocks a single bloom bit section vector holds (default 16384) |
| `execution.rpc.bloom-confirms?` | `number` | number of confirmation blocks before a bloom section is considered final (default 256) |
| `execution.rpc.classic-redirect?` | `string` | url to redirect classic requests, use "error:[CODE:]MESSAGE" to return specified error instead of redirecting |
| `execution.rpc.classic-redirect-timeout?` | `string` | timeout for forwarded classic requests, where 0 = no timeout |
| `execution.rpc.evm-timeout?` | `string` | timeout used for eth_call (0=infinite) (default 5s) |
| `execution.rpc.feehistory-max-block-count?` | `number` | max number of blocks a fee history request may cover (default 1024) |
| `execution.rpc.filter-log-cache-size?` | `number` | log filter system maximum number of cached blocks (default 32) |
| `execution.rpc.filter-timeout?` | `string` | log filter system maximum time filters stay active (default 5m0s) |
| `execution.rpc.gas-cap?` | `number` | cap on computation gas that can be used in eth_call/estimateGas (0=infinite) (default 50000000) |
| `execution.rpc.max-recreate-state-depth?` | `number` | maximum depth for recreating state, measured in l2 gas (0=don't recreate state, -1=infinite, -2=use default value for archive or non-archive node (whichever is configured)) (default -2) |
| `execution.rpc.tx-allow-unprotected?` | `boolean` | allow transactions that aren't EIP-155 replay protected to be submitted over the RPC (default true) |
| `execution.rpc.tx-fee-cap?` | `number` | cap on transaction fee (in ether) that can be sent via the RPC APIs (0 = no cap) (default 1) |
| `execution.secondary-forwarding-target?` | `string`[] | secondary transaction forwarding target URL |
| `execution.sequencer?` | \{ `enable?`: `boolean` ; `forwarder?`: \{ `connection-timeout?`: `string` ; `idle-connection-timeout?`: `string` ; `max-idle-connections?`: `number` ; `redis-url?`: `string` ; `retry-interval?`: `string` ; `update-interval?`: `string`  } ; `max-acceptable-timestamp-delta?`: `string` ; `max-block-speed?`: `string` ; `max-revert-gas-reject?`: `number` ; `max-tx-data-size?`: `number` ; `nonce-cache-size?`: `number` ; `nonce-failure-cache-expiry?`: `string` ; `nonce-failure-cache-size?`: `number` ; `queue-size?`: `number` ; `queue-timeout?`: `string` ; `sender-whitelist?`: `string`  } | - |
| `execution.sequencer.enable?` | `boolean` | act and post to l1 as sequencer |
| `execution.sequencer.forwarder?` | \{ `connection-timeout?`: `string` ; `idle-connection-timeout?`: `string` ; `max-idle-connections?`: `number` ; `redis-url?`: `string` ; `retry-interval?`: `string` ; `update-interval?`: `string`  } | - |
| `execution.sequencer.forwarder.connection-timeout?` | `string` | total time to wait before cancelling connection (default 30s) |
| `execution.sequencer.forwarder.idle-connection-timeout?` | `string` | time until idle connections are closed (default 1m0s) |
| `execution.sequencer.forwarder.max-idle-connections?` | `number` | maximum number of idle connections to keep open (default 100) |
| `execution.sequencer.forwarder.redis-url?` | `string` | the Redis URL to recomend target via |
| `execution.sequencer.forwarder.retry-interval?` | `string` | minimal time between update retries (default 100ms) |
| `execution.sequencer.forwarder.update-interval?` | `string` | forwarding target update interval (default 1s) |
| `execution.sequencer.max-acceptable-timestamp-delta?` | `string` | maximum acceptable time difference between the local time and the latest L1 block's timestamp (default 1h0m0s) |
| `execution.sequencer.max-block-speed?` | `string` | minimum delay between blocks (sets a maximum speed of block production) (default 250ms) |
| `execution.sequencer.max-revert-gas-reject?` | `number` | maximum gas executed in a revert for the sequencer to reject the transaction instead of posting it (anti-DOS) (default 31000) |
| `execution.sequencer.max-tx-data-size?` | `number` | maximum transaction size the sequencer will accept (default 95000) |
| `execution.sequencer.nonce-cache-size?` | `number` | size of the tx sender nonce cache (default 1024) |
| `execution.sequencer.nonce-failure-cache-expiry?` | `string` | maximum amount of time to wait for a predecessor before rejecting a tx with nonce too high (default 1s) |
| `execution.sequencer.nonce-failure-cache-size?` | `number` | number of transactions with too high of a nonce to keep in memory while waiting for their predecessor (default 1024) |
| `execution.sequencer.queue-size?` | `number` | size of the pending tx queue (default 1024) |
| `execution.sequencer.queue-timeout?` | `string` | maximum amount of time transaction can wait in queue (default 12s) |
| `execution.sequencer.sender-whitelist?` | `string` | comma separated whitelist of authorized senders (if empty, everyone is allowed) |
| `execution.tx-lookup-limit?` | `number` | retain the ability to lookup transactions by hash for the past N blocks (0 = all blocks) (default 126230400) |
| `execution.tx-pre-checker?` | \{ `required-state-age?`: `number` ; `required-state-max-blocks?`: `number` ; `strictness?`: `number`  } | - |
| `execution.tx-pre-checker.required-state-age?` | `number` | how long ago should the storage conditions from eth_SendRawTransactionConditional be true, 0 = don't check old state (default 2) |
| `execution.tx-pre-checker.required-state-max-blocks?` | `number` | maximum number of blocks to look back while looking for the <required-state-age> seconds old state, 0 = don't limit the search (default 4) |
| `execution.tx-pre-checker.strictness?` | `number` | how strict to be when checking txs before forwarding them. 0 = accept anything, 10 = should never reject anything that'd succeed, 20 = likely won't reject anything that'd succeed, 30 = full validation which may reject txs that would succeed |
| `file-logging?` | \{ `buf-size?`: `number` ; `compress?`: `boolean` ; `enable?`: `boolean` ; `file?`: `string` ; `local-time?`: `boolean` ; `max-age?`: `number` ; `max-backups?`: `number` ; `max-size?`: `number`  } | - |
| `file-logging.buf-size?` | `number` | size of intermediate log records buffer (default 512) |
| `file-logging.compress?` | `boolean` | enable compression of old log files (default true) |
| `file-logging.enable?` | `boolean` | enable logging to file (default true) |
| `file-logging.file?` | `string` | path to log file (default "nitro.log") |
| `file-logging.local-time?` | `boolean` | if true: local time will be used in old log filename timestamps |
| `file-logging.max-age?` | `number` | maximum number of days to retain old log files based on the timestamp encoded in their filename (0 = no limit) |
| `file-logging.max-backups?` | `number` | maximum number of old log files to retain (0 = no limit) (default 20) |
| `file-logging.max-size?` | `number` | log file size in Mb that will trigger log file rotation (0 = trigger disabled) (default 5) |
| `graphql?` | \{ `corsdomain?`: `string`[] ; `enable?`: `boolean` ; `vhosts?`: `string`[]  } | - |
| `graphql.corsdomain?` | `string`[] | Comma separated list of domains from which to accept cross origin requests (browser enforced) |
| `graphql.enable?` | `boolean` | Enable graphql endpoint on the rpc endpoint |
| `graphql.vhosts?` | `string`[] | Comma separated list of virtual hostnames from which to accept requests (server enforced). Accepts '*' wildcard (default [localhost]) |
| `http?` | \{ `addr?`: `string` ; `api?`: `string`[] ; `corsdomain?`: `string`[] ; `port?`: `number` ; `rpcprefix?`: `string` ; `server-timeouts?`: \{ `idle-timeout?`: `string` ; `read-header-timeout?`: `string` ; `read-timeout?`: `string` ; `write-timeout?`: `string`  } ; `vhosts?`: `string`[]  } | - |
| `http.addr?` | `string` | HTTP-RPC server listening interface |
| `http.api?` | `string`[] | APIs offered over the HTTP-RPC interface (default [net,web3,eth,arb]) |
| `http.corsdomain?` | `string`[] | Comma separated list of domains from which to accept cross origin requests (browser enforced) |
| `http.port?` | `number` | HTTP-RPC server listening port (default 8547) |
| `http.rpcprefix?` | `string` | HTTP path path prefix on which JSON-RPC is served. Use '/' to serve on all paths |
| `http.server-timeouts?` | \{ `idle-timeout?`: `string` ; `read-header-timeout?`: `string` ; `read-timeout?`: `string` ; `write-timeout?`: `string`  } | - |
| `http.server-timeouts.idle-timeout?` | `string` | the maximum amount of time to wait for the next request when keep-alives are enabled (http.Server.IdleTimeout) (default 2m0s) |
| `http.server-timeouts.read-header-timeout?` | `string` | the amount of time allowed to read the request headers (http.Server.ReadHeaderTimeout) (default 30s) |
| `http.server-timeouts.read-timeout?` | `string` | the maximum duration for reading the entire request (http.Server.ReadTimeout) (default 30s) |
| `http.server-timeouts.write-timeout?` | `string` | the maximum duration before timing out writes of the response (http.Server.WriteTimeout) (default 30s) |
| `http.vhosts?` | `string`[] | Comma separated list of virtual hostnames from which to accept requests (server enforced). Accepts '*' wildcard (default [localhost]) |
| `init?` | \{ `accounts-per-sync?`: `number` ; `dev-init?`: `boolean` ; `dev-init-address?`: `string` ; `dev-init-blocknum?`: `number` ; `download-path?`: `string` ; `download-poll?`: `string` ; `empty?`: `boolean` ; `force?`: `boolean` ; `import-file?`: `string` ; `prune?`: `string` ; `prune-bloom-size?`: `number` ; `recreate-missing-state-from?`: `number` ; `reset-to-message?`: `number` ; `then-quit?`: `boolean` ; `url?`: `string`  } | - |
| `init.accounts-per-sync?` | `number` | during init - sync database every X accounts. Lower value for low-memory systems. 0 disables. (default 100000) |
| `init.dev-init?` | `boolean` | init with dev data (1 account with balance) instead of file import |
| `init.dev-init-address?` | `string` | Address of dev-account. Leave empty to use the dev-wallet. |
| `init.dev-init-blocknum?` | `number` | Number of preinit blocks. Must exist in ancient database. |
| `init.download-path?` | `string` | path to save temp downloaded file (default "/tmp/") |
| `init.download-poll?` | `string` | how long to wait between polling attempts (default 1m0s) |
| `init.empty?` | `boolean` | init with empty state |
| `init.force?` | `boolean` | if true: in case database exists init code will be reexecuted and genesis block compared to database |
| `init.import-file?` | `string` | path for json data to import |
| `init.prune?` | `string` | pruning for a given use: "full" for full nodes serving RPC requests, or "validator" for validators |
| `init.prune-bloom-size?` | `number` | the amount of memory in megabytes to use for the pruning bloom filter (higher values prune better) (default 2048) |
| `init.recreate-missing-state-from?` | `number` | block number to start recreating missing states from (0 = disabled) |
| `init.reset-to-message?` | `number` | forces a reset to an old message height. Also set max-reorg-resequence-depth=0 to force re-reading messages (default -1) |
| `init.then-quit?` | `boolean` | quit after init is done |
| `init.url?` | `string` | url to download initializtion data - will poll if download fails |
| `ipc?` | \{ `path?`: `string`  } | - |
| `ipc.path?` | `string` | Requested location to place the IPC endpoint. An empty path disables IPC. |
| `log-level?` | `number` | log level (default 3) |
| `log-type?` | `string` | log type (plaintext or json) (default "plaintext") |
| `metrics?` | `boolean` | enable metrics |
| `metrics-server?` | \{ `addr?`: `string` ; `port?`: `number` ; `update-interval?`: `string`  } | - |
| `metrics-server.addr?` | `string` | metrics server address (default "127.0.0.1") |
| `metrics-server.port?` | `number` | metrics server port (default 6070) |
| `metrics-server.update-interval?` | `string` | metrics server update interval (default 3s) |
| `node?` | \{ `batch-poster?`: \{ `compression-level?`: `number` ; `das-retention-period?`: `string` ; `data-poster?`: \{ `allocate-mempool-balance?`: `boolean` ; `dangerous?`: \{ `clear-dbstorage?`: `boolean`  } ; `elapsed-time-base?`: `string` ; `elapsed-time-importance?`: `number` ; `external-signer?`: \{ `address?`: `string` ; `client-cert?`: `string` ; `client-private-key?`: `string` ; `method?`: `string` ; `root-ca?`: `string` ; `url?`: `string`  } ; `legacy-storage-encoding?`: `boolean` ; `max-fee-cap-formula?`: `string` ; `max-mempool-transactions?`: `number` ; `max-queued-transactions?`: `number` ; `max-tip-cap-gwei?`: `number` ; `min-fee-cap-gwei?`: `number` ; `min-tip-cap-gwei?`: `number` ; `nonce-rbf-soft-confs?`: `number` ; `redis-signer?`: \{ `dangerous?`: \{ `disable-signature-verification?`: `boolean`  } ; `fallback-verification-key?`: `string` ; `signing-key?`: `string`  } ; `replacement-times?`: `string` ; `target-price-gwei?`: `number` ; `urgency-gwei?`: `number` ; `use-db-storage?`: `boolean` ; `use-noop-storage?`: `boolean` ; `wait-for-l1-finality?`: `boolean`  } ; `disable-das-fallback-store-data-on-chain?`: `boolean` ; `enable?`: `boolean` ; `error-delay?`: `string` ; `extra-batch-gas?`: `number` ; `gas-refunder-address?`: `string` ; `ignore-blob-price?`: `boolean` ; `l1-block-bound?`: `string` ; `l1-block-bound-bypass?`: `string` ; `max-4844-batch-size?`: `number` ; `max-delay?`: `string` ; `max-size?`: `number` ; `parent-chain-wallet?`: \{ `account?`: `string` ; `only-create-key?`: `boolean` ; `password?`: `string` ; `pathname?`: `string` ; `private-key?`: `string`  } ; `poll-interval?`: `string` ; `post-4844-blobs?`: `boolean` ; `redis-lock?`: \{ `background-lock?`: `boolean` ; `enable?`: `boolean` ; `key?`: `string` ; `lockout-duration?`: `string` ; `my-id?`: `string` ; `refresh-duration?`: `string`  } ; `redis-url?`: `string` ; `use-access-lists?`: `boolean` ; `wait-for-max-delay?`: `boolean`  } ; `block-validator?`: \{ `current-module-root?`: `string` ; `dangerous?`: \{ `reset-block-validation?`: `boolean`  } ; `enable?`: `boolean` ; `failure-is-fatal?`: `boolean` ; `forward-blocks?`: `number` ; `memory-free-limit?`: `string` ; `pending-upgrade-module-root?`: `string` ; `prerecorded-blocks?`: `number` ; `validation-poll?`: `string` ; `validation-server?`: \{ `arg-log-limit?`: `number` ; `connection-wait?`: `string` ; `jwtsecret?`: `string` ; `retries?`: `number` ; `retry-delay?`: `string` ; `retry-errors?`: `string` ; `timeout?`: `string` ; `url?`: `string`  } ; `validation-server-configs-list?`: `string`  } ; `dangerous?`: \{ `disable-blob-reader?`: `boolean` ; `no-l1-listener?`: `boolean` ; `no-sequencer-coordinator?`: `boolean`  } ; `data-availability?`: \{ `enable?`: `boolean` ; `ipfs-storage?`: \{ `enable?`: `boolean` ; `peers?`: `string`[] ; `pin-after-get?`: `boolean` ; `pin-percentage?`: `number` ; `profiles?`: `string` ; `read-timeout?`: `string` ; `repo-dir?`: `string`  } ; `panic-on-error?`: `boolean` ; `parent-chain-connection-attempts?`: `number` ; `parent-chain-node-url?`: `string` ; `request-timeout?`: `string` ; `rest-aggregator?`: \{ `enable?`: `boolean` ; `max-per-endpoint-stats?`: `number` ; `online-url-list?`: `string` ; `online-url-list-fetch-interval?`: `string` ; `simple-explore-exploit-strategy?`: \{ `exploit-iterations?`: `number` ; `explore-iterations?`: `number`  } ; `strategy?`: `string` ; `strategy-update-interval?`: `string` ; `sync-to-storage?`: \{ `check-already-exists?`: `boolean` ; `delay-on-error?`: `string` ; `eager?`: `boolean` ; `eager-lower-bound-block?`: `number` ; `ignore-write-errors?`: `boolean` ; `parent-chain-blocks-per-read?`: `number` ; `retention-period?`: `string` ; `state-dir?`: `string`  } ; `urls?`: `string`[] ; `wait-before-try-next?`: `string`  } ; `rpc-aggregator?`: \{ `assumed-honest?`: `number` ; `backends?`: `string` ; `enable?`: `boolean`  } ; `sequencer-inbox-address?`: `string`  } ; `delayed-sequencer?`: \{ `enable?`: `boolean` ; `finalize-distance?`: `number` ; `require-full-finality?`: `boolean` ; `use-merge-finality?`: `boolean`  } ; `feed?`: \{ `input?`: \{ `enable-compression?`: `boolean` ; `reconnect-initial-backoff?`: `string` ; `reconnect-maximum-backoff?`: `string` ; `require-chain-id?`: `boolean` ; `require-feed-version?`: `boolean` ; `secondary-url?`: `string`[] ; `timeout?`: `string` ; `url?`: `string`[] ; `verify?`: \{ `accept-sequencer?`: `boolean` ; `allowed-addresses?`: `string`[] ; `dangerous?`: \{ `accept-missing?`: `boolean`  }  }  } ; `output?`: \{ `addr?`: `string` ; `backlog?`: \{ `segment-limit?`: `number`  } ; `client-delay?`: `string` ; `client-timeout?`: `string` ; `connection-limits?`: \{ `enable?`: `boolean` ; `per-ip-limit?`: `number` ; `per-ipv6-cidr-48-limit?`: `number` ; `per-ipv6-cidr-64-limit?`: `number` ; `reconnect-cooldown-period?`: `string`  } ; `disable-signing?`: `boolean` ; `enable?`: `boolean` ; `enable-compression?`: `boolean` ; `handshake-timeout?`: `string` ; `limit-catchup?`: `boolean` ; `log-connect?`: `boolean` ; `log-disconnect?`: `boolean` ; `max-catchup?`: `number` ; `max-send-queue?`: `number` ; `ping?`: `string` ; `port?`: `string` ; `queue?`: `number` ; `read-timeout?`: `string` ; `require-compression?`: `boolean` ; `require-version?`: `boolean` ; `signed?`: `boolean` ; `workers?`: `number` ; `write-timeout?`: `string`  }  } ; `inbox-reader?`: \{ `check-delay?`: `string` ; `default-blocks-to-read?`: `number` ; `delay-blocks?`: `number` ; `hard-reorg?`: `boolean` ; `max-blocks-to-read?`: `number` ; `min-blocks-to-read?`: `number` ; `read-mode?`: `string` ; `target-messages-read?`: `number`  } ; `maintenance?`: \{ `lock?`: \{ `background-lock?`: `boolean` ; `enable?`: `boolean` ; `key?`: `string` ; `lockout-duration?`: `string` ; `my-id?`: `string` ; `refresh-duration?`: `string`  } ; `time-of-day?`: `string`  } ; `message-pruner?`: \{ `enable?`: `boolean` ; `min-batches-left?`: `number` ; `prune-interval?`: `string`  } ; `parent-chain-reader?`: \{ `dangerous?`: \{ `wait-for-tx-approval-safe-poll?`: `string`  } ; `enable?`: `boolean` ; `old-header-timeout?`: `string` ; `poll-interval?`: `string` ; `poll-only?`: `boolean` ; `subscribe-err-interval?`: `string` ; `tx-timeout?`: `string` ; `use-finality-data?`: `boolean`  } ; `seq-coordinator?`: \{ `chosen-healthcheck-addr?`: `string` ; `enable?`: `boolean` ; `handoff-timeout?`: `string` ; `lockout-duration?`: `string` ; `lockout-spare?`: `string` ; `msg-per-poll?`: `number` ; `my-url?`: `string` ; `redis-url?`: `string` ; `release-retries?`: `number` ; `retry-interval?`: `string` ; `safe-shutdown-delay?`: `string` ; `seq-num-duration?`: `string` ; `signer?`: \{ `ecdsa?`: \{ `accept-sequencer?`: `boolean` ; `allowed-addresses?`: `string`[] ; `dangerous?`: \{ `accept-missing?`: `boolean`  }  } ; `symmetric?`: \{ `dangerous?`: \{ `disable-signature-verification?`: `boolean`  } ; `fallback-verification-key?`: `string` ; `signing-key?`: `string`  } ; `symmetric-fallback?`: `boolean` ; `symmetric-sign?`: `boolean`  } ; `update-interval?`: `string`  } ; `sequencer?`: `boolean` ; `staker?`: \{ `confirmation-blocks?`: `number` ; `contract-wallet-address?`: `string` ; `dangerous?`: \{ `ignore-rollup-wasm-module-root?`: `boolean` ; `without-block-validator?`: `boolean`  } ; `data-poster?`: \{ `allocate-mempool-balance?`: `boolean` ; `dangerous?`: \{ `clear-dbstorage?`: `boolean`  } ; `elapsed-time-base?`: `string` ; `elapsed-time-importance?`: `number` ; `external-signer?`: \{ `address?`: `string` ; `client-cert?`: `string` ; `client-private-key?`: `string` ; `method?`: `string` ; `root-ca?`: `string` ; `url?`: `string`  } ; `legacy-storage-encoding?`: `boolean` ; `max-fee-cap-formula?`: `string` ; `max-mempool-transactions?`: `number` ; `max-queued-transactions?`: `number` ; `max-tip-cap-gwei?`: `number` ; `min-fee-cap-gwei?`: `number` ; `min-tip-cap-gwei?`: `number` ; `nonce-rbf-soft-confs?`: `number` ; `redis-signer?`: \{ `dangerous?`: \{ `disable-signature-verification?`: `boolean`  } ; `fallback-verification-key?`: `string` ; `signing-key?`: `string`  } ; `replacement-times?`: `string` ; `target-price-gwei?`: `number` ; `urgency-gwei?`: `number` ; `use-db-storage?`: `boolean` ; `use-noop-storage?`: `boolean` ; `wait-for-l1-finality?`: `boolean`  } ; `disable-challenge?`: `boolean` ; `enable?`: `boolean` ; `extra-gas?`: `number` ; `gas-refunder-address?`: `string` ; `make-assertion-interval?`: `string` ; `only-create-wallet-contract?`: `boolean` ; `parent-chain-wallet?`: \{ `account?`: `string` ; `only-create-key?`: `boolean` ; `password?`: `string` ; `pathname?`: `string` ; `private-key?`: `string`  } ; `posting-strategy?`: \{ `high-gas-delay-blocks?`: `number` ; `high-gas-threshold?`: `number`  } ; `redis-url?`: `string` ; `staker-interval?`: `string` ; `start-validation-from-staked?`: `boolean` ; `strategy?`: `string` ; `use-smart-contract-wallet?`: `boolean`  } ; `sync-monitor?`: \{ `block-build-lag?`: `number` ; `block-build-sequencer-inbox-lag?`: `number` ; `coordinator-msg-lag?`: `number` ; `finalized-block-wait-for-block-validator?`: `boolean` ; `safe-block-wait-for-block-validator?`: `boolean`  } ; `transaction-streamer?`: \{ `execute-message-loop-delay?`: `string` ; `max-broadcaster-queue-size?`: `number` ; `max-reorg-resequence-depth?`: `number`  }  } | - |
| `node.batch-poster?` | \{ `compression-level?`: `number` ; `das-retention-period?`: `string` ; `data-poster?`: \{ `allocate-mempool-balance?`: `boolean` ; `dangerous?`: \{ `clear-dbstorage?`: `boolean`  } ; `elapsed-time-base?`: `string` ; `elapsed-time-importance?`: `number` ; `external-signer?`: \{ `address?`: `string` ; `client-cert?`: `string` ; `client-private-key?`: `string` ; `method?`: `string` ; `root-ca?`: `string` ; `url?`: `string`  } ; `legacy-storage-encoding?`: `boolean` ; `max-fee-cap-formula?`: `string` ; `max-mempool-transactions?`: `number` ; `max-queued-transactions?`: `number` ; `max-tip-cap-gwei?`: `number` ; `min-fee-cap-gwei?`: `number` ; `min-tip-cap-gwei?`: `number` ; `nonce-rbf-soft-confs?`: `number` ; `redis-signer?`: \{ `dangerous?`: \{ `disable-signature-verification?`: `boolean`  } ; `fallback-verification-key?`: `string` ; `signing-key?`: `string`  } ; `replacement-times?`: `string` ; `target-price-gwei?`: `number` ; `urgency-gwei?`: `number` ; `use-db-storage?`: `boolean` ; `use-noop-storage?`: `boolean` ; `wait-for-l1-finality?`: `boolean`  } ; `disable-das-fallback-store-data-on-chain?`: `boolean` ; `enable?`: `boolean` ; `error-delay?`: `string` ; `extra-batch-gas?`: `number` ; `gas-refunder-address?`: `string` ; `ignore-blob-price?`: `boolean` ; `l1-block-bound?`: `string` ; `l1-block-bound-bypass?`: `string` ; `max-4844-batch-size?`: `number` ; `max-delay?`: `string` ; `max-size?`: `number` ; `parent-chain-wallet?`: \{ `account?`: `string` ; `only-create-key?`: `boolean` ; `password?`: `string` ; `pathname?`: `string` ; `private-key?`: `string`  } ; `poll-interval?`: `string` ; `post-4844-blobs?`: `boolean` ; `redis-lock?`: \{ `background-lock?`: `boolean` ; `enable?`: `boolean` ; `key?`: `string` ; `lockout-duration?`: `string` ; `my-id?`: `string` ; `refresh-duration?`: `string`  } ; `redis-url?`: `string` ; `use-access-lists?`: `boolean` ; `wait-for-max-delay?`: `boolean`  } | - |
| `node.batch-poster.compression-level?` | `number` | batch compression level (default 11) |
| `node.batch-poster.das-retention-period?` | `string` | In AnyTrust mode, the period which DASes are requested to retain the stored batches. (default 360h0m0s) |
| `node.batch-poster.data-poster?` | \{ `allocate-mempool-balance?`: `boolean` ; `dangerous?`: \{ `clear-dbstorage?`: `boolean`  } ; `elapsed-time-base?`: `string` ; `elapsed-time-importance?`: `number` ; `external-signer?`: \{ `address?`: `string` ; `client-cert?`: `string` ; `client-private-key?`: `string` ; `method?`: `string` ; `root-ca?`: `string` ; `url?`: `string`  } ; `legacy-storage-encoding?`: `boolean` ; `max-fee-cap-formula?`: `string` ; `max-mempool-transactions?`: `number` ; `max-queued-transactions?`: `number` ; `max-tip-cap-gwei?`: `number` ; `min-fee-cap-gwei?`: `number` ; `min-tip-cap-gwei?`: `number` ; `nonce-rbf-soft-confs?`: `number` ; `redis-signer?`: \{ `dangerous?`: \{ `disable-signature-verification?`: `boolean`  } ; `fallback-verification-key?`: `string` ; `signing-key?`: `string`  } ; `replacement-times?`: `string` ; `target-price-gwei?`: `number` ; `urgency-gwei?`: `number` ; `use-db-storage?`: `boolean` ; `use-noop-storage?`: `boolean` ; `wait-for-l1-finality?`: `boolean`  } | - |
| `node.batch-poster.data-poster.allocate-mempool-balance?` | `boolean` | if true, don't put transactions in the mempool that spend a total greater than the batch poster's balance (default true) |
| `node.batch-poster.data-poster.dangerous?` | \{ `clear-dbstorage?`: `boolean`  } | - |
| `node.batch-poster.data-poster.dangerous.clear-dbstorage?` | `boolean` | clear database storage |
| `node.batch-poster.data-poster.elapsed-time-base?` | `string` | unit to measure the time elapsed since creation of transaction used for maximum fee cap calculation (default 10m0s) |
| `node.batch-poster.data-poster.elapsed-time-importance?` | `number` | weight given to the units of time elapsed used for maximum fee cap calculation (default 10) |
| `node.batch-poster.data-poster.external-signer?` | \{ `address?`: `string` ; `client-cert?`: `string` ; `client-private-key?`: `string` ; `method?`: `string` ; `root-ca?`: `string` ; `url?`: `string`  } | - |
| `node.batch-poster.data-poster.external-signer.address?` | `string` | external signer address |
| `node.batch-poster.data-poster.external-signer.client-cert?` | `string` | rpc client cert |
| `node.batch-poster.data-poster.external-signer.client-private-key?` | `string` | rpc client private key |
| `node.batch-poster.data-poster.external-signer.method?` | `string` | external signer method (default "eth_signTransaction") |
| `node.batch-poster.data-poster.external-signer.root-ca?` | `string` | external signer root CA |
| `node.batch-poster.data-poster.external-signer.url?` | `string` | external signer url |
| `node.batch-poster.data-poster.legacy-storage-encoding?` | `boolean` | encodes items in a legacy way (as it was before dropping generics) |
| `node.batch-poster.data-poster.max-fee-cap-formula?` | `string` | mathematical formula to calculate maximum fee cap gwei the result of which would be float64. This expression is expected to be evaluated please refer https://github.com/Knetic/govaluate/blob/master/MANUAL.md to find all available mathematical operators. Currently available variables to construct the formula are BacklogOfBatches, UrgencyGWei, ElapsedTime, ElapsedTimeBase, ElapsedTimeImportance, and TargetPriceGWei (default "((BacklogOfBatches * UrgencyGWei) ** 2) + ((ElapsedTime/ElapsedTimeBase) ** 2) * ElapsedTimeImportance + TargetPriceGWei") |
| `node.batch-poster.data-poster.max-mempool-transactions?` | `number` | the maximum number of transactions to have queued in the mempool at once (0 = unlimited) (default 20) |
| `node.batch-poster.data-poster.max-queued-transactions?` | `number` | the maximum number of unconfirmed transactions to track at once (0 = unlimited) |
| `node.batch-poster.data-poster.max-tip-cap-gwei?` | `number` | the maximum tip cap to post transactions at (default 5) |
| `node.batch-poster.data-poster.min-fee-cap-gwei?` | `number` | the minimum fee cap to post transactions at |
| `node.batch-poster.data-poster.min-tip-cap-gwei?` | `number` | the minimum tip cap to post transactions at (default 0.05) |
| `node.batch-poster.data-poster.nonce-rbf-soft-confs?` | `number` | the maximum probable reorg depth, used to determine when a transaction will no longer likely need replaced-by-fee (default 1) |
| `node.batch-poster.data-poster.redis-signer?` | \{ `dangerous?`: \{ `disable-signature-verification?`: `boolean`  } ; `fallback-verification-key?`: `string` ; `signing-key?`: `string`  } | - |
| `node.batch-poster.data-poster.redis-signer.dangerous?` | \{ `disable-signature-verification?`: `boolean`  } | - |
| `node.batch-poster.data-poster.redis-signer.dangerous.disable-signature-verification?` | `boolean` | disable message signature verification |
| `node.batch-poster.data-poster.redis-signer.fallback-verification-key?` | `string` | a fallback key used for message verification |
| `node.batch-poster.data-poster.redis-signer.signing-key?` | `string` | a 32-byte (64-character) hex string used to sign messages, or a path to a file containing it |
| `node.batch-poster.data-poster.replacement-times?` | `string` | comma-separated list of durations since first posting to attempt a replace-by-fee (default "5m,10m,20m,30m,1h,2h,4h,6h,8h,12h,16h,18h,20h,22h") |
| `node.batch-poster.data-poster.target-price-gwei?` | `number` | the target price to use for maximum fee cap calculation (default 60) |
| `node.batch-poster.data-poster.urgency-gwei?` | `number` | the urgency to use for maximum fee cap calculation (default 2) |
| `node.batch-poster.data-poster.use-db-storage?` | `boolean` | uses database storage when enabled (default true) |
| `node.batch-poster.data-poster.use-noop-storage?` | `boolean` | uses noop storage, it doesn't store anything |
| `node.batch-poster.data-poster.wait-for-l1-finality?` | `boolean` | only treat a transaction as confirmed after L1 finality has been achieved (recommended) (default true) |
| `node.batch-poster.disable-das-fallback-store-data-on-chain?` | `boolean` | If unable to batch to DAS, disable fallback storing data on chain |
| `node.batch-poster.enable?` | `boolean` | enable posting batches to l1 |
| `node.batch-poster.error-delay?` | `string` | how long to delay after error posting batch (default 10s) |
| `node.batch-poster.extra-batch-gas?` | `number` | use this much more gas than estimation says is necessary to post batches (default 50000) |
| `node.batch-poster.gas-refunder-address?` | `string` | The gas refunder contract address (optional) |
| `node.batch-poster.ignore-blob-price?` | `boolean` | if the parent chain supports 4844 blobs and ignore-blob-price is true, post 4844 blobs even if it's not price efficient |
| `node.batch-poster.l1-block-bound?` | `string` | only post messages to batches when they're within the max future block/timestamp as of this L1 block tag ("safe", "finalized", "latest", or "ignore" to ignore this check) |
| `node.batch-poster.l1-block-bound-bypass?` | `string` | post batches even if not within the layer 1 future bounds if we're within this margin of the max delay (default 1h0m0s) |
| `node.batch-poster.max-4844-batch-size?` | `number` | maximum 4844 blob enabled batch size (default 779288) |
| `node.batch-poster.max-delay?` | `string` | maximum batch posting delay (default 1h0m0s) |
| `node.batch-poster.max-size?` | `number` | maximum batch size (default 100000) |
| `node.batch-poster.parent-chain-wallet?` | \{ `account?`: `string` ; `only-create-key?`: `boolean` ; `password?`: `string` ; `pathname?`: `string` ; `private-key?`: `string`  } | - |
| `node.batch-poster.parent-chain-wallet.account?` | `string` | account to use (default is first account in keystore) |
| `node.batch-poster.parent-chain-wallet.only-create-key?` | `boolean` | if true, creates new key then exits |
| `node.batch-poster.parent-chain-wallet.password?` | `string` | wallet passphrase (default "PASSWORD_NOT_SET") |
| `node.batch-poster.parent-chain-wallet.pathname?` | `string` | pathname for wallet (default "batch-poster-wallet") |
| `node.batch-poster.parent-chain-wallet.private-key?` | `string` | private key for wallet |
| `node.batch-poster.poll-interval?` | `string` | how long to wait after no batches are ready to be posted before checking again (default 10s) |
| `node.batch-poster.post-4844-blobs?` | `boolean` | if the parent chain supports 4844 blobs and they're well priced, post EIP-4844 blobs |
| `node.batch-poster.redis-lock?` | \{ `background-lock?`: `boolean` ; `enable?`: `boolean` ; `key?`: `string` ; `lockout-duration?`: `string` ; `my-id?`: `string` ; `refresh-duration?`: `string`  } | - |
| `node.batch-poster.redis-lock.background-lock?` | `boolean` | should node always try grabing lock in background |
| `node.batch-poster.redis-lock.enable?` | `boolean` | if false, always treat this as locked and don't write the lock to redis (default true) |
| `node.batch-poster.redis-lock.key?` | `string` | key for lock |
| `node.batch-poster.redis-lock.lockout-duration?` | `string` | how long lock is held (default 1m0s) |
| `node.batch-poster.redis-lock.my-id?` | `string` | this node's id prefix when acquiring the lock (optional) |
| `node.batch-poster.redis-lock.refresh-duration?` | `string` | how long between consecutive calls to redis (default 10s) |
| `node.batch-poster.redis-url?` | `string` | if non-empty, the Redis URL to store queued transactions in |
| `node.batch-poster.use-access-lists?` | `boolean` | post batches with access lists to reduce gas usage (disabled for L3s) (default true) |
| `node.batch-poster.wait-for-max-delay?` | `boolean` | wait for the max batch delay, even if the batch is full |
| `node.block-validator?` | \{ `current-module-root?`: `string` ; `dangerous?`: \{ `reset-block-validation?`: `boolean`  } ; `enable?`: `boolean` ; `failure-is-fatal?`: `boolean` ; `forward-blocks?`: `number` ; `memory-free-limit?`: `string` ; `pending-upgrade-module-root?`: `string` ; `prerecorded-blocks?`: `number` ; `validation-poll?`: `string` ; `validation-server?`: \{ `arg-log-limit?`: `number` ; `connection-wait?`: `string` ; `jwtsecret?`: `string` ; `retries?`: `number` ; `retry-delay?`: `string` ; `retry-errors?`: `string` ; `timeout?`: `string` ; `url?`: `string`  } ; `validation-server-configs-list?`: `string`  } | - |
| `node.block-validator.current-module-root?` | `string` | current wasm module root ('current' read from chain, 'latest' from machines/latest dir, or provide hash) (default "current") |
| `node.block-validator.dangerous?` | \{ `reset-block-validation?`: `boolean`  } | - |
| `node.block-validator.dangerous.reset-block-validation?` | `boolean` | resets block-by-block validation, starting again at genesis |
| `node.block-validator.enable?` | `boolean` | enable block-by-block validation |
| `node.block-validator.failure-is-fatal?` | `boolean` | failing a validation is treated as a fatal error (default true) |
| `node.block-validator.forward-blocks?` | `number` | prepare entries for up to that many blocks ahead of validation (small footprint) (default 1024) |
| `node.block-validator.memory-free-limit?` | `string` | minimum free-memory limit after reaching which the blockvalidator pauses validation. Enabled by default as 1GB, to disable provide empty string (default "default") |
| `node.block-validator.pending-upgrade-module-root?` | `string` | pending upgrade wasm module root to additionally validate (hash, 'latest' or empty) (default "latest") |
| `node.block-validator.prerecorded-blocks?` | `number` | record that many blocks ahead of validation (larger footprint) (default 20) |
| `node.block-validator.validation-poll?` | `string` | poll time to check validations (default 1s) |
| `node.block-validator.validation-server?` | \{ `arg-log-limit?`: `number` ; `connection-wait?`: `string` ; `jwtsecret?`: `string` ; `retries?`: `number` ; `retry-delay?`: `string` ; `retry-errors?`: `string` ; `timeout?`: `string` ; `url?`: `string`  } | - |
| `node.block-validator.validation-server.arg-log-limit?` | `number` | limit size of arguments in log entries (default 2048) |
| `node.block-validator.validation-server.connection-wait?` | `string` | how long to wait for initial connection |
| `node.block-validator.validation-server.jwtsecret?` | `string` | path to file with jwtsecret for validation - ignored if url is self or self-auth |
| `node.block-validator.validation-server.retries?` | `number` | number of retries in case of failure(0 mean one attempt) (default 3) |
| `node.block-validator.validation-server.retry-delay?` | `string` | delay between retries |
| `node.block-validator.validation-server.retry-errors?` | `string` | Errors matching this regular expression are automatically retried (default "websocket: close.*\|dial tcp .*\|.*i/o timeout\|.*connection reset by peer\|.*connection refused") |
| `node.block-validator.validation-server.timeout?` | `string` | per-response timeout (0-disabled) |
| `node.block-validator.validation-server.url?` | `string` | url of server, use self for loopback websocket, self-auth for loopback with authentication (default "self-auth") |
| `node.block-validator.validation-server-configs-list?` | `string` | array of validation rpc configs given as a json string. time duration should be supplied in number indicating nanoseconds (default "default") |
| `node.dangerous?` | \{ `disable-blob-reader?`: `boolean` ; `no-l1-listener?`: `boolean` ; `no-sequencer-coordinator?`: `boolean`  } | - |
| `node.dangerous.disable-blob-reader?` | `boolean` | DANGEROUS! disables the EIP-4844 blob reader, which is necessary to read batches |
| `node.dangerous.no-l1-listener?` | `boolean` | DANGEROUS! disables listening to L1. To be used in test nodes only |
| `node.dangerous.no-sequencer-coordinator?` | `boolean` | DANGEROUS! allows sequencing without sequencer-coordinator |
| `node.data-availability?` | \{ `enable?`: `boolean` ; `ipfs-storage?`: \{ `enable?`: `boolean` ; `peers?`: `string`[] ; `pin-after-get?`: `boolean` ; `pin-percentage?`: `number` ; `profiles?`: `string` ; `read-timeout?`: `string` ; `repo-dir?`: `string`  } ; `panic-on-error?`: `boolean` ; `parent-chain-connection-attempts?`: `number` ; `parent-chain-node-url?`: `string` ; `request-timeout?`: `string` ; `rest-aggregator?`: \{ `enable?`: `boolean` ; `max-per-endpoint-stats?`: `number` ; `online-url-list?`: `string` ; `online-url-list-fetch-interval?`: `string` ; `simple-explore-exploit-strategy?`: \{ `exploit-iterations?`: `number` ; `explore-iterations?`: `number`  } ; `strategy?`: `string` ; `strategy-update-interval?`: `string` ; `sync-to-storage?`: \{ `check-already-exists?`: `boolean` ; `delay-on-error?`: `string` ; `eager?`: `boolean` ; `eager-lower-bound-block?`: `number` ; `ignore-write-errors?`: `boolean` ; `parent-chain-blocks-per-read?`: `number` ; `retention-period?`: `string` ; `state-dir?`: `string`  } ; `urls?`: `string`[] ; `wait-before-try-next?`: `string`  } ; `rpc-aggregator?`: \{ `assumed-honest?`: `number` ; `backends?`: `string` ; `enable?`: `boolean`  } ; `sequencer-inbox-address?`: `string`  } | - |
| `node.data-availability.enable?` | `boolean` | enable Anytrust Data Availability mode |
| `node.data-availability.ipfs-storage?` | \{ `enable?`: `boolean` ; `peers?`: `string`[] ; `pin-after-get?`: `boolean` ; `pin-percentage?`: `number` ; `profiles?`: `string` ; `read-timeout?`: `string` ; `repo-dir?`: `string`  } | - |
| `node.data-availability.ipfs-storage.enable?` | `boolean` | enable storage/retrieval of sequencer batch data from IPFS |
| `node.data-availability.ipfs-storage.peers?` | `string`[] | list of IPFS peers to connect to, eg /ip4/1.2.3.4/tcp/12345/p2p/abc...xyz |
| `node.data-availability.ipfs-storage.pin-after-get?` | `boolean` | pin sequencer batch data in IPFS (default true) |
| `node.data-availability.ipfs-storage.pin-percentage?` | `number` | percent of sequencer batch data to pin, as a floating point number in the range 0.0 to 100.0 (default 100) |
| `node.data-availability.ipfs-storage.profiles?` | `string` | comma separated list of IPFS profiles to use, see https://docs.ipfs.tech/how-to/default-profile |
| `node.data-availability.ipfs-storage.read-timeout?` | `string` | timeout for IPFS reads, since by default it will wait forever. Treat timeout as not found (default 1m0s) |
| `node.data-availability.ipfs-storage.repo-dir?` | `string` | directory to use to store the local IPFS repo |
| `node.data-availability.panic-on-error?` | `boolean` | whether the Data Availability Service should fail immediately on errors (not recommended) |
| `node.data-availability.parent-chain-connection-attempts?` | `number` | parent chain RPC connection attempts (spaced out at least 1 second per attempt, 0 to retry infinitely), only used in standalone daserver; when running as part of a node that node's parent chain configuration is used (default 15) |
| `node.data-availability.parent-chain-node-url?` | `string` | URL for parent chain node, only used in standalone daserver; when running as part of a node that node's L1 configuration is used |
| `node.data-availability.request-timeout?` | `string` | Data Availability Service timeout duration for Store requests (default 5s) |
| `node.data-availability.rest-aggregator?` | \{ `enable?`: `boolean` ; `max-per-endpoint-stats?`: `number` ; `online-url-list?`: `string` ; `online-url-list-fetch-interval?`: `string` ; `simple-explore-exploit-strategy?`: \{ `exploit-iterations?`: `number` ; `explore-iterations?`: `number`  } ; `strategy?`: `string` ; `strategy-update-interval?`: `string` ; `sync-to-storage?`: \{ `check-already-exists?`: `boolean` ; `delay-on-error?`: `string` ; `eager?`: `boolean` ; `eager-lower-bound-block?`: `number` ; `ignore-write-errors?`: `boolean` ; `parent-chain-blocks-per-read?`: `number` ; `retention-period?`: `string` ; `state-dir?`: `string`  } ; `urls?`: `string`[] ; `wait-before-try-next?`: `string`  } | - |
| `node.data-availability.rest-aggregator.enable?` | `boolean` | enable retrieval of sequencer batch data from a list of remote REST endpoints; if other DAS storage types are enabled, this mode is used as a fallback |
| `node.data-availability.rest-aggregator.max-per-endpoint-stats?` | `number` | number of stats entries (latency and success rate) to keep for each REST endpoint; controls whether strategy is faster or slower to respond to changing conditions (default 20) |
| `node.data-availability.rest-aggregator.online-url-list?` | `string` | a URL to a list of URLs of REST das endpoints that is checked at startup; additive with the url option |
| `node.data-availability.rest-aggregator.online-url-list-fetch-interval?` | `string` | time interval to periodically fetch url list from online-url-list (default 1h0m0s) |
| `node.data-availability.rest-aggregator.simple-explore-exploit-strategy?` | \{ `exploit-iterations?`: `number` ; `explore-iterations?`: `number`  } | - |
| `node.data-availability.rest-aggregator.simple-explore-exploit-strategy.exploit-iterations?` | `number` | number of consecutive GetByHash calls to the aggregator where each call will cause it to select from REST endpoints in order of best latency and success rate, before switching to explore mode (default 1000) |
| `node.data-availability.rest-aggregator.simple-explore-exploit-strategy.explore-iterations?` | `number` | number of consecutive GetByHash calls to the aggregator where each call will cause it to randomly select from REST endpoints until one returns successfully, before switching to exploit mode (default 20) |
| `node.data-availability.rest-aggregator.strategy?` | `string` | strategy to use to determine order and parallelism of calling REST endpoint URLs; valid options are 'simple-explore-exploit' (default "simple-explore-exploit") |
| `node.data-availability.rest-aggregator.strategy-update-interval?` | `string` | how frequently to update the strategy with endpoint latency and error rate data (default 10s) |
| `node.data-availability.rest-aggregator.sync-to-storage?` | \{ `check-already-exists?`: `boolean` ; `delay-on-error?`: `string` ; `eager?`: `boolean` ; `eager-lower-bound-block?`: `number` ; `ignore-write-errors?`: `boolean` ; `parent-chain-blocks-per-read?`: `number` ; `retention-period?`: `string` ; `state-dir?`: `string`  } | - |
| `node.data-availability.rest-aggregator.sync-to-storage.check-already-exists?` | `boolean` | check if the data already exists in this DAS's storage. Must be disabled for fast sync with an IPFS backend (default true) |
| `node.data-availability.rest-aggregator.sync-to-storage.delay-on-error?` | `string` | time to wait if encountered an error before retrying (default 1s) |
| `node.data-availability.rest-aggregator.sync-to-storage.eager?` | `boolean` | eagerly sync batch data to this DAS's storage from the rest endpoints, using L1 as the index of batch data hashes; otherwise only sync lazily |
| `node.data-availability.rest-aggregator.sync-to-storage.eager-lower-bound-block?` | `number` | when eagerly syncing, start indexing forward from this L1 block. Only used if there is no sync state |
| `node.data-availability.rest-aggregator.sync-to-storage.ignore-write-errors?` | `boolean` | log only on failures to write when syncing; otherwise treat it as an error (default true) |
| `node.data-availability.rest-aggregator.sync-to-storage.parent-chain-blocks-per-read?` | `number` | when eagerly syncing, max l1 blocks to read per poll (default 100) |
| `node.data-availability.rest-aggregator.sync-to-storage.retention-period?` | `string` | period to retain synced data (defaults to forever) (default 2562047h47m16.854775807s) |
| `node.data-availability.rest-aggregator.sync-to-storage.state-dir?` | `string` | directory to store the sync state in, ie the block number currently synced up to, so that we don't sync from scratch each time |
| `node.data-availability.rest-aggregator.urls?` | `string`[] | list of URLs including 'http://' or 'https://' prefixes and port numbers to REST DAS endpoints; additive with the online-url-list option |
| `node.data-availability.rest-aggregator.wait-before-try-next?` | `string` | time to wait until trying the next set of REST endpoints while waiting for a response; the next set of REST endpoints is determined by the strategy selected (default 2s) |
| `node.data-availability.rpc-aggregator?` | \{ `assumed-honest?`: `number` ; `backends?`: `string` ; `enable?`: `boolean`  } | - |
| `node.data-availability.rpc-aggregator.assumed-honest?` | `number` | Number of assumed honest backends (H). If there are N backends, K=N+1-H valid responses are required to consider an Store request to be successful. |
| `node.data-availability.rpc-aggregator.backends?` | `string` | JSON RPC backend configuration |
| `node.data-availability.rpc-aggregator.enable?` | `boolean` | enable storage/retrieval of sequencer batch data from a list of RPC endpoints; this should only be used by the batch poster and not in combination with other DAS storage types |
| `node.data-availability.sequencer-inbox-address?` | `string` | parent chain address of SequencerInbox contract |
| `node.delayed-sequencer?` | \{ `enable?`: `boolean` ; `finalize-distance?`: `number` ; `require-full-finality?`: `boolean` ; `use-merge-finality?`: `boolean`  } | - |
| `node.delayed-sequencer.enable?` | `boolean` | enable delayed sequencer |
| `node.delayed-sequencer.finalize-distance?` | `number` | how many blocks in the past L1 block is considered final (ignored when using Merge finality) (default 20) |
| `node.delayed-sequencer.require-full-finality?` | `boolean` | whether to wait for full finality before sequencing delayed messages |
| `node.delayed-sequencer.use-merge-finality?` | `boolean` | whether to use The Merge's notion of finality before sequencing delayed messages (default true) |
| `node.feed?` | \{ `input?`: \{ `enable-compression?`: `boolean` ; `reconnect-initial-backoff?`: `string` ; `reconnect-maximum-backoff?`: `string` ; `require-chain-id?`: `boolean` ; `require-feed-version?`: `boolean` ; `secondary-url?`: `string`[] ; `timeout?`: `string` ; `url?`: `string`[] ; `verify?`: \{ `accept-sequencer?`: `boolean` ; `allowed-addresses?`: `string`[] ; `dangerous?`: \{ `accept-missing?`: `boolean`  }  }  } ; `output?`: \{ `addr?`: `string` ; `backlog?`: \{ `segment-limit?`: `number`  } ; `client-delay?`: `string` ; `client-timeout?`: `string` ; `connection-limits?`: \{ `enable?`: `boolean` ; `per-ip-limit?`: `number` ; `per-ipv6-cidr-48-limit?`: `number` ; `per-ipv6-cidr-64-limit?`: `number` ; `reconnect-cooldown-period?`: `string`  } ; `disable-signing?`: `boolean` ; `enable?`: `boolean` ; `enable-compression?`: `boolean` ; `handshake-timeout?`: `string` ; `limit-catchup?`: `boolean` ; `log-connect?`: `boolean` ; `log-disconnect?`: `boolean` ; `max-catchup?`: `number` ; `max-send-queue?`: `number` ; `ping?`: `string` ; `port?`: `string` ; `queue?`: `number` ; `read-timeout?`: `string` ; `require-compression?`: `boolean` ; `require-version?`: `boolean` ; `signed?`: `boolean` ; `workers?`: `number` ; `write-timeout?`: `string`  }  } | - |
| `node.feed.input?` | \{ `enable-compression?`: `boolean` ; `reconnect-initial-backoff?`: `string` ; `reconnect-maximum-backoff?`: `string` ; `require-chain-id?`: `boolean` ; `require-feed-version?`: `boolean` ; `secondary-url?`: `string`[] ; `timeout?`: `string` ; `url?`: `string`[] ; `verify?`: \{ `accept-sequencer?`: `boolean` ; `allowed-addresses?`: `string`[] ; `dangerous?`: \{ `accept-missing?`: `boolean`  }  }  } | - |
| `node.feed.input.enable-compression?` | `boolean` | enable per message deflate compression support (default true) |
| `node.feed.input.reconnect-initial-backoff?` | `string` | initial duration to wait before reconnect (default 1s) |
| `node.feed.input.reconnect-maximum-backoff?` | `string` | maximum duration to wait before reconnect (default 1m4s) |
| `node.feed.input.require-chain-id?` | `boolean` | require chain id to be present on connect |
| `node.feed.input.require-feed-version?` | `boolean` | require feed version to be present on connect |
| `node.feed.input.secondary-url?` | `string`[] | list of secondary URLs of sequencer feed source. Would be started in the order they appear in the list when primary feeds fails |
| `node.feed.input.timeout?` | `string` | duration to wait before timing out connection to sequencer feed (default 20s) |
| `node.feed.input.url?` | `string`[] | list of primary URLs of sequencer feed source |
| `node.feed.input.verify?` | \{ `accept-sequencer?`: `boolean` ; `allowed-addresses?`: `string`[] ; `dangerous?`: \{ `accept-missing?`: `boolean`  }  } | - |
| `node.feed.input.verify.accept-sequencer?` | `boolean` | accept verified message from sequencer (default true) |
| `node.feed.input.verify.allowed-addresses?` | `string`[] | a list of allowed addresses |
| `node.feed.input.verify.dangerous?` | \{ `accept-missing?`: `boolean`  } | - |
| `node.feed.input.verify.dangerous.accept-missing?` | `boolean` | accept empty as valid signature (default true) |
| `node.feed.output?` | \{ `addr?`: `string` ; `backlog?`: \{ `segment-limit?`: `number`  } ; `client-delay?`: `string` ; `client-timeout?`: `string` ; `connection-limits?`: \{ `enable?`: `boolean` ; `per-ip-limit?`: `number` ; `per-ipv6-cidr-48-limit?`: `number` ; `per-ipv6-cidr-64-limit?`: `number` ; `reconnect-cooldown-period?`: `string`  } ; `disable-signing?`: `boolean` ; `enable?`: `boolean` ; `enable-compression?`: `boolean` ; `handshake-timeout?`: `string` ; `limit-catchup?`: `boolean` ; `log-connect?`: `boolean` ; `log-disconnect?`: `boolean` ; `max-catchup?`: `number` ; `max-send-queue?`: `number` ; `ping?`: `string` ; `port?`: `string` ; `queue?`: `number` ; `read-timeout?`: `string` ; `require-compression?`: `boolean` ; `require-version?`: `boolean` ; `signed?`: `boolean` ; `workers?`: `number` ; `write-timeout?`: `string`  } | - |
| `node.feed.output.addr?` | `string` | address to bind the relay feed output to |
| `node.feed.output.backlog?` | \{ `segment-limit?`: `number`  } | - |
| `node.feed.output.backlog.segment-limit?` | `number` | the maximum number of messages each segment within the backlog can contain (default 240) |
| `node.feed.output.client-delay?` | `string` | delay the first messages sent to each client by this amount |
| `node.feed.output.client-timeout?` | `string` | duration to wait before timing out connections to client (default 15s) |
| `node.feed.output.connection-limits?` | \{ `enable?`: `boolean` ; `per-ip-limit?`: `number` ; `per-ipv6-cidr-48-limit?`: `number` ; `per-ipv6-cidr-64-limit?`: `number` ; `reconnect-cooldown-period?`: `string`  } | - |
| `node.feed.output.connection-limits.enable?` | `boolean` | enable broadcaster per-client connection limiting |
| `node.feed.output.connection-limits.per-ip-limit?` | `number` | limit clients, as identified by IPv4/v6 address, to this many connections to this relay (default 5) |
| `node.feed.output.connection-limits.per-ipv6-cidr-48-limit?` | `number` | limit ipv6 clients, as identified by IPv6 address masked with /48, to this many connections to this relay (default 20) |
| `node.feed.output.connection-limits.per-ipv6-cidr-64-limit?` | `number` | limit ipv6 clients, as identified by IPv6 address masked with /64, to this many connections to this relay (default 10) |
| `node.feed.output.connection-limits.reconnect-cooldown-period?` | `string` | time to wait after a relay client disconnects before the disconnect is registered with respect to the limit for this client |
| `node.feed.output.disable-signing?` | `boolean` | don't sign feed messages (default true) |
| `node.feed.output.enable?` | `boolean` | enable broadcaster |
| `node.feed.output.enable-compression?` | `boolean` | enable per message deflate compression support |
| `node.feed.output.handshake-timeout?` | `string` | duration to wait before timing out HTTP to WS upgrade (default 1s) |
| `node.feed.output.limit-catchup?` | `boolean` | only supply catchup buffer if requested sequence number is reasonable |
| `node.feed.output.log-connect?` | `boolean` | log every client connect |
| `node.feed.output.log-disconnect?` | `boolean` | log every client disconnect |
| `node.feed.output.max-catchup?` | `number` | the maximum size of the catchup buffer (-1 means unlimited) (default -1) |
| `node.feed.output.max-send-queue?` | `number` | maximum number of messages allowed to accumulate before client is disconnected (default 4096) |
| `node.feed.output.ping?` | `string` | duration for ping interval (default 5s) |
| `node.feed.output.port?` | `string` | port to bind the relay feed output to (default "9642") |
| `node.feed.output.queue?` | `number` | queue size for HTTP to WS upgrade (default 100) |
| `node.feed.output.read-timeout?` | `string` | duration to wait before timing out reading data (i.e. pings) from clients (default 1s) |
| `node.feed.output.require-compression?` | `boolean` | require clients to use compression |
| `node.feed.output.require-version?` | `boolean` | don't connect if client version not present |
| `node.feed.output.signed?` | `boolean` | sign broadcast messages |
| `node.feed.output.workers?` | `number` | number of threads to reserve for HTTP to WS upgrade (default 100) |
| `node.feed.output.write-timeout?` | `string` | duration to wait before timing out writing data to clients (default 2s) |
| `node.inbox-reader?` | \{ `check-delay?`: `string` ; `default-blocks-to-read?`: `number` ; `delay-blocks?`: `number` ; `hard-reorg?`: `boolean` ; `max-blocks-to-read?`: `number` ; `min-blocks-to-read?`: `number` ; `read-mode?`: `string` ; `target-messages-read?`: `number`  } | - |
| `node.inbox-reader.check-delay?` | `string` | the maximum time to wait between inbox checks (if not enough new blocks are found) (default 1m0s) |
| `node.inbox-reader.default-blocks-to-read?` | `number` | the default number of blocks to read at once (will vary based on traffic by default) (default 100) |
| `node.inbox-reader.delay-blocks?` | `number` | number of latest blocks to ignore to reduce reorgs |
| `node.inbox-reader.hard-reorg?` | `boolean` | erase future transactions in addition to overwriting existing ones on reorg |
| `node.inbox-reader.max-blocks-to-read?` | `number` | if adjust-blocks-to-read is enabled, the maximum number of blocks to read at once (default 2000) |
| `node.inbox-reader.min-blocks-to-read?` | `number` | the minimum number of blocks to read at once (when caught up lowers load on L1) (default 1) |
| `node.inbox-reader.read-mode?` | `string` | mode to only read latest or safe or finalized L1 blocks. Enabling safe or finalized disables feed input and output. Defaults to latest. Takes string input, valid strings- latest, safe, finalized (default "latest") |
| `node.inbox-reader.target-messages-read?` | `number` | if adjust-blocks-to-read is enabled, the target number of messages to read at once (default 500) |
| `node.maintenance?` | \{ `lock?`: \{ `background-lock?`: `boolean` ; `enable?`: `boolean` ; `key?`: `string` ; `lockout-duration?`: `string` ; `my-id?`: `string` ; `refresh-duration?`: `string`  } ; `time-of-day?`: `string`  } | - |
| `node.maintenance.lock?` | \{ `background-lock?`: `boolean` ; `enable?`: `boolean` ; `key?`: `string` ; `lockout-duration?`: `string` ; `my-id?`: `string` ; `refresh-duration?`: `string`  } | - |
| `node.maintenance.lock.background-lock?` | `boolean` | should node always try grabing lock in background |
| `node.maintenance.lock.enable?` | `boolean` | if false, always treat this as locked and don't write the lock to redis (default true) |
| `node.maintenance.lock.key?` | `string` | key for lock |
| `node.maintenance.lock.lockout-duration?` | `string` | how long lock is held (default 1m0s) |
| `node.maintenance.lock.my-id?` | `string` | this node's id prefix when acquiring the lock (optional) |
| `node.maintenance.lock.refresh-duration?` | `string` | how long between consecutive calls to redis (default 10s) |
| `node.maintenance.time-of-day?` | `string` | UTC 24-hour time of day to run maintenance (currently only db compaction) at (e.g. 15:00) |
| `node.message-pruner?` | \{ `enable?`: `boolean` ; `min-batches-left?`: `number` ; `prune-interval?`: `string`  } | - |
| `node.message-pruner.enable?` | `boolean` | enable message pruning (default true) |
| `node.message-pruner.min-batches-left?` | `number` | min number of batches not pruned (default 2) |
| `node.message-pruner.prune-interval?` | `string` | interval for running message pruner (default 1m0s) |
| `node.parent-chain-reader?` | \{ `dangerous?`: \{ `wait-for-tx-approval-safe-poll?`: `string`  } ; `enable?`: `boolean` ; `old-header-timeout?`: `string` ; `poll-interval?`: `string` ; `poll-only?`: `boolean` ; `subscribe-err-interval?`: `string` ; `tx-timeout?`: `string` ; `use-finality-data?`: `boolean`  } | - |
| `node.parent-chain-reader.dangerous?` | \{ `wait-for-tx-approval-safe-poll?`: `string`  } | - |
| `node.parent-chain-reader.dangerous.wait-for-tx-approval-safe-poll?` | `string` | Dangerous! only meant to be used by system tests |
| `node.parent-chain-reader.enable?` | `boolean` | enable reader connection (default true) |
| `node.parent-chain-reader.old-header-timeout?` | `string` | warns if the latest l1 block is at least this old (default 5m0s) |
| `node.parent-chain-reader.poll-interval?` | `string` | interval when polling endpoint (default 15s) |
| `node.parent-chain-reader.poll-only?` | `boolean` | do not attempt to subscribe to header events |
| `node.parent-chain-reader.subscribe-err-interval?` | `string` | interval for subscribe error (default 5m0s) |
| `node.parent-chain-reader.tx-timeout?` | `string` | timeout when waiting for a transaction (default 5m0s) |
| `node.parent-chain-reader.use-finality-data?` | `boolean` | use l1 data about finalized/safe blocks (default true) |
| `node.seq-coordinator?` | \{ `chosen-healthcheck-addr?`: `string` ; `enable?`: `boolean` ; `handoff-timeout?`: `string` ; `lockout-duration?`: `string` ; `lockout-spare?`: `string` ; `msg-per-poll?`: `number` ; `my-url?`: `string` ; `redis-url?`: `string` ; `release-retries?`: `number` ; `retry-interval?`: `string` ; `safe-shutdown-delay?`: `string` ; `seq-num-duration?`: `string` ; `signer?`: \{ `ecdsa?`: \{ `accept-sequencer?`: `boolean` ; `allowed-addresses?`: `string`[] ; `dangerous?`: \{ `accept-missing?`: `boolean`  }  } ; `symmetric?`: \{ `dangerous?`: \{ `disable-signature-verification?`: `boolean`  } ; `fallback-verification-key?`: `string` ; `signing-key?`: `string`  } ; `symmetric-fallback?`: `boolean` ; `symmetric-sign?`: `boolean`  } ; `update-interval?`: `string`  } | - |
| `node.seq-coordinator.chosen-healthcheck-addr?` | `string` | if non-empty, launch an HTTP service binding to this address that returns status code 200 when chosen and 503 otherwise |
| `node.seq-coordinator.enable?` | `boolean` | enable sequence coordinator |
| `node.seq-coordinator.handoff-timeout?` | `string` | the maximum amount of time to spend waiting for another sequencer to accept the lockout when handing it off on shutdown or db compaction (default 30s) |
| `node.seq-coordinator.lockout-duration?` | `string` | (default 1m0s) |
| `node.seq-coordinator.lockout-spare?` | `string` | (default 30s) |
| `node.seq-coordinator.msg-per-poll?` | `number` | will only be marked as wanting the lockout if not too far behind (default 2000) |
| `node.seq-coordinator.my-url?` | `string` | url for this sequencer if it is the chosen (default "<?INVALID-URL?>") |
| `node.seq-coordinator.redis-url?` | `string` | the Redis URL to coordinate via |
| `node.seq-coordinator.release-retries?` | `number` | the number of times to retry releasing the wants lockout and chosen one status on shutdown (default 4) |
| `node.seq-coordinator.retry-interval?` | `string` | (default 50ms) |
| `node.seq-coordinator.safe-shutdown-delay?` | `string` | if non-zero will add delay after transferring control (default 5s) |
| `node.seq-coordinator.seq-num-duration?` | `string` | (default 24h0m0s) |
| `node.seq-coordinator.signer?` | \{ `ecdsa?`: \{ `accept-sequencer?`: `boolean` ; `allowed-addresses?`: `string`[] ; `dangerous?`: \{ `accept-missing?`: `boolean`  }  } ; `symmetric?`: \{ `dangerous?`: \{ `disable-signature-verification?`: `boolean`  } ; `fallback-verification-key?`: `string` ; `signing-key?`: `string`  } ; `symmetric-fallback?`: `boolean` ; `symmetric-sign?`: `boolean`  } | - |
| `node.seq-coordinator.signer.ecdsa?` | \{ `accept-sequencer?`: `boolean` ; `allowed-addresses?`: `string`[] ; `dangerous?`: \{ `accept-missing?`: `boolean`  }  } | - |
| `node.seq-coordinator.signer.ecdsa.accept-sequencer?` | `boolean` | accept verified message from sequencer (default true) |
| `node.seq-coordinator.signer.ecdsa.allowed-addresses?` | `string`[] | a list of allowed addresses |
| `node.seq-coordinator.signer.ecdsa.dangerous?` | \{ `accept-missing?`: `boolean`  } | - |
| `node.seq-coordinator.signer.ecdsa.dangerous.accept-missing?` | `boolean` | accept empty as valid signature (default true) |
| `node.seq-coordinator.signer.symmetric?` | \{ `dangerous?`: \{ `disable-signature-verification?`: `boolean`  } ; `fallback-verification-key?`: `string` ; `signing-key?`: `string`  } | - |
| `node.seq-coordinator.signer.symmetric.dangerous?` | \{ `disable-signature-verification?`: `boolean`  } | - |
| `node.seq-coordinator.signer.symmetric.dangerous.disable-signature-verification?` | `boolean` | disable message signature verification |
| `node.seq-coordinator.signer.symmetric.fallback-verification-key?` | `string` | a fallback key used for message verification |
| `node.seq-coordinator.signer.symmetric.signing-key?` | `string` | a 32-byte (64-character) hex string used to sign messages, or a path to a file containing it |
| `node.seq-coordinator.signer.symmetric-fallback?` | `boolean` | if to fall back to symmetric hmac |
| `node.seq-coordinator.signer.symmetric-sign?` | `boolean` | if to sign with symmetric hmac |
| `node.seq-coordinator.update-interval?` | `string` | (default 250ms) |
| `node.sequencer?` | `boolean` | enable sequencer |
| `node.staker?` | \{ `confirmation-blocks?`: `number` ; `contract-wallet-address?`: `string` ; `dangerous?`: \{ `ignore-rollup-wasm-module-root?`: `boolean` ; `without-block-validator?`: `boolean`  } ; `data-poster?`: \{ `allocate-mempool-balance?`: `boolean` ; `dangerous?`: \{ `clear-dbstorage?`: `boolean`  } ; `elapsed-time-base?`: `string` ; `elapsed-time-importance?`: `number` ; `external-signer?`: \{ `address?`: `string` ; `client-cert?`: `string` ; `client-private-key?`: `string` ; `method?`: `string` ; `root-ca?`: `string` ; `url?`: `string`  } ; `legacy-storage-encoding?`: `boolean` ; `max-fee-cap-formula?`: `string` ; `max-mempool-transactions?`: `number` ; `max-queued-transactions?`: `number` ; `max-tip-cap-gwei?`: `number` ; `min-fee-cap-gwei?`: `number` ; `min-tip-cap-gwei?`: `number` ; `nonce-rbf-soft-confs?`: `number` ; `redis-signer?`: \{ `dangerous?`: \{ `disable-signature-verification?`: `boolean`  } ; `fallback-verification-key?`: `string` ; `signing-key?`: `string`  } ; `replacement-times?`: `string` ; `target-price-gwei?`: `number` ; `urgency-gwei?`: `number` ; `use-db-storage?`: `boolean` ; `use-noop-storage?`: `boolean` ; `wait-for-l1-finality?`: `boolean`  } ; `disable-challenge?`: `boolean` ; `enable?`: `boolean` ; `extra-gas?`: `number` ; `gas-refunder-address?`: `string` ; `make-assertion-interval?`: `string` ; `only-create-wallet-contract?`: `boolean` ; `parent-chain-wallet?`: \{ `account?`: `string` ; `only-create-key?`: `boolean` ; `password?`: `string` ; `pathname?`: `string` ; `private-key?`: `string`  } ; `posting-strategy?`: \{ `high-gas-delay-blocks?`: `number` ; `high-gas-threshold?`: `number`  } ; `redis-url?`: `string` ; `staker-interval?`: `string` ; `start-validation-from-staked?`: `boolean` ; `strategy?`: `string` ; `use-smart-contract-wallet?`: `boolean`  } | - |
| `node.staker.confirmation-blocks?` | `number` | confirmation blocks (default 12) |
| `node.staker.contract-wallet-address?` | `string` | validator smart contract wallet public address |
| `node.staker.dangerous?` | \{ `ignore-rollup-wasm-module-root?`: `boolean` ; `without-block-validator?`: `boolean`  } | - |
| `node.staker.dangerous.ignore-rollup-wasm-module-root?` | `boolean` | DANGEROUS! make assertions even when the wasm module root is wrong |
| `node.staker.dangerous.without-block-validator?` | `boolean` | DANGEROUS! allows running an L1 validator without a block validator |
| `node.staker.data-poster?` | \{ `allocate-mempool-balance?`: `boolean` ; `dangerous?`: \{ `clear-dbstorage?`: `boolean`  } ; `elapsed-time-base?`: `string` ; `elapsed-time-importance?`: `number` ; `external-signer?`: \{ `address?`: `string` ; `client-cert?`: `string` ; `client-private-key?`: `string` ; `method?`: `string` ; `root-ca?`: `string` ; `url?`: `string`  } ; `legacy-storage-encoding?`: `boolean` ; `max-fee-cap-formula?`: `string` ; `max-mempool-transactions?`: `number` ; `max-queued-transactions?`: `number` ; `max-tip-cap-gwei?`: `number` ; `min-fee-cap-gwei?`: `number` ; `min-tip-cap-gwei?`: `number` ; `nonce-rbf-soft-confs?`: `number` ; `redis-signer?`: \{ `dangerous?`: \{ `disable-signature-verification?`: `boolean`  } ; `fallback-verification-key?`: `string` ; `signing-key?`: `string`  } ; `replacement-times?`: `string` ; `target-price-gwei?`: `number` ; `urgency-gwei?`: `number` ; `use-db-storage?`: `boolean` ; `use-noop-storage?`: `boolean` ; `wait-for-l1-finality?`: `boolean`  } | - |
| `node.staker.data-poster.allocate-mempool-balance?` | `boolean` | if true, don't put transactions in the mempool that spend a total greater than the batch poster's balance (default true) |
| `node.staker.data-poster.dangerous?` | \{ `clear-dbstorage?`: `boolean`  } | - |
| `node.staker.data-poster.dangerous.clear-dbstorage?` | `boolean` | clear database storage |
| `node.staker.data-poster.elapsed-time-base?` | `string` | unit to measure the time elapsed since creation of transaction used for maximum fee cap calculation (default 10m0s) |
| `node.staker.data-poster.elapsed-time-importance?` | `number` | weight given to the units of time elapsed used for maximum fee cap calculation (default 10) |
| `node.staker.data-poster.external-signer?` | \{ `address?`: `string` ; `client-cert?`: `string` ; `client-private-key?`: `string` ; `method?`: `string` ; `root-ca?`: `string` ; `url?`: `string`  } | - |
| `node.staker.data-poster.external-signer.address?` | `string` | external signer address |
| `node.staker.data-poster.external-signer.client-cert?` | `string` | rpc client cert |
| `node.staker.data-poster.external-signer.client-private-key?` | `string` | rpc client private key |
| `node.staker.data-poster.external-signer.method?` | `string` | external signer method (default "eth_signTransaction") |
| `node.staker.data-poster.external-signer.root-ca?` | `string` | external signer root CA |
| `node.staker.data-poster.external-signer.url?` | `string` | external signer url |
| `node.staker.data-poster.legacy-storage-encoding?` | `boolean` | encodes items in a legacy way (as it was before dropping generics) |
| `node.staker.data-poster.max-fee-cap-formula?` | `string` | mathematical formula to calculate maximum fee cap gwei the result of which would be float64. This expression is expected to be evaluated please refer https://github.com/Knetic/govaluate/blob/master/MANUAL.md to find all available mathematical operators. Currently available variables to construct the formula are BacklogOfBatches, UrgencyGWei, ElapsedTime, ElapsedTimeBase, ElapsedTimeImportance, and TargetPriceGWei (default "((BacklogOfBatches * UrgencyGWei) ** 2) + ((ElapsedTime/ElapsedTimeBase) ** 2) * ElapsedTimeImportance + TargetPriceGWei") |
| `node.staker.data-poster.max-mempool-transactions?` | `number` | the maximum number of transactions to have queued in the mempool at once (0 = unlimited) (default 1) |
| `node.staker.data-poster.max-queued-transactions?` | `number` | the maximum number of unconfirmed transactions to track at once (0 = unlimited) |
| `node.staker.data-poster.max-tip-cap-gwei?` | `number` | the maximum tip cap to post transactions at (default 5) |
| `node.staker.data-poster.min-fee-cap-gwei?` | `number` | the minimum fee cap to post transactions at |
| `node.staker.data-poster.min-tip-cap-gwei?` | `number` | the minimum tip cap to post transactions at (default 0.05) |
| `node.staker.data-poster.nonce-rbf-soft-confs?` | `number` | the maximum probable reorg depth, used to determine when a transaction will no longer likely need replaced-by-fee (default 1) |
| `node.staker.data-poster.redis-signer?` | \{ `dangerous?`: \{ `disable-signature-verification?`: `boolean`  } ; `fallback-verification-key?`: `string` ; `signing-key?`: `string`  } | - |
| `node.staker.data-poster.redis-signer.dangerous?` | \{ `disable-signature-verification?`: `boolean`  } | - |
| `node.staker.data-poster.redis-signer.dangerous.disable-signature-verification?` | `boolean` | disable message signature verification |
| `node.staker.data-poster.redis-signer.fallback-verification-key?` | `string` | a fallback key used for message verification |
| `node.staker.data-poster.redis-signer.signing-key?` | `string` | a 32-byte (64-character) hex string used to sign messages, or a path to a file containing it |
| `node.staker.data-poster.replacement-times?` | `string` | comma-separated list of durations since first posting to attempt a replace-by-fee (default "5m,10m,20m,30m,1h,2h,4h,6h,8h,12h,16h,18h,20h,22h") |
| `node.staker.data-poster.target-price-gwei?` | `number` | the target price to use for maximum fee cap calculation (default 60) |
| `node.staker.data-poster.urgency-gwei?` | `number` | the urgency to use for maximum fee cap calculation (default 2) |
| `node.staker.data-poster.use-db-storage?` | `boolean` | uses database storage when enabled (default true) |
| `node.staker.data-poster.use-noop-storage?` | `boolean` | uses noop storage, it doesn't store anything |
| `node.staker.data-poster.wait-for-l1-finality?` | `boolean` | only treat a transaction as confirmed after L1 finality has been achieved (recommended) (default true) |
| `node.staker.disable-challenge?` | `boolean` | disable validator challenge |
| `node.staker.enable?` | `boolean` | enable validator (default true) |
| `node.staker.extra-gas?` | `number` | use this much more gas than estimation says is necessary to post transactions (default 50000) |
| `node.staker.gas-refunder-address?` | `string` | The gas refunder contract address (optional) |
| `node.staker.make-assertion-interval?` | `string` | if configured with the makeNodes strategy, how often to create new assertions (bypassed in case of a dispute) (default 1h0m0s) |
| `node.staker.only-create-wallet-contract?` | `boolean` | only create smart wallet contract and exit |
| `node.staker.parent-chain-wallet?` | \{ `account?`: `string` ; `only-create-key?`: `boolean` ; `password?`: `string` ; `pathname?`: `string` ; `private-key?`: `string`  } | - |
| `node.staker.parent-chain-wallet.account?` | `string` | account to use (default is first account in keystore) |
| `node.staker.parent-chain-wallet.only-create-key?` | `boolean` | if true, creates new key then exits |
| `node.staker.parent-chain-wallet.password?` | `string` | wallet passphrase (default "PASSWORD_NOT_SET") |
| `node.staker.parent-chain-wallet.pathname?` | `string` | pathname for wallet (default "validator-wallet") |
| `node.staker.parent-chain-wallet.private-key?` | `string` | private key for wallet |
| `node.staker.posting-strategy?` | \{ `high-gas-delay-blocks?`: `number` ; `high-gas-threshold?`: `number`  } | - |
| `node.staker.posting-strategy.high-gas-delay-blocks?` | `number` | high gas delay blocks |
| `node.staker.posting-strategy.high-gas-threshold?` | `number` | high gas threshold |
| `node.staker.redis-url?` | `string` | redis url for L1 validator |
| `node.staker.staker-interval?` | `string` | how often the L1 validator should check the status of the L1 rollup and maybe take action with its stake (default 1m0s) |
| `node.staker.start-validation-from-staked?` | `boolean` | assume staked nodes are valid (default true) |
| `node.staker.strategy?` | `string` | L1 validator strategy, either watchtower, defensive, stakeLatest, or makeNodes (default "Watchtower") |
| `node.staker.use-smart-contract-wallet?` | `boolean` | use a smart contract wallet instead of an EOA address |
| `node.sync-monitor?` | \{ `block-build-lag?`: `number` ; `block-build-sequencer-inbox-lag?`: `number` ; `coordinator-msg-lag?`: `number` ; `finalized-block-wait-for-block-validator?`: `boolean` ; `safe-block-wait-for-block-validator?`: `boolean`  } | - |
| `node.sync-monitor.block-build-lag?` | `number` | allowed lag between messages read and blocks built (default 20) |
| `node.sync-monitor.block-build-sequencer-inbox-lag?` | `number` | allowed lag between messages read from sequencer inbox and blocks built |
| `node.sync-monitor.coordinator-msg-lag?` | `number` | allowed lag between local and remote messages (default 15) |
| `node.sync-monitor.finalized-block-wait-for-block-validator?` | `boolean` | wait for block validator to complete before returning finalized block number |
| `node.sync-monitor.safe-block-wait-for-block-validator?` | `boolean` | wait for block validator to complete before returning safe block number |
| `node.transaction-streamer?` | \{ `execute-message-loop-delay?`: `string` ; `max-broadcaster-queue-size?`: `number` ; `max-reorg-resequence-depth?`: `number`  } | - |
| `node.transaction-streamer.execute-message-loop-delay?` | `string` | delay when polling calls to execute messages (default 100ms) |
| `node.transaction-streamer.max-broadcaster-queue-size?` | `number` | maximum cache of pending broadcaster messages (default 50000) |
| `node.transaction-streamer.max-reorg-resequence-depth?` | `number` | maximum number of messages to attempt to resequence on reorg (0 = never resequence, -1 = always resequence) (default 1024) |
| `p2p?` | \{ `bootnodes?`: `string`[] ; `bootnodes-v5?`: `string`[] ; `discovery-v4?`: `boolean` ; `discovery-v5?`: `boolean` ; `listen-addr?`: `string` ; `max-peers?`: `number` ; `no-dial?`: `boolean` ; `no-discovery?`: `boolean`  } | - |
| `p2p.bootnodes?` | `string`[] | P2P bootnodes |
| `p2p.bootnodes-v5?` | `string`[] | P2P bootnodes v5 |
| `p2p.discovery-v4?` | `boolean` | P2P discovery v4 |
| `p2p.discovery-v5?` | `boolean` | P2P discovery v5 |
| `p2p.listen-addr?` | `string` | P2P listen address |
| `p2p.max-peers?` | `number` | P2P max peers (default 50) |
| `p2p.no-dial?` | `boolean` | P2P no dial (default true) |
| `p2p.no-discovery?` | `boolean` | P2P no discovery (default true) |
| `parent-chain?` | \{ `blob-client?`: \{ `beacon-url?`: `string` ; `blob-directory?`: `string`  } ; `connection?`: \{ `arg-log-limit?`: `number` ; `connection-wait?`: `string` ; `jwtsecret?`: `string` ; `retries?`: `number` ; `retry-delay?`: `string` ; `retry-errors?`: `string` ; `timeout?`: `string` ; `url?`: `string`  } ; `id?`: `number` ; `wallet?`: \{ `account?`: `string` ; `only-create-key?`: `boolean` ; `password?`: `string` ; `pathname?`: `string` ; `private-key?`: `string`  }  } | - |
| `parent-chain.blob-client?` | \{ `beacon-url?`: `string` ; `blob-directory?`: `string`  } | - |
| `parent-chain.blob-client.beacon-url?` | `string` | Beacon Chain RPC URL to use for fetching blobs (normally on port 3500) |
| `parent-chain.blob-client.blob-directory?` | `string` | Full path of the directory to save fetched blobs |
| `parent-chain.connection?` | \{ `arg-log-limit?`: `number` ; `connection-wait?`: `string` ; `jwtsecret?`: `string` ; `retries?`: `number` ; `retry-delay?`: `string` ; `retry-errors?`: `string` ; `timeout?`: `string` ; `url?`: `string`  } | - |
| `parent-chain.connection.arg-log-limit?` | `number` | limit size of arguments in log entries (default 2048) |
| `parent-chain.connection.connection-wait?` | `string` | how long to wait for initial connection (default 1m0s) |
| `parent-chain.connection.jwtsecret?` | `string` | path to file with jwtsecret for validation - ignored if url is self or self-auth |
| `parent-chain.connection.retries?` | `number` | number of retries in case of failure(0 mean one attempt) (default 2) |
| `parent-chain.connection.retry-delay?` | `string` | delay between retries |
| `parent-chain.connection.retry-errors?` | `string` | Errors matching this regular expression are automatically retried |
| `parent-chain.connection.timeout?` | `string` | per-response timeout (0-disabled) (default 1m0s) |
| `parent-chain.connection.url?` | `string` | url of server, use self for loopback websocket, self-auth for loopback with authentication |
| `parent-chain.id?` | `number` | if set other than 0, will be used to validate database and L1 connection |
| `parent-chain.wallet?` | \{ `account?`: `string` ; `only-create-key?`: `boolean` ; `password?`: `string` ; `pathname?`: `string` ; `private-key?`: `string`  } | - |
| `parent-chain.wallet.account?` | `string` | account to use (default is first account in keystore) |
| `parent-chain.wallet.only-create-key?` | `boolean` | if true, creates new key then exits |
| `parent-chain.wallet.password?` | `string` | wallet passphrase (default "PASSWORD_NOT_SET") |
| `parent-chain.wallet.pathname?` | `string` | pathname for wallet (default "wallet") |
| `parent-chain.wallet.private-key?` | `string` | private key for wallet |
| `persistent?` | \{ `ancient?`: `string` ; `chain?`: `string` ; `db-engine?`: `string` ; `global-config?`: `string` ; `handles?`: `number` ; `log-dir?`: `string`  } | - |
| `persistent.ancient?` | `string` | directory of ancient where the chain freezer can be opened |
| `persistent.chain?` | `string` | directory to store chain state |
| `persistent.db-engine?` | `string` | backing database implementation to use ('leveldb' or 'pebble') (default "leveldb") |
| `persistent.global-config?` | `string` | directory to store global config (default ".arbitrum") |
| `persistent.handles?` | `number` | number of file descriptor handles to use for the database (default 512) |
| `persistent.log-dir?` | `string` | directory to store log file |
| `pprof?` | `boolean` | enable pprof |
| `pprof-cfg?` | \{ `addr?`: `string` ; `port?`: `number`  } | - |
| `pprof-cfg.addr?` | `string` | pprof server address (default "127.0.0.1") |
| `pprof-cfg.port?` | `number` | pprof server port (default 6071) |
| `rpc?` | \{ `batch-request-limit?`: `number` ; `max-batch-response-size?`: `number`  } | - |
| `rpc.batch-request-limit?` | `number` | the maximum number of requests in a batch (0 means no limit) (default 1000) |
| `rpc.max-batch-response-size?` | `number` | the maximum response size for a JSON-RPC request measured in bytes (0 means no limit) (default 10000000) |
| `validation?` | \{ `api-auth?`: `boolean` ; `api-public?`: `boolean` ; `arbitrator?`: \{ `execution?`: \{ `cached-challenge-machines?`: `number` ; `initial-steps?`: `number`  } ; `execution-run-timeout?`: `string` ; `output-path?`: `string` ; `workers?`: `number`  } ; `jit?`: \{ `cranelift?`: `boolean` ; `wasm-memory-usage-limit?`: `number` ; `workers?`: `number`  } ; `use-jit?`: `boolean` ; `wasm?`: \{ `allowed-wasm-module-roots?`: `string`[] ; `enable-wasmroots-check?`: `boolean` ; `root-path?`: `string`  }  } | - |
| `validation.api-auth?` | `boolean` | validate is an authenticated API (default true) |
| `validation.api-public?` | `boolean` | validate is a public API |
| `validation.arbitrator?` | \{ `execution?`: \{ `cached-challenge-machines?`: `number` ; `initial-steps?`: `number`  } ; `execution-run-timeout?`: `string` ; `output-path?`: `string` ; `workers?`: `number`  } | - |
| `validation.arbitrator.execution?` | \{ `cached-challenge-machines?`: `number` ; `initial-steps?`: `number`  } | - |
| `validation.arbitrator.execution.cached-challenge-machines?` | `number` | how many machines to store in cache while working on a challenge (should be even) (default 4) |
| `validation.arbitrator.execution.initial-steps?` | `number` | initial steps between machines (default 100000) |
| `validation.arbitrator.execution-run-timeout?` | `string` | timeout before discarding execution run (default 15m0s) |
| `validation.arbitrator.output-path?` | `string` | path to write machines to (default "./target/output") |
| `validation.arbitrator.workers?` | `number` | number of concurrent validation threads |
| `validation.jit?` | \{ `cranelift?`: `boolean` ; `wasm-memory-usage-limit?`: `number` ; `workers?`: `number`  } | - |
| `validation.jit.cranelift?` | `boolean` | use Cranelift instead of LLVM when validating blocks using the jit-accelerated block validator (default true) |
| `validation.jit.wasm-memory-usage-limit?` | `number` | if memory used by a jit wasm exceeds this limit, a warning is logged (default 4294967296) |
| `validation.jit.workers?` | `number` | number of concurrent validation threads |
| `validation.use-jit?` | `boolean` | use jit for validation (default true) |
| `validation.wasm?` | \{ `allowed-wasm-module-roots?`: `string`[] ; `enable-wasmroots-check?`: `boolean` ; `root-path?`: `string`  } | - |
| `validation.wasm.allowed-wasm-module-roots?` | `string`[] | list of WASM module roots to check if the on-chain WASM module root belongs to on node startup |
| `validation.wasm.enable-wasmroots-check?` | `boolean` | enable check for compatibility of on-chain WASM module root with node (default true) |
| `validation.wasm.root-path?` | `string` | path to machine folders, each containing wasm files (machine.wavm.br, replay.wasm) |
| `ws?` | \{ `addr?`: `string` ; `api?`: `string`[] ; `expose-all?`: `boolean` ; `origins?`: `string`[] ; `port?`: `number` ; `rpcprefix?`: `string`  } | - |
| `ws.addr?` | `string` | WS-RPC server listening interface |
| `ws.api?` | `string`[] | APIs offered over the WS-RPC interface (default [net,web3,eth,arb]) |
| `ws.expose-all?` | `boolean` | expose private api via websocket |
| `ws.origins?` | `string`[] | Origins from which to accept websockets requests |
| `ws.port?` | `number` | WS-RPC server listening port (default 8548) |
| `ws.rpcprefix?` | `string` | WS path path prefix on which JSON-RPC is served. Use '/' to serve on all paths |

#### Defined in

[src/types/NodeConfig.generated.ts:10](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/types/NodeConfig.generated.ts#L10)

___

### NodeConfigChainInfoJson

 **NodeConfigChainInfoJson**: [\{ `chain-config`: [`ChainConfig`](modules.md#chainconfig) ; `chain-id`: `number` ; `chain-name`: `string` ; `parent-chain-id`: `number` ; `parent-chain-is-arbitrum`: `boolean` ; `rollup`: \{ `bridge`: `string` ; `deployed-at`: `number` ; `inbox`: `string` ; `rollup`: `string` ; `sequencer-inbox`: `string` ; `validator-utils`: `string` ; `validator-wallet-creator`: `string`  }  }]

#### Defined in

[src/types/NodeConfig.ts:3](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/types/NodeConfig.ts#L3)

___

### ParentChain

 **ParentChain**: typeof `chains`[`number`]

#### Defined in

[src/types/ParentChain.ts:4](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/types/ParentChain.ts#L4)

___

### ParentChainId

 **ParentChainId**: [`ParentChain`](modules.md#parentchain)[``"id"``]

#### Defined in

[src/types/ParentChain.ts:5](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/types/ParentChain.ts#L5)

___

### PrepareChainConfigParams

 **PrepareChainConfigParams**: `Pick`\<[`ChainConfig`](modules.md#chainconfig), ``"chainId"``\> & `Partial`\<`Omit`\<[`ChainConfig`](modules.md#chainconfig), ``"chainId"`` \| ``"arbitrum"``\>\> & \{ `arbitrum`: `Pick`\<[`ChainConfigArbitrumParams`](modules.md#chainconfigarbitrumparams), ``"InitialChainOwner"``\> & `Partial`\<`Omit`\<[`ChainConfigArbitrumParams`](modules.md#chainconfigarbitrumparams), ``"InitialChainOwner"``\>\>  }

#### Defined in

[src/prepareChainConfig.ts:33](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/prepareChainConfig.ts#L33)

___

### SetValidKeysetParams

 **SetValidKeysetParams**: `Object`

#### Type declaration

| Name | Type |
| :------ | :------ |
| `coreContracts` | `Pick`\<[`CoreContracts`](modules.md#corecontracts), ``"upgradeExecutor"`` \| ``"sequencerInbox"``\> |
| `keyset` | \`0x$\{string}\` |
| `publicClient` | `PublicClient` |
| `walletClient` | `WalletClient` |

#### Defined in

[src/setValidKeyset.ts:8](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/setValidKeyset.ts#L8)

___

### SetValidKeysetPrepareTransactionRequestParams

 **SetValidKeysetPrepareTransactionRequestParams**: `Omit`\<[`SetValidKeysetParams`](modules.md#setvalidkeysetparams), ``"walletClient"``\> & \{ `account`: `Address`  }

#### Defined in

[src/setValidKeysetPrepareTransactionRequest.ts:8](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/setValidKeysetPrepareTransactionRequest.ts#L8)

___

### UpgradeExecutorAbi

 **UpgradeExecutorAbi**: typeof `upgradeExecutor.abi`

#### Defined in

[src/upgradeExecutor.ts:6](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/upgradeExecutor.ts#L6)

___

### UpgradeExecutorEncodeFunctionDataParameters

 **UpgradeExecutorEncodeFunctionDataParameters**\<`TFunctionName`\>: `Prettify`\<`Omit`\<`EncodeFunctionDataParameters`\<[`UpgradeExecutorAbi`](modules.md#upgradeexecutorabi), `TFunctionName`\>, ``"abi"``\>\>

#### Type parameters

| Name | Type |
| :------ | :------ |
| `TFunctionName` | extends [`UpgradeExecutorFunctionName`](modules.md#upgradeexecutorfunctionname) |

#### Defined in

[src/upgradeExecutor.ts:10](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/upgradeExecutor.ts#L10)

___

### UpgradeExecutorFunctionName

 **UpgradeExecutorFunctionName**: `GetFunctionName`\<[`UpgradeExecutorAbi`](modules.md#upgradeexecutorabi)\>

#### Defined in

[src/upgradeExecutor.ts:8](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/upgradeExecutor.ts#L8)

## Functions

### createRollupEnoughCustomFeeTokenAllowance

**createRollupEnoughCustomFeeTokenAllowance**(`«destructured»`): `Promise`\<`boolean`\>

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `«destructured»` | `Object` | - |
| › `account` | \`0x$\{string}\` | - |
| › `nativeToken` | \`0x$\{string}\` | - |
| › `publicClient` | `Object` | - |
| › `publicClient.account` | `undefined` | The Account of the Client. |
| › `publicClient.batch?` | `Object` | Flags for batch settings. |
| › `publicClient.batch.multicall?` | `boolean` \| \{ `batchSize?`: `number` ; `wait?`: `number`  } | Toggle to enable `eth_call` multicall aggregation. |
| › `publicClient.cacheTime` | `number` | Time (in ms) that cached data will remain in memory. |
| › `publicClient.call` | (`parameters`: `CallParameters`\<`undefined` \| `Chain`\>) => `Promise`\<`CallReturnType`\> | Executes a new message call immediately without submitting a transaction to the network. - Docs: https://viem.sh/docs/actions/public/call.html - JSON-RPC Methods: [`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const data = await client.call({ account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', }) ``` |
| › `publicClient.chain` | `undefined` \| `Chain` | Chain for the client. |
| › `publicClient.createBlockFilter` | () => `Promise`\<\{ `id`: \`0x$\{string}\` ; `request`: `EIP1193RequestFn`\<readonly [\{ `Method`: ``"eth_getFilterChanges"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: \`0x$\{(...)}\`[] \| `RpcLog`[]  }, \{ `Method`: ``"eth_getFilterLogs"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `RpcLog`[]  }, \{ `Method`: ``"eth_uninstallFilter"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `boolean`  }]\> ; `type`: ``"block"``  }\> | Creates a Filter to listen for new block hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html). - Docs: https://viem.sh/docs/actions/public/createBlockFilter.html - JSON-RPC Methods: [`eth_newBlockFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newBlockFilter) **`Example`** ```ts import { createPublicClient, createBlockFilter, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await createBlockFilter(client) // { id: "0x345a6572337856574a76364e457a4366", type: 'block' } ``` |
| › `publicClient.createContractEventFilter` | \<TAbi, TEventName, TArgs, TStrict, TFromBlock, TToBlock\>(`args`: `CreateContractEventFilterParameters`\<`TAbi`, `TEventName`, `TArgs`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`CreateContractEventFilterReturnType`\<`TAbi`, `TEventName`, `TArgs`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Creates a Filter to retrieve event logs that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html) or [`getFilterLogs`](https://viem.sh/docs/actions/public/getFilterLogs.html). - Docs: https://viem.sh/docs/contract/createContractEventFilter.html **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createContractEventFilter({ abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']), }) ``` |
| › `publicClient.createEventFilter` | \<TAbiEvent, TAbiEvents, TStrict, TFromBlock, TToBlock, _EventName, _Args\>(`args?`: `CreateEventFilterParameters`\<`TAbiEvent`, `TAbiEvents`, `TStrict`, `TFromBlock`, `TToBlock`, `_EventName`, `_Args`\>) => `Promise`\<\{ [K in string \| number \| symbol]: Filter\<"event", TAbiEvents, \_EventName, \_Args, TStrict, TFromBlock, TToBlock\>[K] }\> | Creates a [`Filter`](https://viem.sh/docs/glossary/types.html#filter) to listen for new events that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html). - Docs: https://viem.sh/docs/actions/public/createEventFilter.html - JSON-RPC Methods: [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createEventFilter({ address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2', }) ``` |
| › `publicClient.createPendingTransactionFilter` | () => `Promise`\<\{ `id`: \`0x$\{string}\` ; `request`: `EIP1193RequestFn`\<readonly [\{ `Method`: ``"eth_getFilterChanges"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: \`0x$\{(...)}\`[] \| `RpcLog`[]  }, \{ `Method`: ``"eth_getFilterLogs"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `RpcLog`[]  }, \{ `Method`: ``"eth_uninstallFilter"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `boolean`  }]\> ; `type`: ``"transaction"``  }\> | Creates a Filter to listen for new pending transaction hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html). - Docs: https://viem.sh/docs/actions/public/createPendingTransactionFilter.html - JSON-RPC Methods: [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createPendingTransactionFilter() // { id: "0x345a6572337856574a76364e457a4366", type: 'transaction' } ``` |
| › `publicClient.estimateContractGas` | \<TChain, TAbi, TFunctionName\>(`args`: `EstimateContractGasParameters`\<`TAbi`, `TFunctionName`, `TChain`, `undefined` \| `Account`\>) => `Promise`\<`bigint`\> | Estimates the gas required to successfully execute a contract write function call. - Docs: https://viem.sh/docs/contract/estimateContractGas.html **`Remarks`** Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`estimateGas` action](https://viem.sh/docs/actions/public/estimateGas.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html). **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const gas = await client.estimateContractGas({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['function mint() public']), functionName: 'mint', account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', }) ``` |
| › `publicClient.estimateFeesPerGas` | \<TChainOverride, TType\>(`args?`: `EstimateFeesPerGasParameters`\<`undefined` \| `Chain`, `TChainOverride`, `TType`\>) => `Promise`\<`EstimateFeesPerGasReturnType`\> | Returns an estimate for the fees per gas for a transaction to be included in the next block. - Docs: https://viem.sh/docs/actions/public/estimateFeesPerGas.html **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const maxPriorityFeePerGas = await client.estimateFeesPerGas() // { maxFeePerGas: ..., maxPriorityFeePerGas: ... } ``` |
| › `publicClient.estimateGas` | (`args`: `EstimateGasParameters`\<`undefined` \| `Chain`, `undefined` \| `Account`\>) => `Promise`\<`bigint`\> | Estimates the gas necessary to complete a transaction without submitting it to the network. - Docs: https://viem.sh/docs/actions/public/estimateGas.html - JSON-RPC Methods: [`eth_estimateGas`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas) **`Example`** ```ts import { createPublicClient, http, parseEther } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const gasEstimate = await client.estimateGas({ account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', value: parseEther('1'), }) ``` |
| › `publicClient.estimateMaxPriorityFeePerGas` | \<TChainOverride\>(`args?`: \{ `chain`: ``null`` \| `TChainOverride`  }) => `Promise`\<`bigint`\> | Returns an estimate for the max priority fee per gas (in wei) for a transaction to be included in the next block. - Docs: https://viem.sh/docs/actions/public/estimateMaxPriorityFeePerGas.html **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const maxPriorityFeePerGas = await client.estimateMaxPriorityFeePerGas() // 10000000n ``` |
| › `publicClient.extend` | \<client\>(`fn`: (`client`: `Client`\<`Transport`, `undefined` \| `Chain`, `undefined`, `PublicRpcSchema`, `PublicActions`\<`Transport`, `undefined` \| `Chain`\>\>) => `client`) => `Client`\<`Transport`, `undefined` \| `Chain`, `undefined`, `PublicRpcSchema`, \{ [K in string \| number \| symbol]: client[K] } & `PublicActions`\<`Transport`, `undefined` \| `Chain`\>\> | - |
| › `publicClient.getBalance` | (`args`: `GetBalanceParameters`) => `Promise`\<`bigint`\> | Returns the balance of an address in wei. - Docs: https://viem.sh/docs/actions/public/getBalance.html - JSON-RPC Methods: [`eth_getBalance`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getbalance) **`Remarks`** You can convert the balance to ether units with [`formatEther`](https://viem.sh/docs/utilities/formatEther.html). ```ts const balance = await getBalance(client, { address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', blockTag: 'safe' }) const balanceAsEther = formatEther(balance) // "6.942" ``` **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const balance = await client.getBalance({ address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', }) // 10000000000000000000000n (wei) ``` |
| › `publicClient.getBlock` | \<TIncludeTransactions, TBlockTag\>(`args?`: `GetBlockParameters`\<`TIncludeTransactions`, `TBlockTag`\>) => `Promise`\<`GetBlockReturnType`\<`undefined` \| `Chain`, `TIncludeTransactions`, `TBlockTag`\>\> | Returns information about a block at a block number, hash, or tag. - Docs: https://viem.sh/docs/actions/public/getBlock.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/fetching-blocks - JSON-RPC Methods: - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) for `blockNumber` & `blockTag`. - Calls [`eth_getBlockByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbyhash) for `blockHash`. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const block = await client.getBlock() ``` |
| › `publicClient.getBlockNumber` | (`args?`: `GetBlockNumberParameters`) => `Promise`\<`bigint`\> | Returns the number of the most recent block seen. - Docs: https://viem.sh/docs/actions/public/getBlockNumber.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/fetching-blocks - JSON-RPC Methods: [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const blockNumber = await client.getBlockNumber() // 69420n ``` |
| › `publicClient.getBlockTransactionCount` | (`args?`: `GetBlockTransactionCountParameters`) => `Promise`\<`number`\> | Returns the number of Transactions at a block number, hash, or tag. - Docs: https://viem.sh/docs/actions/public/getBlockTransactionCount.html - JSON-RPC Methods: - Calls [`eth_getBlockTransactionCountByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbynumber) for `blockNumber` & `blockTag`. - Calls [`eth_getBlockTransactionCountByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbyhash) for `blockHash`. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const count = await client.getBlockTransactionCount() ``` |
| › `publicClient.getBytecode` | (`args`: `GetBytecodeParameters`) => `Promise`\<`GetBytecodeReturnType`\> | Retrieves the bytecode at an address. - Docs: https://viem.sh/docs/contract/getBytecode.html - JSON-RPC Methods: [`eth_getCode`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getcode) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const code = await client.getBytecode({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', }) ``` |
| › `publicClient.getChainId` | () => `Promise`\<`number`\> | Returns the chain ID associated with the current network. - Docs: https://viem.sh/docs/actions/public/getChainId.html - JSON-RPC Methods: [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const chainId = await client.getChainId() // 1 ``` |
| › `publicClient.getContractEvents` | \<TAbi, TEventName, TStrict, TFromBlock, TToBlock\>(`args`: `GetContractEventsParameters`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetContractEventsReturnType`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of event logs emitted by a contract. - Docs: https://viem.sh/docs/actions/public/getContractEvents.html - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { wagmiAbi } from './abi' const client = createPublicClient({ chain: mainnet, transport: http(), }) const logs = await client.getContractEvents(client, { address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: wagmiAbi, eventName: 'Transfer' }) ``` |
| › `publicClient.getEnsAddress` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `coinType?`: `number` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsAddressReturnType`\> | Gets address for ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsAddress.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const ensAddress = await client.getEnsAddress({ name: normalize('wevm.eth'), }) // '0xd2135CfB216b74109775236E36d4b433F1DF507B' ``` |
| › `publicClient.getEnsAvatar` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `gatewayUrls?`: `AssetGatewayUrls` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsAvatarReturnType`\> | Gets the avatar of an ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsAvatar.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls [`getEnsText`](https://viem.sh/docs/ens/actions/getEnsText.html) with `key` set to `'avatar'`. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const ensAvatar = await client.getEnsAvatar({ name: normalize('wevm.eth'), }) // 'https://ipfs.io/ipfs/Qma8mnp6xV3J2cRNf3mTth5C8nV11CAnceVinc3y8jSbio' ``` |
| › `publicClient.getEnsName` | (`args`: \{ `address`: \`0x$\{string}\` ; `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsNameReturnType`\> | Gets primary name for specified address. - Docs: https://viem.sh/docs/ens/actions/getEnsName.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `reverse(bytes)` on ENS Universal Resolver Contract to "reverse resolve" the address to the primary ENS name. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const ensName = await client.getEnsName({ address: '0xd2135CfB216b74109775236E36d4b433F1DF507B', }) // 'wevm.eth' ``` |
| › `publicClient.getEnsResolver` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<\`0x$\{string}\`\> | Gets resolver for ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `findResolver(bytes)` on ENS Universal Resolver Contract to retrieve the resolver of an ENS name. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const resolverAddress = await client.getEnsResolver({ name: normalize('wevm.eth'), }) // '0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41' ``` |
| › `publicClient.getEnsText` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `key`: `string` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsTextReturnType`\> | Gets a text record for specified ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const twitterRecord = await client.getEnsText({ name: normalize('wevm.eth'), key: 'com.twitter', }) // 'wagmi_sh' ``` |
| › `publicClient.getFeeHistory` | (`args`: `GetFeeHistoryParameters`) => `Promise`\<`GetFeeHistoryReturnType`\> | Returns a collection of historical gas information. - Docs: https://viem.sh/docs/actions/public/getFeeHistory.html - JSON-RPC Methods: [`eth_feeHistory`](https://docs.alchemy.com/reference/eth-feehistory) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const feeHistory = await client.getFeeHistory({ blockCount: 4, rewardPercentiles: [25, 75], }) ``` |
| › `publicClient.getFilterChanges` | \<TFilterType, TAbi, TEventName, TStrict, TFromBlock, TToBlock\>(`args`: `GetFilterChangesParameters`\<`TFilterType`, `TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetFilterChangesReturnType`\<`TFilterType`, `TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of logs or hashes based on a [Filter](/docs/glossary/terms#filter) since the last time it was called. - Docs: https://viem.sh/docs/actions/public/getFilterChanges.html - JSON-RPC Methods: [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges) **`Remarks`** A Filter can be created from the following actions: - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter.html) - [`createContractEventFilter`](https://viem.sh/docs/contract/createContractEventFilter.html) - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter.html) - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter.html) Depending on the type of filter, the return value will be different: - If the filter was created with `createContractEventFilter` or `createEventFilter`, it returns a list of logs. - If the filter was created with `createPendingTransactionFilter`, it returns a list of transaction hashes. - If the filter was created with `createBlockFilter`, it returns a list of block hashes. **`Example`** ```ts // Blocks import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createBlockFilter() const hashes = await client.getFilterChanges({ filter }) ``` **`Example`** ```ts // Contract Events import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createContractEventFilter({ address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']), eventName: 'Transfer', }) const logs = await client.getFilterChanges({ filter }) ``` **`Example`** ```ts // Raw Events import { createPublicClient, http, parseAbiItem } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createEventFilter({ address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'), }) const logs = await client.getFilterChanges({ filter }) ``` **`Example`** ```ts // Transactions import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createPendingTransactionFilter() const hashes = await client.getFilterChanges({ filter }) ``` |
| › `publicClient.getFilterLogs` | \<TAbi, TEventName, TStrict, TFromBlock, TToBlock\>(`args`: `GetFilterLogsParameters`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetFilterLogsReturnType`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of event logs since the filter was created. - Docs: https://viem.sh/docs/actions/public/getFilterLogs.html - JSON-RPC Methods: [`eth_getFilterLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterlogs) **`Remarks`** `getFilterLogs` is only compatible with **event filters**. **`Example`** ```ts import { createPublicClient, http, parseAbiItem } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createEventFilter({ address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'), }) const logs = await client.getFilterLogs({ filter }) ``` |
| › `publicClient.getGasPrice` | () => `Promise`\<`bigint`\> | Returns the current price of gas (in wei). - Docs: https://viem.sh/docs/actions/public/getGasPrice.html - JSON-RPC Methods: [`eth_gasPrice`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gasprice) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const gasPrice = await client.getGasPrice() ``` |
| › `publicClient.getLogs` | \<TAbiEvent, TAbiEvents, TStrict, TFromBlock, TToBlock\>(`args?`: `GetLogsParameters`\<`TAbiEvent`, `TAbiEvents`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetLogsReturnType`\<`TAbiEvent`, `TAbiEvents`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of event logs matching the provided parameters. - Docs: https://viem.sh/docs/actions/public/getLogs.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/filters-and-logs/event-logs - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) **`Example`** ```ts import { createPublicClient, http, parseAbiItem } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const logs = await client.getLogs() ``` |
| › `publicClient.getProof` | (`args`: `GetProofParameters`) => `Promise`\<`GetProofReturnType`\> | Returns the account and storage values of the specified account including the Merkle-proof. - Docs: https://viem.sh/docs/actions/public/getProof.html - JSON-RPC Methods: - Calls [`eth_getProof`](https://eips.ethereum.org/EIPS/eip-1186) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const block = await client.getProof({ address: '0x...', storageKeys: ['0x...'], }) ``` |
| › `publicClient.getStorageAt` | (`args`: `GetStorageAtParameters`) => `Promise`\<`GetStorageAtReturnType`\> | Returns the value from a storage slot at a given address. - Docs: https://viem.sh/docs/contract/getStorageAt.html - JSON-RPC Methods: [`eth_getStorageAt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getstorageat) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { getStorageAt } from 'viem/contract' const client = createPublicClient({ chain: mainnet, transport: http(), }) const code = await client.getStorageAt({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', slot: toHex(0), }) ``` |
| › `publicClient.getTransaction` | \<TBlockTag\>(`args`: `GetTransactionParameters`\<`TBlockTag`\>) => `Promise`\<`GetTransactionReturnType`\<`undefined` \| `Chain`, `TBlockTag`\>\> | Returns information about a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) given a hash or block identifier. - Docs: https://viem.sh/docs/actions/public/getTransaction.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/fetching-transactions - JSON-RPC Methods: [`eth_getTransactionByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionByHash) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transaction = await client.getTransaction({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `publicClient.getTransactionConfirmations` | (`args`: `GetTransactionConfirmationsParameters`\<`undefined` \| `Chain`\>) => `Promise`\<`bigint`\> | Returns the number of blocks passed (confirmations) since the transaction was processed on a block. - Docs: https://viem.sh/docs/actions/public/getTransactionConfirmations.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/fetching-transactions - JSON-RPC Methods: [`eth_getTransactionConfirmations`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionConfirmations) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const confirmations = await client.getTransactionConfirmations({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `publicClient.getTransactionCount` | (`args`: `GetTransactionCountParameters`) => `Promise`\<`number`\> | Returns the number of [Transactions](https://viem.sh/docs/glossary/terms.html#transaction) an Account has broadcast / sent. - Docs: https://viem.sh/docs/actions/public/getTransactionCount.html - JSON-RPC Methods: [`eth_getTransactionCount`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactioncount) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transactionCount = await client.getTransactionCount({ address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', }) ``` |
| › `publicClient.getTransactionReceipt` | (`args`: `GetTransactionReceiptParameters`) => `Promise`\<`TransactionReceipt`\> | Returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt) given a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash. - Docs: https://viem.sh/docs/actions/public/getTransactionReceipt.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/fetching-transactions - JSON-RPC Methods: [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transactionReceipt = await client.getTransactionReceipt({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `publicClient.key` | `string` | A key for the client. |
| › `publicClient.multicall` | \<TContracts, TAllowFailure\>(`args`: `MulticallParameters`\<`TContracts`, `TAllowFailure`\>) => `Promise`\<`MulticallReturnType`\<`TContracts`, `TAllowFailure`\>\> | Similar to [`readContract`](https://viem.sh/docs/contract/readContract.html), but batches up multiple functions on a contract in a single RPC call via the [`multicall3` contract](https://github.com/mds1/multicall). - Docs: https://viem.sh/docs/contract/multicall.html **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const abi = parseAbi([ 'function balanceOf(address) view returns (uint256)', 'function totalSupply() view returns (uint256)', ]) const result = await client.multicall({ contracts: [ { address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi, functionName: 'balanceOf', args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'], }, { address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi, functionName: 'totalSupply', }, ], }) // [{ result: 424122n, status: 'success' }, { result: 1000000n, status: 'success' }] ``` |
| › `publicClient.name` | `string` | A name for the client. |
| › `publicClient.pollingInterval` | `number` | Frequency (in ms) for polling enabled actions & events. Defaults to 4_000 milliseconds. |
| › `publicClient.prepareTransactionRequest` | \<TChainOverride\>(`args`: `PrepareTransactionRequestParameters`\<`undefined` \| `Chain`, `undefined` \| `Account`, `TChainOverride`\>) => `Promise`\<`PrepareTransactionRequestReturnType`\> | Prepares a transaction request for signing. - Docs: https://viem.sh/docs/actions/wallet/prepareTransactionRequest.html **`Example`** ```ts import { createWalletClient, custom } from 'viem' import { mainnet } from 'viem/chains' const client = createWalletClient({ chain: mainnet, transport: custom(window.ethereum), }) const request = await client.prepareTransactionRequest({ account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', to: '0x0000000000000000000000000000000000000000', value: 1n, }) ``` **`Example`** ```ts // Account Hoisting import { createWalletClient, http } from 'viem' import { privateKeyToAccount } from 'viem/accounts' import { mainnet } from 'viem/chains' const client = createWalletClient({ account: privateKeyToAccount('0x…'), chain: mainnet, transport: custom(window.ethereum), }) const request = await client.prepareTransactionRequest({ to: '0x0000000000000000000000000000000000000000', value: 1n, }) ``` |
| › `publicClient.readContract` | \<TAbi, TFunctionName\>(`args`: `ReadContractParameters`\<`TAbi`, `TFunctionName`\>) => `Promise`\<`ReadContractReturnType`\<`TAbi`, `TFunctionName`\>\> | Calls a read-only function on a contract, and returns the response. - Docs: https://viem.sh/docs/contract/readContract.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts/reading-contracts **`Remarks`** A "read-only" function (constant function) on a Solidity contract is denoted by a `view` or `pure` keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas. Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html). **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' import { readContract } from 'viem/contract' const client = createPublicClient({ chain: mainnet, transport: http(), }) const result = await client.readContract({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['function balanceOf(address) view returns (uint256)']), functionName: 'balanceOf', args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'], }) // 424122n ``` |
| › `publicClient.request` | `EIP1193RequestFn`\<`PublicRpcSchema`\> | Request function wrapped with friendly error handling |
| › `publicClient.sendRawTransaction` | (`args`: `SendRawTransactionParameters`) => `Promise`\<\`0x$\{string}\`\> | Sends a **signed** transaction to the network - Docs: https://viem.sh/docs/actions/wallet/sendRawTransaction.html - JSON-RPC Method: [`eth_sendRawTransaction`](https://ethereum.github.io/execution-apis/api-documentation/) **`Example`** ```ts import { createWalletClient, custom } from 'viem' import { mainnet } from 'viem/chains' import { sendRawTransaction } from 'viem/wallet' const client = createWalletClient({ chain: mainnet, transport: custom(window.ethereum), }) const hash = await client.sendRawTransaction({ serializedTransaction: '0x02f850018203118080825208808080c080a04012522854168b27e5dc3d5839bab5e6b39e1a0ffd343901ce1622e3d64b48f1a04e00902ae0502c4728cbf12156290df99c3ed7de85b1dbfe20b5c36931733a33' }) ``` |
| › `publicClient.simulateContract` | \<TAbi, TFunctionName, TChainOverride\>(`args`: `SimulateContractParameters`\<`TAbi`, `TFunctionName`, `undefined` \| `Chain`, `TChainOverride`\>) => `Promise`\<`SimulateContractReturnType`\<`TAbi`, `TFunctionName`, `undefined` \| `Chain`, `TChainOverride`\>\> | Simulates/validates a contract interaction. This is useful for retrieving **return data** and **revert reasons** of contract write functions. - Docs: https://viem.sh/docs/contract/simulateContract.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts/writing-to-contracts **`Remarks`** This function does not require gas to execute and _**does not**_ change the state of the blockchain. It is almost identical to [`readContract`](https://viem.sh/docs/contract/readContract.html), but also supports contract write functions. Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html). **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const result = await client.simulateContract({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['function mint(uint32) view returns (uint32)']), functionName: 'mint', args: ['69420'], account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', }) ``` |
| › `publicClient.transport` | `TransportConfig`\<`string`, `EIP1193RequestFn`\> & `Record`\<`string`, `any`\> | The RPC transport |
| › `publicClient.type` | `string` | The type of client. |
| › `publicClient.uid` | `string` | A unique ID for the client. |
| › `publicClient.uninstallFilter` | (`args`: `UninstallFilterParameters`) => `Promise`\<`boolean`\> | Destroys a Filter that was created from one of the following Actions: - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter.html) - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter.html) - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter.html) - Docs: https://viem.sh/docs/actions/public/uninstallFilter.html - JSON-RPC Methods: [`eth_uninstallFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_uninstallFilter) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { createPendingTransactionFilter, uninstallFilter } from 'viem/public' const filter = await client.createPendingTransactionFilter() const uninstalled = await client.uninstallFilter({ filter }) // true ``` |
| › `publicClient.verifyMessage` | (`args`: `VerifyMessageParameters`) => `Promise`\<`boolean`\> | - |
| › `publicClient.verifyTypedData` | (`args`: `VerifyTypedDataParameters`) => `Promise`\<`boolean`\> | - |
| › `publicClient.waitForTransactionReceipt` | (`args`: `WaitForTransactionReceiptParameters`\<`undefined` \| `Chain`\>) => `Promise`\<`TransactionReceipt`\> | Waits for the [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms.html#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt). If the Transaction reverts, then the action will throw an error. - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/sending-transactions - JSON-RPC Methods: - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed. - If a Transaction has been replaced: - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions - Checks if one of the Transactions is a replacement - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt). **`Remarks`** The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions). Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce. There are 3 types of Transaction Replacement reasons: - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`) - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`) - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transactionReceipt = await client.waitForTransactionReceipt({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `publicClient.watchBlockNumber` | (`args`: `WatchBlockNumberParameters`) => `WatchBlockNumberReturnType` | Watches and returns incoming block numbers. - Docs: https://viem.sh/docs/actions/public/watchBlockNumber.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/watching-blocks - JSON-RPC Methods: - When `poll: true`, calls [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) on a polling interval. - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newHeads"` event. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = await client.watchBlockNumber({ onBlockNumber: (blockNumber) => console.log(blockNumber), }) ``` |
| › `publicClient.watchBlocks` | \<TIncludeTransactions, TBlockTag\>(`args`: `WatchBlocksParameters`\<`Transport`, `undefined` \| `Chain`, `TIncludeTransactions`, `TBlockTag`\>) => `WatchBlocksReturnType` | Watches and returns information for incoming blocks. - Docs: https://viem.sh/docs/actions/public/watchBlocks.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/watching-blocks - JSON-RPC Methods: - When `poll: true`, calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getBlockByNumber) on a polling interval. - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newHeads"` event. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = await client.watchBlocks({ onBlock: (block) => console.log(block), }) ``` |
| › `publicClient.watchContractEvent` | \<TAbi, TEventName, TStrict\>(`args`: `WatchContractEventParameters`\<`TAbi`, `TEventName`, `TStrict`\>) => `WatchContractEventReturnType` | Watches and returns emitted contract event logs. - Docs: https://viem.sh/docs/contract/watchContractEvent.html **`Remarks`** This Action will batch up all the event logs found within the [`pollingInterval`](https://viem.sh/docs/contract/watchContractEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/contract/watchContractEvent.html#onLogs). `watchContractEvent` will attempt to create an [Event Filter](https://viem.sh/docs/contract/createContractEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchContractEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs.html) instead. **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = client.watchContractEvent({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['event Transfer(address indexed from, address indexed to, uint256 value)']), eventName: 'Transfer', args: { from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b' }, onLogs: (logs) => console.log(logs), }) ``` |
| › `publicClient.watchEvent` | \<TAbiEvent, TAbiEvents, TStrict\>(`args`: `WatchEventParameters`\<`TAbiEvent`, `TAbiEvents`, `TStrict`\>) => `WatchEventReturnType` | Watches and returns emitted [Event Logs](https://viem.sh/docs/glossary/terms.html#event-log). - Docs: https://viem.sh/docs/actions/public/watchEvent.html - JSON-RPC Methods: - **RPC Provider supports `eth_newFilter`:** - Calls [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) to create a filter (called on initialize). - On a polling interval, it will call [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges). - **RPC Provider does not support `eth_newFilter`:** - Calls [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) for each block between the polling interval. **`Remarks`** This Action will batch up all the Event Logs found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/actions/public/watchEvent.html#onLogs). `watchEvent` will attempt to create an [Event Filter](https://viem.sh/docs/actions/public/createEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs.html) instead. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = client.watchEvent({ onLogs: (logs) => console.log(logs), }) ``` |
| › `publicClient.watchPendingTransactions` | (`args`: `WatchPendingTransactionsParameters`\<`Transport`\>) => `WatchPendingTransactionsReturnType` | Watches and returns pending transaction hashes. - Docs: https://viem.sh/docs/actions/public/watchPendingTransactions.html - JSON-RPC Methods: - When `poll: true` - Calls [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) to initialize the filter. - Calls [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getFilterChanges) on a polling interval. - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newPendingTransactions"` event. **`Remarks`** This Action will batch up all the pending transactions found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#pollinginterval-optional), and invoke them via [`onTransactions`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#ontransactions). **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = await client.watchPendingTransactions({ onTransactions: (hashes) => console.log(hashes), }) ``` |
| › `rollupCreatorAddressOverride?` | \`0x$\{string}\` | Specifies a custom address for the RollupCreator. By default, the address will be automatically detected based on the provided chain. |

#### Returns

`Promise`\<`boolean`\>

#### Defined in

[src/createRollupEnoughCustomFeeTokenAllowance.ts:18](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/createRollupEnoughCustomFeeTokenAllowance.ts#L18)

___

### createRollupFetchCoreContracts

**createRollupFetchCoreContracts**(`«destructured»`): `Promise`\<[`CoreContracts`](modules.md#corecontracts)\>

#### Parameters

| Name | Type |
| :------ | :------ |
| `«destructured»` | `CreateRollupFetchCoreContractsParams` |

#### Returns

`Promise`\<[`CoreContracts`](modules.md#corecontracts)\>

#### Defined in

[src/createRollupFetchCoreContracts.ts:12](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/createRollupFetchCoreContracts.ts#L12)

___

### createRollupFetchTransactionHash

**createRollupFetchTransactionHash**(`«destructured»`): `Promise`\<\`0x$\{string}\`\>

#### Parameters

| Name | Type |
| :------ | :------ |
| `«destructured»` | [`CreateRollupFetchTransactionHashParams`](modules.md#createrollupfetchtransactionhashparams) |

#### Returns

`Promise`\<\`0x$\{string}\`\>

#### Defined in

[src/createRollupFetchTransactionHash.ts:57](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/createRollupFetchTransactionHash.ts#L57)

___

### createRollupPrepareConfig

**createRollupPrepareConfig**(`«destructured»`): [`CreateRollupPrepareConfigResult`](modules.md#createrollupprepareconfigresult)

#### Parameters

| Name | Type |
| :------ | :------ |
| `«destructured»` | [`CreateRollupPrepareConfigParams`](modules.md#createrollupprepareconfigparams) |

#### Returns

[`CreateRollupPrepareConfigResult`](modules.md#createrollupprepareconfigresult)

#### Defined in

[src/createRollupPrepareConfig.ts:36](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/createRollupPrepareConfig.ts#L36)

___

### createRollupPrepareCustomFeeTokenApprovalTransactionRequest

**createRollupPrepareCustomFeeTokenApprovalTransactionRequest**(`«destructured»`): `Promise`\<\{ `accessList?`: `undefined` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `bigint` ; `maxFeePerGas?`: `undefined` ; `maxPriorityFeePerGas?`: `undefined` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"legacy"`` ; `value?`: `bigint`  } \| \{ `accessList?`: `AccessList` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `bigint` ; `maxFeePerGas?`: `undefined` ; `maxPriorityFeePerGas?`: `undefined` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"eip2930"`` ; `value?`: `bigint`  } \| \{ `accessList?`: `AccessList` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `undefined` ; `maxFeePerGas?`: `bigint` ; `maxPriorityFeePerGas?`: `bigint` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"eip1559"`` ; `value?`: `bigint`  }\>

#### Parameters

| Name | Type | Default value | Description |
| :------ | :------ | :------ | :------ |
| `«destructured»` | `Object` | `undefined` | - |
| › `account` | \`0x$\{string}\` | `undefined` | - |
| › `amount?` | `bigint` | `createRollupDefaultRetryablesFees` | - |
| › `nativeToken` | \`0x$\{string}\` | `undefined` | - |
| › `publicClient` | `Object` | `undefined` | - |
| › `publicClient.account` | `undefined` | `undefined` | The Account of the Client. |
| › `publicClient.batch?` | `Object` | `undefined` | Flags for batch settings. |
| › `publicClient.batch.multicall?` | `boolean` \| \{ `batchSize?`: `number` ; `wait?`: `number`  } | `undefined` | Toggle to enable `eth_call` multicall aggregation. |
| › `publicClient.cacheTime` | `number` | `undefined` | Time (in ms) that cached data will remain in memory. |
| › `publicClient.call` | (`parameters`: `CallParameters`\<`undefined` \| `Chain`\>) => `Promise`\<`CallReturnType`\> | `undefined` | Executes a new message call immediately without submitting a transaction to the network. - Docs: https://viem.sh/docs/actions/public/call.html - JSON-RPC Methods: [`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const data = await client.call({ account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', }) ``` |
| › `publicClient.chain` | `undefined` \| `Chain` | `undefined` | Chain for the client. |
| › `publicClient.createBlockFilter` | () => `Promise`\<\{ `id`: \`0x$\{string}\` ; `request`: `EIP1193RequestFn`\<readonly [\{ `Method`: ``"eth_getFilterChanges"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: \`0x$\{(...)}\`[] \| `RpcLog`[]  }, \{ `Method`: ``"eth_getFilterLogs"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `RpcLog`[]  }, \{ `Method`: ``"eth_uninstallFilter"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `boolean`  }]\> ; `type`: ``"block"``  }\> | `undefined` | Creates a Filter to listen for new block hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html). - Docs: https://viem.sh/docs/actions/public/createBlockFilter.html - JSON-RPC Methods: [`eth_newBlockFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newBlockFilter) **`Example`** ```ts import { createPublicClient, createBlockFilter, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await createBlockFilter(client) // { id: "0x345a6572337856574a76364e457a4366", type: 'block' } ``` |
| › `publicClient.createContractEventFilter` | \<TAbi, TEventName, TArgs, TStrict, TFromBlock, TToBlock\>(`args`: `CreateContractEventFilterParameters`\<`TAbi`, `TEventName`, `TArgs`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`CreateContractEventFilterReturnType`\<`TAbi`, `TEventName`, `TArgs`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | `undefined` | Creates a Filter to retrieve event logs that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html) or [`getFilterLogs`](https://viem.sh/docs/actions/public/getFilterLogs.html). - Docs: https://viem.sh/docs/contract/createContractEventFilter.html **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createContractEventFilter({ abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']), }) ``` |
| › `publicClient.createEventFilter` | \<TAbiEvent, TAbiEvents, TStrict, TFromBlock, TToBlock, _EventName, _Args\>(`args?`: `CreateEventFilterParameters`\<`TAbiEvent`, `TAbiEvents`, `TStrict`, `TFromBlock`, `TToBlock`, `_EventName`, `_Args`\>) => `Promise`\<\{ [K in string \| number \| symbol]: Filter\<"event", TAbiEvents, \_EventName, \_Args, TStrict, TFromBlock, TToBlock\>[K] }\> | `undefined` | Creates a [`Filter`](https://viem.sh/docs/glossary/types.html#filter) to listen for new events that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html). - Docs: https://viem.sh/docs/actions/public/createEventFilter.html - JSON-RPC Methods: [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createEventFilter({ address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2', }) ``` |
| › `publicClient.createPendingTransactionFilter` | () => `Promise`\<\{ `id`: \`0x$\{string}\` ; `request`: `EIP1193RequestFn`\<readonly [\{ `Method`: ``"eth_getFilterChanges"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: \`0x$\{(...)}\`[] \| `RpcLog`[]  }, \{ `Method`: ``"eth_getFilterLogs"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `RpcLog`[]  }, \{ `Method`: ``"eth_uninstallFilter"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `boolean`  }]\> ; `type`: ``"transaction"``  }\> | `undefined` | Creates a Filter to listen for new pending transaction hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html). - Docs: https://viem.sh/docs/actions/public/createPendingTransactionFilter.html - JSON-RPC Methods: [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createPendingTransactionFilter() // { id: "0x345a6572337856574a76364e457a4366", type: 'transaction' } ``` |
| › `publicClient.estimateContractGas` | \<TChain, TAbi, TFunctionName\>(`args`: `EstimateContractGasParameters`\<`TAbi`, `TFunctionName`, `TChain`, `undefined` \| `Account`\>) => `Promise`\<`bigint`\> | `undefined` | Estimates the gas required to successfully execute a contract write function call. - Docs: https://viem.sh/docs/contract/estimateContractGas.html **`Remarks`** Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`estimateGas` action](https://viem.sh/docs/actions/public/estimateGas.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html). **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const gas = await client.estimateContractGas({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['function mint() public']), functionName: 'mint', account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', }) ``` |
| › `publicClient.estimateFeesPerGas` | \<TChainOverride, TType\>(`args?`: `EstimateFeesPerGasParameters`\<`undefined` \| `Chain`, `TChainOverride`, `TType`\>) => `Promise`\<`EstimateFeesPerGasReturnType`\> | `undefined` | Returns an estimate for the fees per gas for a transaction to be included in the next block. - Docs: https://viem.sh/docs/actions/public/estimateFeesPerGas.html **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const maxPriorityFeePerGas = await client.estimateFeesPerGas() // { maxFeePerGas: ..., maxPriorityFeePerGas: ... } ``` |
| › `publicClient.estimateGas` | (`args`: `EstimateGasParameters`\<`undefined` \| `Chain`, `undefined` \| `Account`\>) => `Promise`\<`bigint`\> | `undefined` | Estimates the gas necessary to complete a transaction without submitting it to the network. - Docs: https://viem.sh/docs/actions/public/estimateGas.html - JSON-RPC Methods: [`eth_estimateGas`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas) **`Example`** ```ts import { createPublicClient, http, parseEther } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const gasEstimate = await client.estimateGas({ account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', value: parseEther('1'), }) ``` |
| › `publicClient.estimateMaxPriorityFeePerGas` | \<TChainOverride\>(`args?`: \{ `chain`: ``null`` \| `TChainOverride`  }) => `Promise`\<`bigint`\> | `undefined` | Returns an estimate for the max priority fee per gas (in wei) for a transaction to be included in the next block. - Docs: https://viem.sh/docs/actions/public/estimateMaxPriorityFeePerGas.html **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const maxPriorityFeePerGas = await client.estimateMaxPriorityFeePerGas() // 10000000n ``` |
| › `publicClient.extend` | \<client\>(`fn`: (`client`: `Client`\<`Transport`, `undefined` \| `Chain`, `undefined`, `PublicRpcSchema`, `PublicActions`\<`Transport`, `undefined` \| `Chain`\>\>) => `client`) => `Client`\<`Transport`, `undefined` \| `Chain`, `undefined`, `PublicRpcSchema`, \{ [K in string \| number \| symbol]: client[K] } & `PublicActions`\<`Transport`, `undefined` \| `Chain`\>\> | `undefined` | - |
| › `publicClient.getBalance` | (`args`: `GetBalanceParameters`) => `Promise`\<`bigint`\> | `undefined` | Returns the balance of an address in wei. - Docs: https://viem.sh/docs/actions/public/getBalance.html - JSON-RPC Methods: [`eth_getBalance`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getbalance) **`Remarks`** You can convert the balance to ether units with [`formatEther`](https://viem.sh/docs/utilities/formatEther.html). ```ts const balance = await getBalance(client, { address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', blockTag: 'safe' }) const balanceAsEther = formatEther(balance) // "6.942" ``` **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const balance = await client.getBalance({ address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', }) // 10000000000000000000000n (wei) ``` |
| › `publicClient.getBlock` | \<TIncludeTransactions, TBlockTag\>(`args?`: `GetBlockParameters`\<`TIncludeTransactions`, `TBlockTag`\>) => `Promise`\<`GetBlockReturnType`\<`undefined` \| `Chain`, `TIncludeTransactions`, `TBlockTag`\>\> | `undefined` | Returns information about a block at a block number, hash, or tag. - Docs: https://viem.sh/docs/actions/public/getBlock.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/fetching-blocks - JSON-RPC Methods: - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) for `blockNumber` & `blockTag`. - Calls [`eth_getBlockByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbyhash) for `blockHash`. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const block = await client.getBlock() ``` |
| › `publicClient.getBlockNumber` | (`args?`: `GetBlockNumberParameters`) => `Promise`\<`bigint`\> | `undefined` | Returns the number of the most recent block seen. - Docs: https://viem.sh/docs/actions/public/getBlockNumber.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/fetching-blocks - JSON-RPC Methods: [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const blockNumber = await client.getBlockNumber() // 69420n ``` |
| › `publicClient.getBlockTransactionCount` | (`args?`: `GetBlockTransactionCountParameters`) => `Promise`\<`number`\> | `undefined` | Returns the number of Transactions at a block number, hash, or tag. - Docs: https://viem.sh/docs/actions/public/getBlockTransactionCount.html - JSON-RPC Methods: - Calls [`eth_getBlockTransactionCountByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbynumber) for `blockNumber` & `blockTag`. - Calls [`eth_getBlockTransactionCountByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbyhash) for `blockHash`. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const count = await client.getBlockTransactionCount() ``` |
| › `publicClient.getBytecode` | (`args`: `GetBytecodeParameters`) => `Promise`\<`GetBytecodeReturnType`\> | `undefined` | Retrieves the bytecode at an address. - Docs: https://viem.sh/docs/contract/getBytecode.html - JSON-RPC Methods: [`eth_getCode`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getcode) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const code = await client.getBytecode({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', }) ``` |
| › `publicClient.getChainId` | () => `Promise`\<`number`\> | `undefined` | Returns the chain ID associated with the current network. - Docs: https://viem.sh/docs/actions/public/getChainId.html - JSON-RPC Methods: [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const chainId = await client.getChainId() // 1 ``` |
| › `publicClient.getContractEvents` | \<TAbi, TEventName, TStrict, TFromBlock, TToBlock\>(`args`: `GetContractEventsParameters`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetContractEventsReturnType`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | `undefined` | Returns a list of event logs emitted by a contract. - Docs: https://viem.sh/docs/actions/public/getContractEvents.html - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { wagmiAbi } from './abi' const client = createPublicClient({ chain: mainnet, transport: http(), }) const logs = await client.getContractEvents(client, { address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: wagmiAbi, eventName: 'Transfer' }) ``` |
| › `publicClient.getEnsAddress` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `coinType?`: `number` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsAddressReturnType`\> | `undefined` | Gets address for ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsAddress.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const ensAddress = await client.getEnsAddress({ name: normalize('wevm.eth'), }) // '0xd2135CfB216b74109775236E36d4b433F1DF507B' ``` |
| › `publicClient.getEnsAvatar` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `gatewayUrls?`: `AssetGatewayUrls` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsAvatarReturnType`\> | `undefined` | Gets the avatar of an ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsAvatar.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls [`getEnsText`](https://viem.sh/docs/ens/actions/getEnsText.html) with `key` set to `'avatar'`. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const ensAvatar = await client.getEnsAvatar({ name: normalize('wevm.eth'), }) // 'https://ipfs.io/ipfs/Qma8mnp6xV3J2cRNf3mTth5C8nV11CAnceVinc3y8jSbio' ``` |
| › `publicClient.getEnsName` | (`args`: \{ `address`: \`0x$\{string}\` ; `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsNameReturnType`\> | `undefined` | Gets primary name for specified address. - Docs: https://viem.sh/docs/ens/actions/getEnsName.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `reverse(bytes)` on ENS Universal Resolver Contract to "reverse resolve" the address to the primary ENS name. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const ensName = await client.getEnsName({ address: '0xd2135CfB216b74109775236E36d4b433F1DF507B', }) // 'wevm.eth' ``` |
| › `publicClient.getEnsResolver` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<\`0x$\{string}\`\> | `undefined` | Gets resolver for ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `findResolver(bytes)` on ENS Universal Resolver Contract to retrieve the resolver of an ENS name. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const resolverAddress = await client.getEnsResolver({ name: normalize('wevm.eth'), }) // '0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41' ``` |
| › `publicClient.getEnsText` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `key`: `string` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsTextReturnType`\> | `undefined` | Gets a text record for specified ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const twitterRecord = await client.getEnsText({ name: normalize('wevm.eth'), key: 'com.twitter', }) // 'wagmi_sh' ``` |
| › `publicClient.getFeeHistory` | (`args`: `GetFeeHistoryParameters`) => `Promise`\<`GetFeeHistoryReturnType`\> | `undefined` | Returns a collection of historical gas information. - Docs: https://viem.sh/docs/actions/public/getFeeHistory.html - JSON-RPC Methods: [`eth_feeHistory`](https://docs.alchemy.com/reference/eth-feehistory) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const feeHistory = await client.getFeeHistory({ blockCount: 4, rewardPercentiles: [25, 75], }) ``` |
| › `publicClient.getFilterChanges` | \<TFilterType, TAbi, TEventName, TStrict, TFromBlock, TToBlock\>(`args`: `GetFilterChangesParameters`\<`TFilterType`, `TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetFilterChangesReturnType`\<`TFilterType`, `TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | `undefined` | Returns a list of logs or hashes based on a [Filter](/docs/glossary/terms#filter) since the last time it was called. - Docs: https://viem.sh/docs/actions/public/getFilterChanges.html - JSON-RPC Methods: [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges) **`Remarks`** A Filter can be created from the following actions: - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter.html) - [`createContractEventFilter`](https://viem.sh/docs/contract/createContractEventFilter.html) - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter.html) - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter.html) Depending on the type of filter, the return value will be different: - If the filter was created with `createContractEventFilter` or `createEventFilter`, it returns a list of logs. - If the filter was created with `createPendingTransactionFilter`, it returns a list of transaction hashes. - If the filter was created with `createBlockFilter`, it returns a list of block hashes. **`Example`** ```ts // Blocks import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createBlockFilter() const hashes = await client.getFilterChanges({ filter }) ``` **`Example`** ```ts // Contract Events import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createContractEventFilter({ address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']), eventName: 'Transfer', }) const logs = await client.getFilterChanges({ filter }) ``` **`Example`** ```ts // Raw Events import { createPublicClient, http, parseAbiItem } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createEventFilter({ address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'), }) const logs = await client.getFilterChanges({ filter }) ``` **`Example`** ```ts // Transactions import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createPendingTransactionFilter() const hashes = await client.getFilterChanges({ filter }) ``` |
| › `publicClient.getFilterLogs` | \<TAbi, TEventName, TStrict, TFromBlock, TToBlock\>(`args`: `GetFilterLogsParameters`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetFilterLogsReturnType`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | `undefined` | Returns a list of event logs since the filter was created. - Docs: https://viem.sh/docs/actions/public/getFilterLogs.html - JSON-RPC Methods: [`eth_getFilterLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterlogs) **`Remarks`** `getFilterLogs` is only compatible with **event filters**. **`Example`** ```ts import { createPublicClient, http, parseAbiItem } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createEventFilter({ address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'), }) const logs = await client.getFilterLogs({ filter }) ``` |
| › `publicClient.getGasPrice` | () => `Promise`\<`bigint`\> | `undefined` | Returns the current price of gas (in wei). - Docs: https://viem.sh/docs/actions/public/getGasPrice.html - JSON-RPC Methods: [`eth_gasPrice`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gasprice) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const gasPrice = await client.getGasPrice() ``` |
| › `publicClient.getLogs` | \<TAbiEvent, TAbiEvents, TStrict, TFromBlock, TToBlock\>(`args?`: `GetLogsParameters`\<`TAbiEvent`, `TAbiEvents`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetLogsReturnType`\<`TAbiEvent`, `TAbiEvents`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | `undefined` | Returns a list of event logs matching the provided parameters. - Docs: https://viem.sh/docs/actions/public/getLogs.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/filters-and-logs/event-logs - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) **`Example`** ```ts import { createPublicClient, http, parseAbiItem } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const logs = await client.getLogs() ``` |
| › `publicClient.getProof` | (`args`: `GetProofParameters`) => `Promise`\<`GetProofReturnType`\> | `undefined` | Returns the account and storage values of the specified account including the Merkle-proof. - Docs: https://viem.sh/docs/actions/public/getProof.html - JSON-RPC Methods: - Calls [`eth_getProof`](https://eips.ethereum.org/EIPS/eip-1186) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const block = await client.getProof({ address: '0x...', storageKeys: ['0x...'], }) ``` |
| › `publicClient.getStorageAt` | (`args`: `GetStorageAtParameters`) => `Promise`\<`GetStorageAtReturnType`\> | `undefined` | Returns the value from a storage slot at a given address. - Docs: https://viem.sh/docs/contract/getStorageAt.html - JSON-RPC Methods: [`eth_getStorageAt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getstorageat) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { getStorageAt } from 'viem/contract' const client = createPublicClient({ chain: mainnet, transport: http(), }) const code = await client.getStorageAt({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', slot: toHex(0), }) ``` |
| › `publicClient.getTransaction` | \<TBlockTag\>(`args`: `GetTransactionParameters`\<`TBlockTag`\>) => `Promise`\<`GetTransactionReturnType`\<`undefined` \| `Chain`, `TBlockTag`\>\> | `undefined` | Returns information about a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) given a hash or block identifier. - Docs: https://viem.sh/docs/actions/public/getTransaction.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/fetching-transactions - JSON-RPC Methods: [`eth_getTransactionByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionByHash) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transaction = await client.getTransaction({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `publicClient.getTransactionConfirmations` | (`args`: `GetTransactionConfirmationsParameters`\<`undefined` \| `Chain`\>) => `Promise`\<`bigint`\> | `undefined` | Returns the number of blocks passed (confirmations) since the transaction was processed on a block. - Docs: https://viem.sh/docs/actions/public/getTransactionConfirmations.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/fetching-transactions - JSON-RPC Methods: [`eth_getTransactionConfirmations`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionConfirmations) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const confirmations = await client.getTransactionConfirmations({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `publicClient.getTransactionCount` | (`args`: `GetTransactionCountParameters`) => `Promise`\<`number`\> | `undefined` | Returns the number of [Transactions](https://viem.sh/docs/glossary/terms.html#transaction) an Account has broadcast / sent. - Docs: https://viem.sh/docs/actions/public/getTransactionCount.html - JSON-RPC Methods: [`eth_getTransactionCount`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactioncount) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transactionCount = await client.getTransactionCount({ address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', }) ``` |
| › `publicClient.getTransactionReceipt` | (`args`: `GetTransactionReceiptParameters`) => `Promise`\<`TransactionReceipt`\> | `undefined` | Returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt) given a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash. - Docs: https://viem.sh/docs/actions/public/getTransactionReceipt.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/fetching-transactions - JSON-RPC Methods: [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transactionReceipt = await client.getTransactionReceipt({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `publicClient.key` | `string` | `undefined` | A key for the client. |
| › `publicClient.multicall` | \<TContracts, TAllowFailure\>(`args`: `MulticallParameters`\<`TContracts`, `TAllowFailure`\>) => `Promise`\<`MulticallReturnType`\<`TContracts`, `TAllowFailure`\>\> | `undefined` | Similar to [`readContract`](https://viem.sh/docs/contract/readContract.html), but batches up multiple functions on a contract in a single RPC call via the [`multicall3` contract](https://github.com/mds1/multicall). - Docs: https://viem.sh/docs/contract/multicall.html **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const abi = parseAbi([ 'function balanceOf(address) view returns (uint256)', 'function totalSupply() view returns (uint256)', ]) const result = await client.multicall({ contracts: [ { address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi, functionName: 'balanceOf', args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'], }, { address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi, functionName: 'totalSupply', }, ], }) // [{ result: 424122n, status: 'success' }, { result: 1000000n, status: 'success' }] ``` |
| › `publicClient.name` | `string` | `undefined` | A name for the client. |
| › `publicClient.pollingInterval` | `number` | `undefined` | Frequency (in ms) for polling enabled actions & events. Defaults to 4_000 milliseconds. |
| › `publicClient.prepareTransactionRequest` | \<TChainOverride\>(`args`: `PrepareTransactionRequestParameters`\<`undefined` \| `Chain`, `undefined` \| `Account`, `TChainOverride`\>) => `Promise`\<`PrepareTransactionRequestReturnType`\> | `undefined` | Prepares a transaction request for signing. - Docs: https://viem.sh/docs/actions/wallet/prepareTransactionRequest.html **`Example`** ```ts import { createWalletClient, custom } from 'viem' import { mainnet } from 'viem/chains' const client = createWalletClient({ chain: mainnet, transport: custom(window.ethereum), }) const request = await client.prepareTransactionRequest({ account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', to: '0x0000000000000000000000000000000000000000', value: 1n, }) ``` **`Example`** ```ts // Account Hoisting import { createWalletClient, http } from 'viem' import { privateKeyToAccount } from 'viem/accounts' import { mainnet } from 'viem/chains' const client = createWalletClient({ account: privateKeyToAccount('0x…'), chain: mainnet, transport: custom(window.ethereum), }) const request = await client.prepareTransactionRequest({ to: '0x0000000000000000000000000000000000000000', value: 1n, }) ``` |
| › `publicClient.readContract` | \<TAbi, TFunctionName\>(`args`: `ReadContractParameters`\<`TAbi`, `TFunctionName`\>) => `Promise`\<`ReadContractReturnType`\<`TAbi`, `TFunctionName`\>\> | `undefined` | Calls a read-only function on a contract, and returns the response. - Docs: https://viem.sh/docs/contract/readContract.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts/reading-contracts **`Remarks`** A "read-only" function (constant function) on a Solidity contract is denoted by a `view` or `pure` keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas. Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html). **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' import { readContract } from 'viem/contract' const client = createPublicClient({ chain: mainnet, transport: http(), }) const result = await client.readContract({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['function balanceOf(address) view returns (uint256)']), functionName: 'balanceOf', args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'], }) // 424122n ``` |
| › `publicClient.request` | `EIP1193RequestFn`\<`PublicRpcSchema`\> | `undefined` | Request function wrapped with friendly error handling |
| › `publicClient.sendRawTransaction` | (`args`: `SendRawTransactionParameters`) => `Promise`\<\`0x$\{string}\`\> | `undefined` | Sends a **signed** transaction to the network - Docs: https://viem.sh/docs/actions/wallet/sendRawTransaction.html - JSON-RPC Method: [`eth_sendRawTransaction`](https://ethereum.github.io/execution-apis/api-documentation/) **`Example`** ```ts import { createWalletClient, custom } from 'viem' import { mainnet } from 'viem/chains' import { sendRawTransaction } from 'viem/wallet' const client = createWalletClient({ chain: mainnet, transport: custom(window.ethereum), }) const hash = await client.sendRawTransaction({ serializedTransaction: '0x02f850018203118080825208808080c080a04012522854168b27e5dc3d5839bab5e6b39e1a0ffd343901ce1622e3d64b48f1a04e00902ae0502c4728cbf12156290df99c3ed7de85b1dbfe20b5c36931733a33' }) ``` |
| › `publicClient.simulateContract` | \<TAbi, TFunctionName, TChainOverride\>(`args`: `SimulateContractParameters`\<`TAbi`, `TFunctionName`, `undefined` \| `Chain`, `TChainOverride`\>) => `Promise`\<`SimulateContractReturnType`\<`TAbi`, `TFunctionName`, `undefined` \| `Chain`, `TChainOverride`\>\> | `undefined` | Simulates/validates a contract interaction. This is useful for retrieving **return data** and **revert reasons** of contract write functions. - Docs: https://viem.sh/docs/contract/simulateContract.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts/writing-to-contracts **`Remarks`** This function does not require gas to execute and _**does not**_ change the state of the blockchain. It is almost identical to [`readContract`](https://viem.sh/docs/contract/readContract.html), but also supports contract write functions. Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html). **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const result = await client.simulateContract({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['function mint(uint32) view returns (uint32)']), functionName: 'mint', args: ['69420'], account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', }) ``` |
| › `publicClient.transport` | `TransportConfig`\<`string`, `EIP1193RequestFn`\> & `Record`\<`string`, `any`\> | `undefined` | The RPC transport |
| › `publicClient.type` | `string` | `undefined` | The type of client. |
| › `publicClient.uid` | `string` | `undefined` | A unique ID for the client. |
| › `publicClient.uninstallFilter` | (`args`: `UninstallFilterParameters`) => `Promise`\<`boolean`\> | `undefined` | Destroys a Filter that was created from one of the following Actions: - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter.html) - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter.html) - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter.html) - Docs: https://viem.sh/docs/actions/public/uninstallFilter.html - JSON-RPC Methods: [`eth_uninstallFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_uninstallFilter) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { createPendingTransactionFilter, uninstallFilter } from 'viem/public' const filter = await client.createPendingTransactionFilter() const uninstalled = await client.uninstallFilter({ filter }) // true ``` |
| › `publicClient.verifyMessage` | (`args`: `VerifyMessageParameters`) => `Promise`\<`boolean`\> | `undefined` | - |
| › `publicClient.verifyTypedData` | (`args`: `VerifyTypedDataParameters`) => `Promise`\<`boolean`\> | `undefined` | - |
| › `publicClient.waitForTransactionReceipt` | (`args`: `WaitForTransactionReceiptParameters`\<`undefined` \| `Chain`\>) => `Promise`\<`TransactionReceipt`\> | `undefined` | Waits for the [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms.html#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt). If the Transaction reverts, then the action will throw an error. - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/sending-transactions - JSON-RPC Methods: - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed. - If a Transaction has been replaced: - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions - Checks if one of the Transactions is a replacement - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt). **`Remarks`** The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions). Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce. There are 3 types of Transaction Replacement reasons: - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`) - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`) - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transactionReceipt = await client.waitForTransactionReceipt({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `publicClient.watchBlockNumber` | (`args`: `WatchBlockNumberParameters`) => `WatchBlockNumberReturnType` | `undefined` | Watches and returns incoming block numbers. - Docs: https://viem.sh/docs/actions/public/watchBlockNumber.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/watching-blocks - JSON-RPC Methods: - When `poll: true`, calls [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) on a polling interval. - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newHeads"` event. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = await client.watchBlockNumber({ onBlockNumber: (blockNumber) => console.log(blockNumber), }) ``` |
| › `publicClient.watchBlocks` | \<TIncludeTransactions, TBlockTag\>(`args`: `WatchBlocksParameters`\<`Transport`, `undefined` \| `Chain`, `TIncludeTransactions`, `TBlockTag`\>) => `WatchBlocksReturnType` | `undefined` | Watches and returns information for incoming blocks. - Docs: https://viem.sh/docs/actions/public/watchBlocks.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/watching-blocks - JSON-RPC Methods: - When `poll: true`, calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getBlockByNumber) on a polling interval. - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newHeads"` event. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = await client.watchBlocks({ onBlock: (block) => console.log(block), }) ``` |
| › `publicClient.watchContractEvent` | \<TAbi, TEventName, TStrict\>(`args`: `WatchContractEventParameters`\<`TAbi`, `TEventName`, `TStrict`\>) => `WatchContractEventReturnType` | `undefined` | Watches and returns emitted contract event logs. - Docs: https://viem.sh/docs/contract/watchContractEvent.html **`Remarks`** This Action will batch up all the event logs found within the [`pollingInterval`](https://viem.sh/docs/contract/watchContractEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/contract/watchContractEvent.html#onLogs). `watchContractEvent` will attempt to create an [Event Filter](https://viem.sh/docs/contract/createContractEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchContractEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs.html) instead. **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = client.watchContractEvent({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['event Transfer(address indexed from, address indexed to, uint256 value)']), eventName: 'Transfer', args: { from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b' }, onLogs: (logs) => console.log(logs), }) ``` |
| › `publicClient.watchEvent` | \<TAbiEvent, TAbiEvents, TStrict\>(`args`: `WatchEventParameters`\<`TAbiEvent`, `TAbiEvents`, `TStrict`\>) => `WatchEventReturnType` | `undefined` | Watches and returns emitted [Event Logs](https://viem.sh/docs/glossary/terms.html#event-log). - Docs: https://viem.sh/docs/actions/public/watchEvent.html - JSON-RPC Methods: - **RPC Provider supports `eth_newFilter`:** - Calls [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) to create a filter (called on initialize). - On a polling interval, it will call [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges). - **RPC Provider does not support `eth_newFilter`:** - Calls [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) for each block between the polling interval. **`Remarks`** This Action will batch up all the Event Logs found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/actions/public/watchEvent.html#onLogs). `watchEvent` will attempt to create an [Event Filter](https://viem.sh/docs/actions/public/createEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs.html) instead. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = client.watchEvent({ onLogs: (logs) => console.log(logs), }) ``` |
| › `publicClient.watchPendingTransactions` | (`args`: `WatchPendingTransactionsParameters`\<`Transport`\>) => `WatchPendingTransactionsReturnType` | `undefined` | Watches and returns pending transaction hashes. - Docs: https://viem.sh/docs/actions/public/watchPendingTransactions.html - JSON-RPC Methods: - When `poll: true` - Calls [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) to initialize the filter. - Calls [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getFilterChanges) on a polling interval. - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newPendingTransactions"` event. **`Remarks`** This Action will batch up all the pending transactions found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#pollinginterval-optional), and invoke them via [`onTransactions`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#ontransactions). **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = await client.watchPendingTransactions({ onTransactions: (hashes) => console.log(hashes), }) ``` |
| › `rollupCreatorAddressOverride?` | \`0x$\{string}\` | `undefined` | Specifies a custom address for the RollupCreator. By default, the address will be automatically detected based on the provided chain. |

#### Returns

`Promise`\<\{ `accessList?`: `undefined` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `bigint` ; `maxFeePerGas?`: `undefined` ; `maxPriorityFeePerGas?`: `undefined` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"legacy"`` ; `value?`: `bigint`  } \| \{ `accessList?`: `AccessList` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `bigint` ; `maxFeePerGas?`: `undefined` ; `maxPriorityFeePerGas?`: `undefined` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"eip2930"`` ; `value?`: `bigint`  } \| \{ `accessList?`: `AccessList` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `undefined` ; `maxFeePerGas?`: `bigint` ; `maxPriorityFeePerGas?`: `bigint` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"eip1559"`` ; `value?`: `bigint`  }\>

#### Defined in

[src/createRollupPrepareCustomFeeTokenApprovalTransactionRequest.ts:20](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/createRollupPrepareCustomFeeTokenApprovalTransactionRequest.ts#L20)

___

### createRollupPrepareTransaction

**createRollupPrepareTransaction**(`tx`): [`CreateRollupTransaction`](modules.md#createrolluptransaction)

#### Parameters

| Name | Type |
| :------ | :------ |
| `tx` | `Transaction` |

#### Returns

[`CreateRollupTransaction`](modules.md#createrolluptransaction)

#### Defined in

[src/createRollupPrepareTransaction.ts:17](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/createRollupPrepareTransaction.ts#L17)

___

### createRollupPrepareTransactionReceipt

**createRollupPrepareTransactionReceipt**(`txReceipt`): [`CreateRollupTransactionReceipt`](modules.md#createrolluptransactionreceipt)

#### Parameters

| Name | Type |
| :------ | :------ |
| `txReceipt` | `TransactionReceipt` |

#### Returns

[`CreateRollupTransactionReceipt`](modules.md#createrolluptransactionreceipt)

#### Defined in

[src/createRollupPrepareTransactionReceipt.ts:34](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/createRollupPrepareTransactionReceipt.ts#L34)

___

### createRollupPrepareTransactionRequest

**createRollupPrepareTransactionRequest**(`«destructured»`): `Promise`\<\{ `accessList?`: `undefined` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `bigint` ; `maxFeePerGas?`: `undefined` ; `maxPriorityFeePerGas?`: `undefined` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"legacy"`` ; `value?`: `bigint`  } \| \{ `accessList?`: `AccessList` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `bigint` ; `maxFeePerGas?`: `undefined` ; `maxPriorityFeePerGas?`: `undefined` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"eip2930"`` ; `value?`: `bigint`  } \| \{ `accessList?`: `AccessList` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `undefined` ; `maxFeePerGas?`: `bigint` ; `maxPriorityFeePerGas?`: `bigint` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"eip1559"`` ; `value?`: `bigint`  }\>

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `«destructured»` | `Object` | - |
| › `account` | \`0x$\{string}\` | - |
| › `gasOverrides?` | `TransactionRequestGasOverrides` | - |
| › `params` | [`CreateRollupParams`](modules.md#createrollupparams) | - |
| › `publicClient` | `Object` | - |
| › `publicClient.account` | `undefined` | The Account of the Client. |
| › `publicClient.batch?` | `Object` | Flags for batch settings. |
| › `publicClient.batch.multicall?` | `boolean` \| \{ `batchSize?`: `number` ; `wait?`: `number`  } | Toggle to enable `eth_call` multicall aggregation. |
| › `publicClient.cacheTime` | `number` | Time (in ms) that cached data will remain in memory. |
| › `publicClient.call` | (`parameters`: `CallParameters`\<`undefined` \| `Chain`\>) => `Promise`\<`CallReturnType`\> | Executes a new message call immediately without submitting a transaction to the network. - Docs: https://viem.sh/docs/actions/public/call.html - JSON-RPC Methods: [`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const data = await client.call({ account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', }) ``` |
| › `publicClient.chain` | `undefined` \| `Chain` | Chain for the client. |
| › `publicClient.createBlockFilter` | () => `Promise`\<\{ `id`: \`0x$\{string}\` ; `request`: `EIP1193RequestFn`\<readonly [\{ `Method`: ``"eth_getFilterChanges"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: \`0x$\{(...)}\`[] \| `RpcLog`[]  }, \{ `Method`: ``"eth_getFilterLogs"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `RpcLog`[]  }, \{ `Method`: ``"eth_uninstallFilter"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `boolean`  }]\> ; `type`: ``"block"``  }\> | Creates a Filter to listen for new block hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html). - Docs: https://viem.sh/docs/actions/public/createBlockFilter.html - JSON-RPC Methods: [`eth_newBlockFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newBlockFilter) **`Example`** ```ts import { createPublicClient, createBlockFilter, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await createBlockFilter(client) // { id: "0x345a6572337856574a76364e457a4366", type: 'block' } ``` |
| › `publicClient.createContractEventFilter` | \<TAbi, TEventName, TArgs, TStrict, TFromBlock, TToBlock\>(`args`: `CreateContractEventFilterParameters`\<`TAbi`, `TEventName`, `TArgs`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`CreateContractEventFilterReturnType`\<`TAbi`, `TEventName`, `TArgs`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Creates a Filter to retrieve event logs that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html) or [`getFilterLogs`](https://viem.sh/docs/actions/public/getFilterLogs.html). - Docs: https://viem.sh/docs/contract/createContractEventFilter.html **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createContractEventFilter({ abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']), }) ``` |
| › `publicClient.createEventFilter` | \<TAbiEvent, TAbiEvents, TStrict, TFromBlock, TToBlock, _EventName, _Args\>(`args?`: `CreateEventFilterParameters`\<`TAbiEvent`, `TAbiEvents`, `TStrict`, `TFromBlock`, `TToBlock`, `_EventName`, `_Args`\>) => `Promise`\<\{ [K in string \| number \| symbol]: Filter\<"event", TAbiEvents, \_EventName, \_Args, TStrict, TFromBlock, TToBlock\>[K] }\> | Creates a [`Filter`](https://viem.sh/docs/glossary/types.html#filter) to listen for new events that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html). - Docs: https://viem.sh/docs/actions/public/createEventFilter.html - JSON-RPC Methods: [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createEventFilter({ address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2', }) ``` |
| › `publicClient.createPendingTransactionFilter` | () => `Promise`\<\{ `id`: \`0x$\{string}\` ; `request`: `EIP1193RequestFn`\<readonly [\{ `Method`: ``"eth_getFilterChanges"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: \`0x$\{(...)}\`[] \| `RpcLog`[]  }, \{ `Method`: ``"eth_getFilterLogs"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `RpcLog`[]  }, \{ `Method`: ``"eth_uninstallFilter"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `boolean`  }]\> ; `type`: ``"transaction"``  }\> | Creates a Filter to listen for new pending transaction hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html). - Docs: https://viem.sh/docs/actions/public/createPendingTransactionFilter.html - JSON-RPC Methods: [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createPendingTransactionFilter() // { id: "0x345a6572337856574a76364e457a4366", type: 'transaction' } ``` |
| › `publicClient.estimateContractGas` | \<TChain, TAbi, TFunctionName\>(`args`: `EstimateContractGasParameters`\<`TAbi`, `TFunctionName`, `TChain`, `undefined` \| `Account`\>) => `Promise`\<`bigint`\> | Estimates the gas required to successfully execute a contract write function call. - Docs: https://viem.sh/docs/contract/estimateContractGas.html **`Remarks`** Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`estimateGas` action](https://viem.sh/docs/actions/public/estimateGas.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html). **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const gas = await client.estimateContractGas({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['function mint() public']), functionName: 'mint', account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', }) ``` |
| › `publicClient.estimateFeesPerGas` | \<TChainOverride, TType\>(`args?`: `EstimateFeesPerGasParameters`\<`undefined` \| `Chain`, `TChainOverride`, `TType`\>) => `Promise`\<`EstimateFeesPerGasReturnType`\> | Returns an estimate for the fees per gas for a transaction to be included in the next block. - Docs: https://viem.sh/docs/actions/public/estimateFeesPerGas.html **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const maxPriorityFeePerGas = await client.estimateFeesPerGas() // { maxFeePerGas: ..., maxPriorityFeePerGas: ... } ``` |
| › `publicClient.estimateGas` | (`args`: `EstimateGasParameters`\<`undefined` \| `Chain`, `undefined` \| `Account`\>) => `Promise`\<`bigint`\> | Estimates the gas necessary to complete a transaction without submitting it to the network. - Docs: https://viem.sh/docs/actions/public/estimateGas.html - JSON-RPC Methods: [`eth_estimateGas`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas) **`Example`** ```ts import { createPublicClient, http, parseEther } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const gasEstimate = await client.estimateGas({ account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', value: parseEther('1'), }) ``` |
| › `publicClient.estimateMaxPriorityFeePerGas` | \<TChainOverride\>(`args?`: \{ `chain`: ``null`` \| `TChainOverride`  }) => `Promise`\<`bigint`\> | Returns an estimate for the max priority fee per gas (in wei) for a transaction to be included in the next block. - Docs: https://viem.sh/docs/actions/public/estimateMaxPriorityFeePerGas.html **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const maxPriorityFeePerGas = await client.estimateMaxPriorityFeePerGas() // 10000000n ``` |
| › `publicClient.extend` | \<client\>(`fn`: (`client`: `Client`\<`Transport`, `undefined` \| `Chain`, `undefined`, `PublicRpcSchema`, `PublicActions`\<`Transport`, `undefined` \| `Chain`\>\>) => `client`) => `Client`\<`Transport`, `undefined` \| `Chain`, `undefined`, `PublicRpcSchema`, \{ [K in string \| number \| symbol]: client[K] } & `PublicActions`\<`Transport`, `undefined` \| `Chain`\>\> | - |
| › `publicClient.getBalance` | (`args`: `GetBalanceParameters`) => `Promise`\<`bigint`\> | Returns the balance of an address in wei. - Docs: https://viem.sh/docs/actions/public/getBalance.html - JSON-RPC Methods: [`eth_getBalance`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getbalance) **`Remarks`** You can convert the balance to ether units with [`formatEther`](https://viem.sh/docs/utilities/formatEther.html). ```ts const balance = await getBalance(client, { address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', blockTag: 'safe' }) const balanceAsEther = formatEther(balance) // "6.942" ``` **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const balance = await client.getBalance({ address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', }) // 10000000000000000000000n (wei) ``` |
| › `publicClient.getBlock` | \<TIncludeTransactions, TBlockTag\>(`args?`: `GetBlockParameters`\<`TIncludeTransactions`, `TBlockTag`\>) => `Promise`\<`GetBlockReturnType`\<`undefined` \| `Chain`, `TIncludeTransactions`, `TBlockTag`\>\> | Returns information about a block at a block number, hash, or tag. - Docs: https://viem.sh/docs/actions/public/getBlock.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/fetching-blocks - JSON-RPC Methods: - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) for `blockNumber` & `blockTag`. - Calls [`eth_getBlockByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbyhash) for `blockHash`. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const block = await client.getBlock() ``` |
| › `publicClient.getBlockNumber` | (`args?`: `GetBlockNumberParameters`) => `Promise`\<`bigint`\> | Returns the number of the most recent block seen. - Docs: https://viem.sh/docs/actions/public/getBlockNumber.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/fetching-blocks - JSON-RPC Methods: [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const blockNumber = await client.getBlockNumber() // 69420n ``` |
| › `publicClient.getBlockTransactionCount` | (`args?`: `GetBlockTransactionCountParameters`) => `Promise`\<`number`\> | Returns the number of Transactions at a block number, hash, or tag. - Docs: https://viem.sh/docs/actions/public/getBlockTransactionCount.html - JSON-RPC Methods: - Calls [`eth_getBlockTransactionCountByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbynumber) for `blockNumber` & `blockTag`. - Calls [`eth_getBlockTransactionCountByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbyhash) for `blockHash`. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const count = await client.getBlockTransactionCount() ``` |
| › `publicClient.getBytecode` | (`args`: `GetBytecodeParameters`) => `Promise`\<`GetBytecodeReturnType`\> | Retrieves the bytecode at an address. - Docs: https://viem.sh/docs/contract/getBytecode.html - JSON-RPC Methods: [`eth_getCode`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getcode) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const code = await client.getBytecode({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', }) ``` |
| › `publicClient.getChainId` | () => `Promise`\<`number`\> | Returns the chain ID associated with the current network. - Docs: https://viem.sh/docs/actions/public/getChainId.html - JSON-RPC Methods: [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const chainId = await client.getChainId() // 1 ``` |
| › `publicClient.getContractEvents` | \<TAbi, TEventName, TStrict, TFromBlock, TToBlock\>(`args`: `GetContractEventsParameters`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetContractEventsReturnType`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of event logs emitted by a contract. - Docs: https://viem.sh/docs/actions/public/getContractEvents.html - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { wagmiAbi } from './abi' const client = createPublicClient({ chain: mainnet, transport: http(), }) const logs = await client.getContractEvents(client, { address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: wagmiAbi, eventName: 'Transfer' }) ``` |
| › `publicClient.getEnsAddress` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `coinType?`: `number` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsAddressReturnType`\> | Gets address for ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsAddress.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const ensAddress = await client.getEnsAddress({ name: normalize('wevm.eth'), }) // '0xd2135CfB216b74109775236E36d4b433F1DF507B' ``` |
| › `publicClient.getEnsAvatar` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `gatewayUrls?`: `AssetGatewayUrls` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsAvatarReturnType`\> | Gets the avatar of an ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsAvatar.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls [`getEnsText`](https://viem.sh/docs/ens/actions/getEnsText.html) with `key` set to `'avatar'`. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const ensAvatar = await client.getEnsAvatar({ name: normalize('wevm.eth'), }) // 'https://ipfs.io/ipfs/Qma8mnp6xV3J2cRNf3mTth5C8nV11CAnceVinc3y8jSbio' ``` |
| › `publicClient.getEnsName` | (`args`: \{ `address`: \`0x$\{string}\` ; `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsNameReturnType`\> | Gets primary name for specified address. - Docs: https://viem.sh/docs/ens/actions/getEnsName.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `reverse(bytes)` on ENS Universal Resolver Contract to "reverse resolve" the address to the primary ENS name. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const ensName = await client.getEnsName({ address: '0xd2135CfB216b74109775236E36d4b433F1DF507B', }) // 'wevm.eth' ``` |
| › `publicClient.getEnsResolver` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<\`0x$\{string}\`\> | Gets resolver for ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `findResolver(bytes)` on ENS Universal Resolver Contract to retrieve the resolver of an ENS name. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const resolverAddress = await client.getEnsResolver({ name: normalize('wevm.eth'), }) // '0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41' ``` |
| › `publicClient.getEnsText` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `key`: `string` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsTextReturnType`\> | Gets a text record for specified ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const twitterRecord = await client.getEnsText({ name: normalize('wevm.eth'), key: 'com.twitter', }) // 'wagmi_sh' ``` |
| › `publicClient.getFeeHistory` | (`args`: `GetFeeHistoryParameters`) => `Promise`\<`GetFeeHistoryReturnType`\> | Returns a collection of historical gas information. - Docs: https://viem.sh/docs/actions/public/getFeeHistory.html - JSON-RPC Methods: [`eth_feeHistory`](https://docs.alchemy.com/reference/eth-feehistory) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const feeHistory = await client.getFeeHistory({ blockCount: 4, rewardPercentiles: [25, 75], }) ``` |
| › `publicClient.getFilterChanges` | \<TFilterType, TAbi, TEventName, TStrict, TFromBlock, TToBlock\>(`args`: `GetFilterChangesParameters`\<`TFilterType`, `TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetFilterChangesReturnType`\<`TFilterType`, `TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of logs or hashes based on a [Filter](/docs/glossary/terms#filter) since the last time it was called. - Docs: https://viem.sh/docs/actions/public/getFilterChanges.html - JSON-RPC Methods: [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges) **`Remarks`** A Filter can be created from the following actions: - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter.html) - [`createContractEventFilter`](https://viem.sh/docs/contract/createContractEventFilter.html) - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter.html) - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter.html) Depending on the type of filter, the return value will be different: - If the filter was created with `createContractEventFilter` or `createEventFilter`, it returns a list of logs. - If the filter was created with `createPendingTransactionFilter`, it returns a list of transaction hashes. - If the filter was created with `createBlockFilter`, it returns a list of block hashes. **`Example`** ```ts // Blocks import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createBlockFilter() const hashes = await client.getFilterChanges({ filter }) ``` **`Example`** ```ts // Contract Events import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createContractEventFilter({ address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']), eventName: 'Transfer', }) const logs = await client.getFilterChanges({ filter }) ``` **`Example`** ```ts // Raw Events import { createPublicClient, http, parseAbiItem } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createEventFilter({ address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'), }) const logs = await client.getFilterChanges({ filter }) ``` **`Example`** ```ts // Transactions import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createPendingTransactionFilter() const hashes = await client.getFilterChanges({ filter }) ``` |
| › `publicClient.getFilterLogs` | \<TAbi, TEventName, TStrict, TFromBlock, TToBlock\>(`args`: `GetFilterLogsParameters`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetFilterLogsReturnType`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of event logs since the filter was created. - Docs: https://viem.sh/docs/actions/public/getFilterLogs.html - JSON-RPC Methods: [`eth_getFilterLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterlogs) **`Remarks`** `getFilterLogs` is only compatible with **event filters**. **`Example`** ```ts import { createPublicClient, http, parseAbiItem } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createEventFilter({ address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'), }) const logs = await client.getFilterLogs({ filter }) ``` |
| › `publicClient.getGasPrice` | () => `Promise`\<`bigint`\> | Returns the current price of gas (in wei). - Docs: https://viem.sh/docs/actions/public/getGasPrice.html - JSON-RPC Methods: [`eth_gasPrice`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gasprice) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const gasPrice = await client.getGasPrice() ``` |
| › `publicClient.getLogs` | \<TAbiEvent, TAbiEvents, TStrict, TFromBlock, TToBlock\>(`args?`: `GetLogsParameters`\<`TAbiEvent`, `TAbiEvents`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetLogsReturnType`\<`TAbiEvent`, `TAbiEvents`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of event logs matching the provided parameters. - Docs: https://viem.sh/docs/actions/public/getLogs.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/filters-and-logs/event-logs - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) **`Example`** ```ts import { createPublicClient, http, parseAbiItem } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const logs = await client.getLogs() ``` |
| › `publicClient.getProof` | (`args`: `GetProofParameters`) => `Promise`\<`GetProofReturnType`\> | Returns the account and storage values of the specified account including the Merkle-proof. - Docs: https://viem.sh/docs/actions/public/getProof.html - JSON-RPC Methods: - Calls [`eth_getProof`](https://eips.ethereum.org/EIPS/eip-1186) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const block = await client.getProof({ address: '0x...', storageKeys: ['0x...'], }) ``` |
| › `publicClient.getStorageAt` | (`args`: `GetStorageAtParameters`) => `Promise`\<`GetStorageAtReturnType`\> | Returns the value from a storage slot at a given address. - Docs: https://viem.sh/docs/contract/getStorageAt.html - JSON-RPC Methods: [`eth_getStorageAt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getstorageat) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { getStorageAt } from 'viem/contract' const client = createPublicClient({ chain: mainnet, transport: http(), }) const code = await client.getStorageAt({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', slot: toHex(0), }) ``` |
| › `publicClient.getTransaction` | \<TBlockTag\>(`args`: `GetTransactionParameters`\<`TBlockTag`\>) => `Promise`\<`GetTransactionReturnType`\<`undefined` \| `Chain`, `TBlockTag`\>\> | Returns information about a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) given a hash or block identifier. - Docs: https://viem.sh/docs/actions/public/getTransaction.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/fetching-transactions - JSON-RPC Methods: [`eth_getTransactionByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionByHash) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transaction = await client.getTransaction({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `publicClient.getTransactionConfirmations` | (`args`: `GetTransactionConfirmationsParameters`\<`undefined` \| `Chain`\>) => `Promise`\<`bigint`\> | Returns the number of blocks passed (confirmations) since the transaction was processed on a block. - Docs: https://viem.sh/docs/actions/public/getTransactionConfirmations.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/fetching-transactions - JSON-RPC Methods: [`eth_getTransactionConfirmations`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionConfirmations) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const confirmations = await client.getTransactionConfirmations({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `publicClient.getTransactionCount` | (`args`: `GetTransactionCountParameters`) => `Promise`\<`number`\> | Returns the number of [Transactions](https://viem.sh/docs/glossary/terms.html#transaction) an Account has broadcast / sent. - Docs: https://viem.sh/docs/actions/public/getTransactionCount.html - JSON-RPC Methods: [`eth_getTransactionCount`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactioncount) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transactionCount = await client.getTransactionCount({ address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', }) ``` |
| › `publicClient.getTransactionReceipt` | (`args`: `GetTransactionReceiptParameters`) => `Promise`\<`TransactionReceipt`\> | Returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt) given a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash. - Docs: https://viem.sh/docs/actions/public/getTransactionReceipt.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/fetching-transactions - JSON-RPC Methods: [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transactionReceipt = await client.getTransactionReceipt({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `publicClient.key` | `string` | A key for the client. |
| › `publicClient.multicall` | \<TContracts, TAllowFailure\>(`args`: `MulticallParameters`\<`TContracts`, `TAllowFailure`\>) => `Promise`\<`MulticallReturnType`\<`TContracts`, `TAllowFailure`\>\> | Similar to [`readContract`](https://viem.sh/docs/contract/readContract.html), but batches up multiple functions on a contract in a single RPC call via the [`multicall3` contract](https://github.com/mds1/multicall). - Docs: https://viem.sh/docs/contract/multicall.html **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const abi = parseAbi([ 'function balanceOf(address) view returns (uint256)', 'function totalSupply() view returns (uint256)', ]) const result = await client.multicall({ contracts: [ { address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi, functionName: 'balanceOf', args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'], }, { address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi, functionName: 'totalSupply', }, ], }) // [{ result: 424122n, status: 'success' }, { result: 1000000n, status: 'success' }] ``` |
| › `publicClient.name` | `string` | A name for the client. |
| › `publicClient.pollingInterval` | `number` | Frequency (in ms) for polling enabled actions & events. Defaults to 4_000 milliseconds. |
| › `publicClient.prepareTransactionRequest` | \<TChainOverride\>(`args`: `PrepareTransactionRequestParameters`\<`undefined` \| `Chain`, `undefined` \| `Account`, `TChainOverride`\>) => `Promise`\<`PrepareTransactionRequestReturnType`\> | Prepares a transaction request for signing. - Docs: https://viem.sh/docs/actions/wallet/prepareTransactionRequest.html **`Example`** ```ts import { createWalletClient, custom } from 'viem' import { mainnet } from 'viem/chains' const client = createWalletClient({ chain: mainnet, transport: custom(window.ethereum), }) const request = await client.prepareTransactionRequest({ account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', to: '0x0000000000000000000000000000000000000000', value: 1n, }) ``` **`Example`** ```ts // Account Hoisting import { createWalletClient, http } from 'viem' import { privateKeyToAccount } from 'viem/accounts' import { mainnet } from 'viem/chains' const client = createWalletClient({ account: privateKeyToAccount('0x…'), chain: mainnet, transport: custom(window.ethereum), }) const request = await client.prepareTransactionRequest({ to: '0x0000000000000000000000000000000000000000', value: 1n, }) ``` |
| › `publicClient.readContract` | \<TAbi, TFunctionName\>(`args`: `ReadContractParameters`\<`TAbi`, `TFunctionName`\>) => `Promise`\<`ReadContractReturnType`\<`TAbi`, `TFunctionName`\>\> | Calls a read-only function on a contract, and returns the response. - Docs: https://viem.sh/docs/contract/readContract.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts/reading-contracts **`Remarks`** A "read-only" function (constant function) on a Solidity contract is denoted by a `view` or `pure` keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas. Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html). **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' import { readContract } from 'viem/contract' const client = createPublicClient({ chain: mainnet, transport: http(), }) const result = await client.readContract({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['function balanceOf(address) view returns (uint256)']), functionName: 'balanceOf', args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'], }) // 424122n ``` |
| › `publicClient.request` | `EIP1193RequestFn`\<`PublicRpcSchema`\> | Request function wrapped with friendly error handling |
| › `publicClient.sendRawTransaction` | (`args`: `SendRawTransactionParameters`) => `Promise`\<\`0x$\{string}\`\> | Sends a **signed** transaction to the network - Docs: https://viem.sh/docs/actions/wallet/sendRawTransaction.html - JSON-RPC Method: [`eth_sendRawTransaction`](https://ethereum.github.io/execution-apis/api-documentation/) **`Example`** ```ts import { createWalletClient, custom } from 'viem' import { mainnet } from 'viem/chains' import { sendRawTransaction } from 'viem/wallet' const client = createWalletClient({ chain: mainnet, transport: custom(window.ethereum), }) const hash = await client.sendRawTransaction({ serializedTransaction: '0x02f850018203118080825208808080c080a04012522854168b27e5dc3d5839bab5e6b39e1a0ffd343901ce1622e3d64b48f1a04e00902ae0502c4728cbf12156290df99c3ed7de85b1dbfe20b5c36931733a33' }) ``` |
| › `publicClient.simulateContract` | \<TAbi, TFunctionName, TChainOverride\>(`args`: `SimulateContractParameters`\<`TAbi`, `TFunctionName`, `undefined` \| `Chain`, `TChainOverride`\>) => `Promise`\<`SimulateContractReturnType`\<`TAbi`, `TFunctionName`, `undefined` \| `Chain`, `TChainOverride`\>\> | Simulates/validates a contract interaction. This is useful for retrieving **return data** and **revert reasons** of contract write functions. - Docs: https://viem.sh/docs/contract/simulateContract.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts/writing-to-contracts **`Remarks`** This function does not require gas to execute and _**does not**_ change the state of the blockchain. It is almost identical to [`readContract`](https://viem.sh/docs/contract/readContract.html), but also supports contract write functions. Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html). **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const result = await client.simulateContract({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['function mint(uint32) view returns (uint32)']), functionName: 'mint', args: ['69420'], account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', }) ``` |
| › `publicClient.transport` | `TransportConfig`\<`string`, `EIP1193RequestFn`\> & `Record`\<`string`, `any`\> | The RPC transport |
| › `publicClient.type` | `string` | The type of client. |
| › `publicClient.uid` | `string` | A unique ID for the client. |
| › `publicClient.uninstallFilter` | (`args`: `UninstallFilterParameters`) => `Promise`\<`boolean`\> | Destroys a Filter that was created from one of the following Actions: - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter.html) - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter.html) - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter.html) - Docs: https://viem.sh/docs/actions/public/uninstallFilter.html - JSON-RPC Methods: [`eth_uninstallFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_uninstallFilter) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { createPendingTransactionFilter, uninstallFilter } from 'viem/public' const filter = await client.createPendingTransactionFilter() const uninstalled = await client.uninstallFilter({ filter }) // true ``` |
| › `publicClient.verifyMessage` | (`args`: `VerifyMessageParameters`) => `Promise`\<`boolean`\> | - |
| › `publicClient.verifyTypedData` | (`args`: `VerifyTypedDataParameters`) => `Promise`\<`boolean`\> | - |
| › `publicClient.waitForTransactionReceipt` | (`args`: `WaitForTransactionReceiptParameters`\<`undefined` \| `Chain`\>) => `Promise`\<`TransactionReceipt`\> | Waits for the [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms.html#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt). If the Transaction reverts, then the action will throw an error. - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/sending-transactions - JSON-RPC Methods: - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed. - If a Transaction has been replaced: - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions - Checks if one of the Transactions is a replacement - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt). **`Remarks`** The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions). Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce. There are 3 types of Transaction Replacement reasons: - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`) - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`) - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transactionReceipt = await client.waitForTransactionReceipt({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `publicClient.watchBlockNumber` | (`args`: `WatchBlockNumberParameters`) => `WatchBlockNumberReturnType` | Watches and returns incoming block numbers. - Docs: https://viem.sh/docs/actions/public/watchBlockNumber.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/watching-blocks - JSON-RPC Methods: - When `poll: true`, calls [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) on a polling interval. - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newHeads"` event. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = await client.watchBlockNumber({ onBlockNumber: (blockNumber) => console.log(blockNumber), }) ``` |
| › `publicClient.watchBlocks` | \<TIncludeTransactions, TBlockTag\>(`args`: `WatchBlocksParameters`\<`Transport`, `undefined` \| `Chain`, `TIncludeTransactions`, `TBlockTag`\>) => `WatchBlocksReturnType` | Watches and returns information for incoming blocks. - Docs: https://viem.sh/docs/actions/public/watchBlocks.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/watching-blocks - JSON-RPC Methods: - When `poll: true`, calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getBlockByNumber) on a polling interval. - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newHeads"` event. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = await client.watchBlocks({ onBlock: (block) => console.log(block), }) ``` |
| › `publicClient.watchContractEvent` | \<TAbi, TEventName, TStrict\>(`args`: `WatchContractEventParameters`\<`TAbi`, `TEventName`, `TStrict`\>) => `WatchContractEventReturnType` | Watches and returns emitted contract event logs. - Docs: https://viem.sh/docs/contract/watchContractEvent.html **`Remarks`** This Action will batch up all the event logs found within the [`pollingInterval`](https://viem.sh/docs/contract/watchContractEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/contract/watchContractEvent.html#onLogs). `watchContractEvent` will attempt to create an [Event Filter](https://viem.sh/docs/contract/createContractEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchContractEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs.html) instead. **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = client.watchContractEvent({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['event Transfer(address indexed from, address indexed to, uint256 value)']), eventName: 'Transfer', args: { from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b' }, onLogs: (logs) => console.log(logs), }) ``` |
| › `publicClient.watchEvent` | \<TAbiEvent, TAbiEvents, TStrict\>(`args`: `WatchEventParameters`\<`TAbiEvent`, `TAbiEvents`, `TStrict`\>) => `WatchEventReturnType` | Watches and returns emitted [Event Logs](https://viem.sh/docs/glossary/terms.html#event-log). - Docs: https://viem.sh/docs/actions/public/watchEvent.html - JSON-RPC Methods: - **RPC Provider supports `eth_newFilter`:** - Calls [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) to create a filter (called on initialize). - On a polling interval, it will call [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges). - **RPC Provider does not support `eth_newFilter`:** - Calls [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) for each block between the polling interval. **`Remarks`** This Action will batch up all the Event Logs found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/actions/public/watchEvent.html#onLogs). `watchEvent` will attempt to create an [Event Filter](https://viem.sh/docs/actions/public/createEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs.html) instead. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = client.watchEvent({ onLogs: (logs) => console.log(logs), }) ``` |
| › `publicClient.watchPendingTransactions` | (`args`: `WatchPendingTransactionsParameters`\<`Transport`\>) => `WatchPendingTransactionsReturnType` | Watches and returns pending transaction hashes. - Docs: https://viem.sh/docs/actions/public/watchPendingTransactions.html - JSON-RPC Methods: - When `poll: true` - Calls [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) to initialize the filter. - Calls [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getFilterChanges) on a polling interval. - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newPendingTransactions"` event. **`Remarks`** This Action will batch up all the pending transactions found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#pollinginterval-optional), and invoke them via [`onTransactions`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#ontransactions). **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = await client.watchPendingTransactions({ onTransactions: (hashes) => console.log(hashes), }) ``` |
| › `rollupCreatorAddressOverride?` | \`0x$\{string}\` | Specifies a custom address for the RollupCreator. By default, the address will be automatically detected based on the provided chain. |

#### Returns

`Promise`\<\{ `accessList?`: `undefined` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `bigint` ; `maxFeePerGas?`: `undefined` ; `maxPriorityFeePerGas?`: `undefined` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"legacy"`` ; `value?`: `bigint`  } \| \{ `accessList?`: `AccessList` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `bigint` ; `maxFeePerGas?`: `undefined` ; `maxPriorityFeePerGas?`: `undefined` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"eip2930"`` ; `value?`: `bigint`  } \| \{ `accessList?`: `AccessList` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `undefined` ; `maxFeePerGas?`: `bigint` ; `maxPriorityFeePerGas?`: `bigint` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"eip1559"`` ; `value?`: `bigint`  }\>

#### Defined in

[src/createRollupPrepareTransactionRequest.ts:39](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/createRollupPrepareTransactionRequest.ts#L39)

___

### createTokenBridgeEnoughCustomFeeTokenAllowance

**createTokenBridgeEnoughCustomFeeTokenAllowance**(`«destructured»`): `Promise`\<`boolean`\>

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `«destructured»` | `Object` | - |
| › `nativeToken` | \`0x$\{string}\` | - |
| › `owner` | \`0x$\{string}\` | - |
| › `publicClient` | `Object` | - |
| › `publicClient.account` | `undefined` | The Account of the Client. |
| › `publicClient.batch?` | `Object` | Flags for batch settings. |
| › `publicClient.batch.multicall?` | `boolean` \| \{ `batchSize?`: `number` ; `wait?`: `number`  } | Toggle to enable `eth_call` multicall aggregation. |
| › `publicClient.cacheTime` | `number` | Time (in ms) that cached data will remain in memory. |
| › `publicClient.call` | (`parameters`: `CallParameters`\<`undefined` \| `Chain`\>) => `Promise`\<`CallReturnType`\> | Executes a new message call immediately without submitting a transaction to the network. - Docs: https://viem.sh/docs/actions/public/call.html - JSON-RPC Methods: [`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const data = await client.call({ account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', }) ``` |
| › `publicClient.chain` | `undefined` \| `Chain` | Chain for the client. |
| › `publicClient.createBlockFilter` | () => `Promise`\<\{ `id`: \`0x$\{string}\` ; `request`: `EIP1193RequestFn`\<readonly [\{ `Method`: ``"eth_getFilterChanges"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: \`0x$\{(...)}\`[] \| `RpcLog`[]  }, \{ `Method`: ``"eth_getFilterLogs"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `RpcLog`[]  }, \{ `Method`: ``"eth_uninstallFilter"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `boolean`  }]\> ; `type`: ``"block"``  }\> | Creates a Filter to listen for new block hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html). - Docs: https://viem.sh/docs/actions/public/createBlockFilter.html - JSON-RPC Methods: [`eth_newBlockFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newBlockFilter) **`Example`** ```ts import { createPublicClient, createBlockFilter, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await createBlockFilter(client) // { id: "0x345a6572337856574a76364e457a4366", type: 'block' } ``` |
| › `publicClient.createContractEventFilter` | \<TAbi, TEventName, TArgs, TStrict, TFromBlock, TToBlock\>(`args`: `CreateContractEventFilterParameters`\<`TAbi`, `TEventName`, `TArgs`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`CreateContractEventFilterReturnType`\<`TAbi`, `TEventName`, `TArgs`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Creates a Filter to retrieve event logs that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html) or [`getFilterLogs`](https://viem.sh/docs/actions/public/getFilterLogs.html). - Docs: https://viem.sh/docs/contract/createContractEventFilter.html **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createContractEventFilter({ abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']), }) ``` |
| › `publicClient.createEventFilter` | \<TAbiEvent, TAbiEvents, TStrict, TFromBlock, TToBlock, _EventName, _Args\>(`args?`: `CreateEventFilterParameters`\<`TAbiEvent`, `TAbiEvents`, `TStrict`, `TFromBlock`, `TToBlock`, `_EventName`, `_Args`\>) => `Promise`\<\{ [K in string \| number \| symbol]: Filter\<"event", TAbiEvents, \_EventName, \_Args, TStrict, TFromBlock, TToBlock\>[K] }\> | Creates a [`Filter`](https://viem.sh/docs/glossary/types.html#filter) to listen for new events that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html). - Docs: https://viem.sh/docs/actions/public/createEventFilter.html - JSON-RPC Methods: [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createEventFilter({ address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2', }) ``` |
| › `publicClient.createPendingTransactionFilter` | () => `Promise`\<\{ `id`: \`0x$\{string}\` ; `request`: `EIP1193RequestFn`\<readonly [\{ `Method`: ``"eth_getFilterChanges"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: \`0x$\{(...)}\`[] \| `RpcLog`[]  }, \{ `Method`: ``"eth_getFilterLogs"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `RpcLog`[]  }, \{ `Method`: ``"eth_uninstallFilter"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `boolean`  }]\> ; `type`: ``"transaction"``  }\> | Creates a Filter to listen for new pending transaction hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html). - Docs: https://viem.sh/docs/actions/public/createPendingTransactionFilter.html - JSON-RPC Methods: [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createPendingTransactionFilter() // { id: "0x345a6572337856574a76364e457a4366", type: 'transaction' } ``` |
| › `publicClient.estimateContractGas` | \<TChain, TAbi, TFunctionName\>(`args`: `EstimateContractGasParameters`\<`TAbi`, `TFunctionName`, `TChain`, `undefined` \| `Account`\>) => `Promise`\<`bigint`\> | Estimates the gas required to successfully execute a contract write function call. - Docs: https://viem.sh/docs/contract/estimateContractGas.html **`Remarks`** Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`estimateGas` action](https://viem.sh/docs/actions/public/estimateGas.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html). **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const gas = await client.estimateContractGas({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['function mint() public']), functionName: 'mint', account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', }) ``` |
| › `publicClient.estimateFeesPerGas` | \<TChainOverride, TType\>(`args?`: `EstimateFeesPerGasParameters`\<`undefined` \| `Chain`, `TChainOverride`, `TType`\>) => `Promise`\<`EstimateFeesPerGasReturnType`\> | Returns an estimate for the fees per gas for a transaction to be included in the next block. - Docs: https://viem.sh/docs/actions/public/estimateFeesPerGas.html **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const maxPriorityFeePerGas = await client.estimateFeesPerGas() // { maxFeePerGas: ..., maxPriorityFeePerGas: ... } ``` |
| › `publicClient.estimateGas` | (`args`: `EstimateGasParameters`\<`undefined` \| `Chain`, `undefined` \| `Account`\>) => `Promise`\<`bigint`\> | Estimates the gas necessary to complete a transaction without submitting it to the network. - Docs: https://viem.sh/docs/actions/public/estimateGas.html - JSON-RPC Methods: [`eth_estimateGas`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas) **`Example`** ```ts import { createPublicClient, http, parseEther } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const gasEstimate = await client.estimateGas({ account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', value: parseEther('1'), }) ``` |
| › `publicClient.estimateMaxPriorityFeePerGas` | \<TChainOverride\>(`args?`: \{ `chain`: ``null`` \| `TChainOverride`  }) => `Promise`\<`bigint`\> | Returns an estimate for the max priority fee per gas (in wei) for a transaction to be included in the next block. - Docs: https://viem.sh/docs/actions/public/estimateMaxPriorityFeePerGas.html **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const maxPriorityFeePerGas = await client.estimateMaxPriorityFeePerGas() // 10000000n ``` |
| › `publicClient.extend` | \<client\>(`fn`: (`client`: `Client`\<`Transport`, `undefined` \| `Chain`, `undefined`, `PublicRpcSchema`, `PublicActions`\<`Transport`, `undefined` \| `Chain`\>\>) => `client`) => `Client`\<`Transport`, `undefined` \| `Chain`, `undefined`, `PublicRpcSchema`, \{ [K in string \| number \| symbol]: client[K] } & `PublicActions`\<`Transport`, `undefined` \| `Chain`\>\> | - |
| › `publicClient.getBalance` | (`args`: `GetBalanceParameters`) => `Promise`\<`bigint`\> | Returns the balance of an address in wei. - Docs: https://viem.sh/docs/actions/public/getBalance.html - JSON-RPC Methods: [`eth_getBalance`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getbalance) **`Remarks`** You can convert the balance to ether units with [`formatEther`](https://viem.sh/docs/utilities/formatEther.html). ```ts const balance = await getBalance(client, { address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', blockTag: 'safe' }) const balanceAsEther = formatEther(balance) // "6.942" ``` **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const balance = await client.getBalance({ address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', }) // 10000000000000000000000n (wei) ``` |
| › `publicClient.getBlock` | \<TIncludeTransactions, TBlockTag\>(`args?`: `GetBlockParameters`\<`TIncludeTransactions`, `TBlockTag`\>) => `Promise`\<`GetBlockReturnType`\<`undefined` \| `Chain`, `TIncludeTransactions`, `TBlockTag`\>\> | Returns information about a block at a block number, hash, or tag. - Docs: https://viem.sh/docs/actions/public/getBlock.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/fetching-blocks - JSON-RPC Methods: - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) for `blockNumber` & `blockTag`. - Calls [`eth_getBlockByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbyhash) for `blockHash`. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const block = await client.getBlock() ``` |
| › `publicClient.getBlockNumber` | (`args?`: `GetBlockNumberParameters`) => `Promise`\<`bigint`\> | Returns the number of the most recent block seen. - Docs: https://viem.sh/docs/actions/public/getBlockNumber.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/fetching-blocks - JSON-RPC Methods: [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const blockNumber = await client.getBlockNumber() // 69420n ``` |
| › `publicClient.getBlockTransactionCount` | (`args?`: `GetBlockTransactionCountParameters`) => `Promise`\<`number`\> | Returns the number of Transactions at a block number, hash, or tag. - Docs: https://viem.sh/docs/actions/public/getBlockTransactionCount.html - JSON-RPC Methods: - Calls [`eth_getBlockTransactionCountByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbynumber) for `blockNumber` & `blockTag`. - Calls [`eth_getBlockTransactionCountByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbyhash) for `blockHash`. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const count = await client.getBlockTransactionCount() ``` |
| › `publicClient.getBytecode` | (`args`: `GetBytecodeParameters`) => `Promise`\<`GetBytecodeReturnType`\> | Retrieves the bytecode at an address. - Docs: https://viem.sh/docs/contract/getBytecode.html - JSON-RPC Methods: [`eth_getCode`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getcode) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const code = await client.getBytecode({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', }) ``` |
| › `publicClient.getChainId` | () => `Promise`\<`number`\> | Returns the chain ID associated with the current network. - Docs: https://viem.sh/docs/actions/public/getChainId.html - JSON-RPC Methods: [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const chainId = await client.getChainId() // 1 ``` |
| › `publicClient.getContractEvents` | \<TAbi, TEventName, TStrict, TFromBlock, TToBlock\>(`args`: `GetContractEventsParameters`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetContractEventsReturnType`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of event logs emitted by a contract. - Docs: https://viem.sh/docs/actions/public/getContractEvents.html - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { wagmiAbi } from './abi' const client = createPublicClient({ chain: mainnet, transport: http(), }) const logs = await client.getContractEvents(client, { address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: wagmiAbi, eventName: 'Transfer' }) ``` |
| › `publicClient.getEnsAddress` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `coinType?`: `number` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsAddressReturnType`\> | Gets address for ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsAddress.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const ensAddress = await client.getEnsAddress({ name: normalize('wevm.eth'), }) // '0xd2135CfB216b74109775236E36d4b433F1DF507B' ``` |
| › `publicClient.getEnsAvatar` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `gatewayUrls?`: `AssetGatewayUrls` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsAvatarReturnType`\> | Gets the avatar of an ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsAvatar.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls [`getEnsText`](https://viem.sh/docs/ens/actions/getEnsText.html) with `key` set to `'avatar'`. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const ensAvatar = await client.getEnsAvatar({ name: normalize('wevm.eth'), }) // 'https://ipfs.io/ipfs/Qma8mnp6xV3J2cRNf3mTth5C8nV11CAnceVinc3y8jSbio' ``` |
| › `publicClient.getEnsName` | (`args`: \{ `address`: \`0x$\{string}\` ; `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsNameReturnType`\> | Gets primary name for specified address. - Docs: https://viem.sh/docs/ens/actions/getEnsName.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `reverse(bytes)` on ENS Universal Resolver Contract to "reverse resolve" the address to the primary ENS name. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const ensName = await client.getEnsName({ address: '0xd2135CfB216b74109775236E36d4b433F1DF507B', }) // 'wevm.eth' ``` |
| › `publicClient.getEnsResolver` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<\`0x$\{string}\`\> | Gets resolver for ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `findResolver(bytes)` on ENS Universal Resolver Contract to retrieve the resolver of an ENS name. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const resolverAddress = await client.getEnsResolver({ name: normalize('wevm.eth'), }) // '0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41' ``` |
| › `publicClient.getEnsText` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `key`: `string` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsTextReturnType`\> | Gets a text record for specified ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const twitterRecord = await client.getEnsText({ name: normalize('wevm.eth'), key: 'com.twitter', }) // 'wagmi_sh' ``` |
| › `publicClient.getFeeHistory` | (`args`: `GetFeeHistoryParameters`) => `Promise`\<`GetFeeHistoryReturnType`\> | Returns a collection of historical gas information. - Docs: https://viem.sh/docs/actions/public/getFeeHistory.html - JSON-RPC Methods: [`eth_feeHistory`](https://docs.alchemy.com/reference/eth-feehistory) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const feeHistory = await client.getFeeHistory({ blockCount: 4, rewardPercentiles: [25, 75], }) ``` |
| › `publicClient.getFilterChanges` | \<TFilterType, TAbi, TEventName, TStrict, TFromBlock, TToBlock\>(`args`: `GetFilterChangesParameters`\<`TFilterType`, `TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetFilterChangesReturnType`\<`TFilterType`, `TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of logs or hashes based on a [Filter](/docs/glossary/terms#filter) since the last time it was called. - Docs: https://viem.sh/docs/actions/public/getFilterChanges.html - JSON-RPC Methods: [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges) **`Remarks`** A Filter can be created from the following actions: - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter.html) - [`createContractEventFilter`](https://viem.sh/docs/contract/createContractEventFilter.html) - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter.html) - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter.html) Depending on the type of filter, the return value will be different: - If the filter was created with `createContractEventFilter` or `createEventFilter`, it returns a list of logs. - If the filter was created with `createPendingTransactionFilter`, it returns a list of transaction hashes. - If the filter was created with `createBlockFilter`, it returns a list of block hashes. **`Example`** ```ts // Blocks import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createBlockFilter() const hashes = await client.getFilterChanges({ filter }) ``` **`Example`** ```ts // Contract Events import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createContractEventFilter({ address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']), eventName: 'Transfer', }) const logs = await client.getFilterChanges({ filter }) ``` **`Example`** ```ts // Raw Events import { createPublicClient, http, parseAbiItem } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createEventFilter({ address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'), }) const logs = await client.getFilterChanges({ filter }) ``` **`Example`** ```ts // Transactions import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createPendingTransactionFilter() const hashes = await client.getFilterChanges({ filter }) ``` |
| › `publicClient.getFilterLogs` | \<TAbi, TEventName, TStrict, TFromBlock, TToBlock\>(`args`: `GetFilterLogsParameters`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetFilterLogsReturnType`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of event logs since the filter was created. - Docs: https://viem.sh/docs/actions/public/getFilterLogs.html - JSON-RPC Methods: [`eth_getFilterLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterlogs) **`Remarks`** `getFilterLogs` is only compatible with **event filters**. **`Example`** ```ts import { createPublicClient, http, parseAbiItem } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createEventFilter({ address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'), }) const logs = await client.getFilterLogs({ filter }) ``` |
| › `publicClient.getGasPrice` | () => `Promise`\<`bigint`\> | Returns the current price of gas (in wei). - Docs: https://viem.sh/docs/actions/public/getGasPrice.html - JSON-RPC Methods: [`eth_gasPrice`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gasprice) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const gasPrice = await client.getGasPrice() ``` |
| › `publicClient.getLogs` | \<TAbiEvent, TAbiEvents, TStrict, TFromBlock, TToBlock\>(`args?`: `GetLogsParameters`\<`TAbiEvent`, `TAbiEvents`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetLogsReturnType`\<`TAbiEvent`, `TAbiEvents`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of event logs matching the provided parameters. - Docs: https://viem.sh/docs/actions/public/getLogs.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/filters-and-logs/event-logs - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) **`Example`** ```ts import { createPublicClient, http, parseAbiItem } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const logs = await client.getLogs() ``` |
| › `publicClient.getProof` | (`args`: `GetProofParameters`) => `Promise`\<`GetProofReturnType`\> | Returns the account and storage values of the specified account including the Merkle-proof. - Docs: https://viem.sh/docs/actions/public/getProof.html - JSON-RPC Methods: - Calls [`eth_getProof`](https://eips.ethereum.org/EIPS/eip-1186) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const block = await client.getProof({ address: '0x...', storageKeys: ['0x...'], }) ``` |
| › `publicClient.getStorageAt` | (`args`: `GetStorageAtParameters`) => `Promise`\<`GetStorageAtReturnType`\> | Returns the value from a storage slot at a given address. - Docs: https://viem.sh/docs/contract/getStorageAt.html - JSON-RPC Methods: [`eth_getStorageAt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getstorageat) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { getStorageAt } from 'viem/contract' const client = createPublicClient({ chain: mainnet, transport: http(), }) const code = await client.getStorageAt({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', slot: toHex(0), }) ``` |
| › `publicClient.getTransaction` | \<TBlockTag\>(`args`: `GetTransactionParameters`\<`TBlockTag`\>) => `Promise`\<`GetTransactionReturnType`\<`undefined` \| `Chain`, `TBlockTag`\>\> | Returns information about a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) given a hash or block identifier. - Docs: https://viem.sh/docs/actions/public/getTransaction.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/fetching-transactions - JSON-RPC Methods: [`eth_getTransactionByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionByHash) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transaction = await client.getTransaction({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `publicClient.getTransactionConfirmations` | (`args`: `GetTransactionConfirmationsParameters`\<`undefined` \| `Chain`\>) => `Promise`\<`bigint`\> | Returns the number of blocks passed (confirmations) since the transaction was processed on a block. - Docs: https://viem.sh/docs/actions/public/getTransactionConfirmations.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/fetching-transactions - JSON-RPC Methods: [`eth_getTransactionConfirmations`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionConfirmations) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const confirmations = await client.getTransactionConfirmations({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `publicClient.getTransactionCount` | (`args`: `GetTransactionCountParameters`) => `Promise`\<`number`\> | Returns the number of [Transactions](https://viem.sh/docs/glossary/terms.html#transaction) an Account has broadcast / sent. - Docs: https://viem.sh/docs/actions/public/getTransactionCount.html - JSON-RPC Methods: [`eth_getTransactionCount`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactioncount) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transactionCount = await client.getTransactionCount({ address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', }) ``` |
| › `publicClient.getTransactionReceipt` | (`args`: `GetTransactionReceiptParameters`) => `Promise`\<`TransactionReceipt`\> | Returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt) given a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash. - Docs: https://viem.sh/docs/actions/public/getTransactionReceipt.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/fetching-transactions - JSON-RPC Methods: [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transactionReceipt = await client.getTransactionReceipt({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `publicClient.key` | `string` | A key for the client. |
| › `publicClient.multicall` | \<TContracts, TAllowFailure\>(`args`: `MulticallParameters`\<`TContracts`, `TAllowFailure`\>) => `Promise`\<`MulticallReturnType`\<`TContracts`, `TAllowFailure`\>\> | Similar to [`readContract`](https://viem.sh/docs/contract/readContract.html), but batches up multiple functions on a contract in a single RPC call via the [`multicall3` contract](https://github.com/mds1/multicall). - Docs: https://viem.sh/docs/contract/multicall.html **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const abi = parseAbi([ 'function balanceOf(address) view returns (uint256)', 'function totalSupply() view returns (uint256)', ]) const result = await client.multicall({ contracts: [ { address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi, functionName: 'balanceOf', args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'], }, { address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi, functionName: 'totalSupply', }, ], }) // [{ result: 424122n, status: 'success' }, { result: 1000000n, status: 'success' }] ``` |
| › `publicClient.name` | `string` | A name for the client. |
| › `publicClient.pollingInterval` | `number` | Frequency (in ms) for polling enabled actions & events. Defaults to 4_000 milliseconds. |
| › `publicClient.prepareTransactionRequest` | \<TChainOverride\>(`args`: `PrepareTransactionRequestParameters`\<`undefined` \| `Chain`, `undefined` \| `Account`, `TChainOverride`\>) => `Promise`\<`PrepareTransactionRequestReturnType`\> | Prepares a transaction request for signing. - Docs: https://viem.sh/docs/actions/wallet/prepareTransactionRequest.html **`Example`** ```ts import { createWalletClient, custom } from 'viem' import { mainnet } from 'viem/chains' const client = createWalletClient({ chain: mainnet, transport: custom(window.ethereum), }) const request = await client.prepareTransactionRequest({ account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', to: '0x0000000000000000000000000000000000000000', value: 1n, }) ``` **`Example`** ```ts // Account Hoisting import { createWalletClient, http } from 'viem' import { privateKeyToAccount } from 'viem/accounts' import { mainnet } from 'viem/chains' const client = createWalletClient({ account: privateKeyToAccount('0x…'), chain: mainnet, transport: custom(window.ethereum), }) const request = await client.prepareTransactionRequest({ to: '0x0000000000000000000000000000000000000000', value: 1n, }) ``` |
| › `publicClient.readContract` | \<TAbi, TFunctionName\>(`args`: `ReadContractParameters`\<`TAbi`, `TFunctionName`\>) => `Promise`\<`ReadContractReturnType`\<`TAbi`, `TFunctionName`\>\> | Calls a read-only function on a contract, and returns the response. - Docs: https://viem.sh/docs/contract/readContract.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts/reading-contracts **`Remarks`** A "read-only" function (constant function) on a Solidity contract is denoted by a `view` or `pure` keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas. Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html). **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' import { readContract } from 'viem/contract' const client = createPublicClient({ chain: mainnet, transport: http(), }) const result = await client.readContract({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['function balanceOf(address) view returns (uint256)']), functionName: 'balanceOf', args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'], }) // 424122n ``` |
| › `publicClient.request` | `EIP1193RequestFn`\<`PublicRpcSchema`\> | Request function wrapped with friendly error handling |
| › `publicClient.sendRawTransaction` | (`args`: `SendRawTransactionParameters`) => `Promise`\<\`0x$\{string}\`\> | Sends a **signed** transaction to the network - Docs: https://viem.sh/docs/actions/wallet/sendRawTransaction.html - JSON-RPC Method: [`eth_sendRawTransaction`](https://ethereum.github.io/execution-apis/api-documentation/) **`Example`** ```ts import { createWalletClient, custom } from 'viem' import { mainnet } from 'viem/chains' import { sendRawTransaction } from 'viem/wallet' const client = createWalletClient({ chain: mainnet, transport: custom(window.ethereum), }) const hash = await client.sendRawTransaction({ serializedTransaction: '0x02f850018203118080825208808080c080a04012522854168b27e5dc3d5839bab5e6b39e1a0ffd343901ce1622e3d64b48f1a04e00902ae0502c4728cbf12156290df99c3ed7de85b1dbfe20b5c36931733a33' }) ``` |
| › `publicClient.simulateContract` | \<TAbi, TFunctionName, TChainOverride\>(`args`: `SimulateContractParameters`\<`TAbi`, `TFunctionName`, `undefined` \| `Chain`, `TChainOverride`\>) => `Promise`\<`SimulateContractReturnType`\<`TAbi`, `TFunctionName`, `undefined` \| `Chain`, `TChainOverride`\>\> | Simulates/validates a contract interaction. This is useful for retrieving **return data** and **revert reasons** of contract write functions. - Docs: https://viem.sh/docs/contract/simulateContract.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts/writing-to-contracts **`Remarks`** This function does not require gas to execute and _**does not**_ change the state of the blockchain. It is almost identical to [`readContract`](https://viem.sh/docs/contract/readContract.html), but also supports contract write functions. Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html). **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const result = await client.simulateContract({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['function mint(uint32) view returns (uint32)']), functionName: 'mint', args: ['69420'], account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', }) ``` |
| › `publicClient.transport` | `TransportConfig`\<`string`, `EIP1193RequestFn`\> & `Record`\<`string`, `any`\> | The RPC transport |
| › `publicClient.type` | `string` | The type of client. |
| › `publicClient.uid` | `string` | A unique ID for the client. |
| › `publicClient.uninstallFilter` | (`args`: `UninstallFilterParameters`) => `Promise`\<`boolean`\> | Destroys a Filter that was created from one of the following Actions: - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter.html) - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter.html) - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter.html) - Docs: https://viem.sh/docs/actions/public/uninstallFilter.html - JSON-RPC Methods: [`eth_uninstallFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_uninstallFilter) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { createPendingTransactionFilter, uninstallFilter } from 'viem/public' const filter = await client.createPendingTransactionFilter() const uninstalled = await client.uninstallFilter({ filter }) // true ``` |
| › `publicClient.verifyMessage` | (`args`: `VerifyMessageParameters`) => `Promise`\<`boolean`\> | - |
| › `publicClient.verifyTypedData` | (`args`: `VerifyTypedDataParameters`) => `Promise`\<`boolean`\> | - |
| › `publicClient.waitForTransactionReceipt` | (`args`: `WaitForTransactionReceiptParameters`\<`undefined` \| `Chain`\>) => `Promise`\<`TransactionReceipt`\> | Waits for the [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms.html#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt). If the Transaction reverts, then the action will throw an error. - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/sending-transactions - JSON-RPC Methods: - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed. - If a Transaction has been replaced: - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions - Checks if one of the Transactions is a replacement - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt). **`Remarks`** The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions). Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce. There are 3 types of Transaction Replacement reasons: - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`) - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`) - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transactionReceipt = await client.waitForTransactionReceipt({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `publicClient.watchBlockNumber` | (`args`: `WatchBlockNumberParameters`) => `WatchBlockNumberReturnType` | Watches and returns incoming block numbers. - Docs: https://viem.sh/docs/actions/public/watchBlockNumber.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/watching-blocks - JSON-RPC Methods: - When `poll: true`, calls [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) on a polling interval. - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newHeads"` event. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = await client.watchBlockNumber({ onBlockNumber: (blockNumber) => console.log(blockNumber), }) ``` |
| › `publicClient.watchBlocks` | \<TIncludeTransactions, TBlockTag\>(`args`: `WatchBlocksParameters`\<`Transport`, `undefined` \| `Chain`, `TIncludeTransactions`, `TBlockTag`\>) => `WatchBlocksReturnType` | Watches and returns information for incoming blocks. - Docs: https://viem.sh/docs/actions/public/watchBlocks.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/watching-blocks - JSON-RPC Methods: - When `poll: true`, calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getBlockByNumber) on a polling interval. - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newHeads"` event. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = await client.watchBlocks({ onBlock: (block) => console.log(block), }) ``` |
| › `publicClient.watchContractEvent` | \<TAbi, TEventName, TStrict\>(`args`: `WatchContractEventParameters`\<`TAbi`, `TEventName`, `TStrict`\>) => `WatchContractEventReturnType` | Watches and returns emitted contract event logs. - Docs: https://viem.sh/docs/contract/watchContractEvent.html **`Remarks`** This Action will batch up all the event logs found within the [`pollingInterval`](https://viem.sh/docs/contract/watchContractEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/contract/watchContractEvent.html#onLogs). `watchContractEvent` will attempt to create an [Event Filter](https://viem.sh/docs/contract/createContractEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchContractEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs.html) instead. **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = client.watchContractEvent({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['event Transfer(address indexed from, address indexed to, uint256 value)']), eventName: 'Transfer', args: { from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b' }, onLogs: (logs) => console.log(logs), }) ``` |
| › `publicClient.watchEvent` | \<TAbiEvent, TAbiEvents, TStrict\>(`args`: `WatchEventParameters`\<`TAbiEvent`, `TAbiEvents`, `TStrict`\>) => `WatchEventReturnType` | Watches and returns emitted [Event Logs](https://viem.sh/docs/glossary/terms.html#event-log). - Docs: https://viem.sh/docs/actions/public/watchEvent.html - JSON-RPC Methods: - **RPC Provider supports `eth_newFilter`:** - Calls [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) to create a filter (called on initialize). - On a polling interval, it will call [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges). - **RPC Provider does not support `eth_newFilter`:** - Calls [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) for each block between the polling interval. **`Remarks`** This Action will batch up all the Event Logs found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/actions/public/watchEvent.html#onLogs). `watchEvent` will attempt to create an [Event Filter](https://viem.sh/docs/actions/public/createEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs.html) instead. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = client.watchEvent({ onLogs: (logs) => console.log(logs), }) ``` |
| › `publicClient.watchPendingTransactions` | (`args`: `WatchPendingTransactionsParameters`\<`Transport`\>) => `WatchPendingTransactionsReturnType` | Watches and returns pending transaction hashes. - Docs: https://viem.sh/docs/actions/public/watchPendingTransactions.html - JSON-RPC Methods: - When `poll: true` - Calls [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) to initialize the filter. - Calls [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getFilterChanges) on a polling interval. - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newPendingTransactions"` event. **`Remarks`** This Action will batch up all the pending transactions found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#pollinginterval-optional), and invoke them via [`onTransactions`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#ontransactions). **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = await client.watchPendingTransactions({ onTransactions: (hashes) => console.log(hashes), }) ``` |
| › `tokenBridgeCreatorAddressOverride?` | \`0x$\{string}\` | Specifies a custom address for the TokenBridgeCreator. By default, the address will be automatically detected based on the provided chain. |

#### Returns

`Promise`\<`boolean`\>

#### Defined in

[src/createTokenBridgeEnoughCustomFeeTokenAllowance.ts:18](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/createTokenBridgeEnoughCustomFeeTokenAllowance.ts#L18)

___

### createTokenBridgeFetchTokenBridgeContracts

**createTokenBridgeFetchTokenBridgeContracts**(`«destructured»`): `Promise`\<`TokenBridgeContracts`\>

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `«destructured»` | `Object` | - |
| › `inbox` | \`0x$\{string}\` | - |
| › `parentChainPublicClient` | `Object` | - |
| › `parentChainPublicClient.account` | `undefined` | The Account of the Client. |
| › `parentChainPublicClient.batch?` | `Object` | Flags for batch settings. |
| › `parentChainPublicClient.batch.multicall?` | `boolean` \| \{ `batchSize?`: `number` ; `wait?`: `number`  } | Toggle to enable `eth_call` multicall aggregation. |
| › `parentChainPublicClient.cacheTime` | `number` | Time (in ms) that cached data will remain in memory. |
| › `parentChainPublicClient.call` | (`parameters`: `CallParameters`\<`undefined` \| `Chain`\>) => `Promise`\<`CallReturnType`\> | Executes a new message call immediately without submitting a transaction to the network. - Docs: https://viem.sh/docs/actions/public/call.html - JSON-RPC Methods: [`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const data = await client.call({ account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', }) ``` |
| › `parentChainPublicClient.chain` | `undefined` \| `Chain` | Chain for the client. |
| › `parentChainPublicClient.createBlockFilter` | () => `Promise`\<\{ `id`: \`0x$\{string}\` ; `request`: `EIP1193RequestFn`\<readonly [\{ `Method`: ``"eth_getFilterChanges"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: \`0x$\{(...)}\`[] \| `RpcLog`[]  }, \{ `Method`: ``"eth_getFilterLogs"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `RpcLog`[]  }, \{ `Method`: ``"eth_uninstallFilter"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `boolean`  }]\> ; `type`: ``"block"``  }\> | Creates a Filter to listen for new block hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html). - Docs: https://viem.sh/docs/actions/public/createBlockFilter.html - JSON-RPC Methods: [`eth_newBlockFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newBlockFilter) **`Example`** ```ts import { createPublicClient, createBlockFilter, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await createBlockFilter(client) // { id: "0x345a6572337856574a76364e457a4366", type: 'block' } ``` |
| › `parentChainPublicClient.createContractEventFilter` | \<TAbi, TEventName, TArgs, TStrict, TFromBlock, TToBlock\>(`args`: `CreateContractEventFilterParameters`\<`TAbi`, `TEventName`, `TArgs`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`CreateContractEventFilterReturnType`\<`TAbi`, `TEventName`, `TArgs`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Creates a Filter to retrieve event logs that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html) or [`getFilterLogs`](https://viem.sh/docs/actions/public/getFilterLogs.html). - Docs: https://viem.sh/docs/contract/createContractEventFilter.html **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createContractEventFilter({ abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']), }) ``` |
| › `parentChainPublicClient.createEventFilter` | \<TAbiEvent, TAbiEvents, TStrict, TFromBlock, TToBlock, _EventName, _Args\>(`args?`: `CreateEventFilterParameters`\<`TAbiEvent`, `TAbiEvents`, `TStrict`, `TFromBlock`, `TToBlock`, `_EventName`, `_Args`\>) => `Promise`\<\{ [K in string \| number \| symbol]: Filter\<"event", TAbiEvents, \_EventName, \_Args, TStrict, TFromBlock, TToBlock\>[K] }\> | Creates a [`Filter`](https://viem.sh/docs/glossary/types.html#filter) to listen for new events that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html). - Docs: https://viem.sh/docs/actions/public/createEventFilter.html - JSON-RPC Methods: [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createEventFilter({ address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2', }) ``` |
| › `parentChainPublicClient.createPendingTransactionFilter` | () => `Promise`\<\{ `id`: \`0x$\{string}\` ; `request`: `EIP1193RequestFn`\<readonly [\{ `Method`: ``"eth_getFilterChanges"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: \`0x$\{(...)}\`[] \| `RpcLog`[]  }, \{ `Method`: ``"eth_getFilterLogs"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `RpcLog`[]  }, \{ `Method`: ``"eth_uninstallFilter"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `boolean`  }]\> ; `type`: ``"transaction"``  }\> | Creates a Filter to listen for new pending transaction hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html). - Docs: https://viem.sh/docs/actions/public/createPendingTransactionFilter.html - JSON-RPC Methods: [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createPendingTransactionFilter() // { id: "0x345a6572337856574a76364e457a4366", type: 'transaction' } ``` |
| › `parentChainPublicClient.estimateContractGas` | \<TChain, TAbi, TFunctionName\>(`args`: `EstimateContractGasParameters`\<`TAbi`, `TFunctionName`, `TChain`, `undefined` \| `Account`\>) => `Promise`\<`bigint`\> | Estimates the gas required to successfully execute a contract write function call. - Docs: https://viem.sh/docs/contract/estimateContractGas.html **`Remarks`** Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`estimateGas` action](https://viem.sh/docs/actions/public/estimateGas.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html). **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const gas = await client.estimateContractGas({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['function mint() public']), functionName: 'mint', account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', }) ``` |
| › `parentChainPublicClient.estimateFeesPerGas` | \<TChainOverride, TType\>(`args?`: `EstimateFeesPerGasParameters`\<`undefined` \| `Chain`, `TChainOverride`, `TType`\>) => `Promise`\<`EstimateFeesPerGasReturnType`\> | Returns an estimate for the fees per gas for a transaction to be included in the next block. - Docs: https://viem.sh/docs/actions/public/estimateFeesPerGas.html **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const maxPriorityFeePerGas = await client.estimateFeesPerGas() // { maxFeePerGas: ..., maxPriorityFeePerGas: ... } ``` |
| › `parentChainPublicClient.estimateGas` | (`args`: `EstimateGasParameters`\<`undefined` \| `Chain`, `undefined` \| `Account`\>) => `Promise`\<`bigint`\> | Estimates the gas necessary to complete a transaction without submitting it to the network. - Docs: https://viem.sh/docs/actions/public/estimateGas.html - JSON-RPC Methods: [`eth_estimateGas`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas) **`Example`** ```ts import { createPublicClient, http, parseEther } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const gasEstimate = await client.estimateGas({ account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', value: parseEther('1'), }) ``` |
| › `parentChainPublicClient.estimateMaxPriorityFeePerGas` | \<TChainOverride\>(`args?`: \{ `chain`: ``null`` \| `TChainOverride`  }) => `Promise`\<`bigint`\> | Returns an estimate for the max priority fee per gas (in wei) for a transaction to be included in the next block. - Docs: https://viem.sh/docs/actions/public/estimateMaxPriorityFeePerGas.html **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const maxPriorityFeePerGas = await client.estimateMaxPriorityFeePerGas() // 10000000n ``` |
| › `parentChainPublicClient.extend` | \<client\>(`fn`: (`client`: `Client`\<`Transport`, `undefined` \| `Chain`, `undefined`, `PublicRpcSchema`, `PublicActions`\<`Transport`, `undefined` \| `Chain`\>\>) => `client`) => `Client`\<`Transport`, `undefined` \| `Chain`, `undefined`, `PublicRpcSchema`, \{ [K in string \| number \| symbol]: client[K] } & `PublicActions`\<`Transport`, `undefined` \| `Chain`\>\> | - |
| › `parentChainPublicClient.getBalance` | (`args`: `GetBalanceParameters`) => `Promise`\<`bigint`\> | Returns the balance of an address in wei. - Docs: https://viem.sh/docs/actions/public/getBalance.html - JSON-RPC Methods: [`eth_getBalance`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getbalance) **`Remarks`** You can convert the balance to ether units with [`formatEther`](https://viem.sh/docs/utilities/formatEther.html). ```ts const balance = await getBalance(client, { address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', blockTag: 'safe' }) const balanceAsEther = formatEther(balance) // "6.942" ``` **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const balance = await client.getBalance({ address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', }) // 10000000000000000000000n (wei) ``` |
| › `parentChainPublicClient.getBlock` | \<TIncludeTransactions, TBlockTag\>(`args?`: `GetBlockParameters`\<`TIncludeTransactions`, `TBlockTag`\>) => `Promise`\<`GetBlockReturnType`\<`undefined` \| `Chain`, `TIncludeTransactions`, `TBlockTag`\>\> | Returns information about a block at a block number, hash, or tag. - Docs: https://viem.sh/docs/actions/public/getBlock.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/fetching-blocks - JSON-RPC Methods: - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) for `blockNumber` & `blockTag`. - Calls [`eth_getBlockByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbyhash) for `blockHash`. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const block = await client.getBlock() ``` |
| › `parentChainPublicClient.getBlockNumber` | (`args?`: `GetBlockNumberParameters`) => `Promise`\<`bigint`\> | Returns the number of the most recent block seen. - Docs: https://viem.sh/docs/actions/public/getBlockNumber.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/fetching-blocks - JSON-RPC Methods: [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const blockNumber = await client.getBlockNumber() // 69420n ``` |
| › `parentChainPublicClient.getBlockTransactionCount` | (`args?`: `GetBlockTransactionCountParameters`) => `Promise`\<`number`\> | Returns the number of Transactions at a block number, hash, or tag. - Docs: https://viem.sh/docs/actions/public/getBlockTransactionCount.html - JSON-RPC Methods: - Calls [`eth_getBlockTransactionCountByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbynumber) for `blockNumber` & `blockTag`. - Calls [`eth_getBlockTransactionCountByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbyhash) for `blockHash`. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const count = await client.getBlockTransactionCount() ``` |
| › `parentChainPublicClient.getBytecode` | (`args`: `GetBytecodeParameters`) => `Promise`\<`GetBytecodeReturnType`\> | Retrieves the bytecode at an address. - Docs: https://viem.sh/docs/contract/getBytecode.html - JSON-RPC Methods: [`eth_getCode`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getcode) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const code = await client.getBytecode({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', }) ``` |
| › `parentChainPublicClient.getChainId` | () => `Promise`\<`number`\> | Returns the chain ID associated with the current network. - Docs: https://viem.sh/docs/actions/public/getChainId.html - JSON-RPC Methods: [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const chainId = await client.getChainId() // 1 ``` |
| › `parentChainPublicClient.getContractEvents` | \<TAbi, TEventName, TStrict, TFromBlock, TToBlock\>(`args`: `GetContractEventsParameters`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetContractEventsReturnType`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of event logs emitted by a contract. - Docs: https://viem.sh/docs/actions/public/getContractEvents.html - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { wagmiAbi } from './abi' const client = createPublicClient({ chain: mainnet, transport: http(), }) const logs = await client.getContractEvents(client, { address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: wagmiAbi, eventName: 'Transfer' }) ``` |
| › `parentChainPublicClient.getEnsAddress` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `coinType?`: `number` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsAddressReturnType`\> | Gets address for ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsAddress.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const ensAddress = await client.getEnsAddress({ name: normalize('wevm.eth'), }) // '0xd2135CfB216b74109775236E36d4b433F1DF507B' ``` |
| › `parentChainPublicClient.getEnsAvatar` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `gatewayUrls?`: `AssetGatewayUrls` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsAvatarReturnType`\> | Gets the avatar of an ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsAvatar.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls [`getEnsText`](https://viem.sh/docs/ens/actions/getEnsText.html) with `key` set to `'avatar'`. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const ensAvatar = await client.getEnsAvatar({ name: normalize('wevm.eth'), }) // 'https://ipfs.io/ipfs/Qma8mnp6xV3J2cRNf3mTth5C8nV11CAnceVinc3y8jSbio' ``` |
| › `parentChainPublicClient.getEnsName` | (`args`: \{ `address`: \`0x$\{string}\` ; `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsNameReturnType`\> | Gets primary name for specified address. - Docs: https://viem.sh/docs/ens/actions/getEnsName.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `reverse(bytes)` on ENS Universal Resolver Contract to "reverse resolve" the address to the primary ENS name. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const ensName = await client.getEnsName({ address: '0xd2135CfB216b74109775236E36d4b433F1DF507B', }) // 'wevm.eth' ``` |
| › `parentChainPublicClient.getEnsResolver` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<\`0x$\{string}\`\> | Gets resolver for ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `findResolver(bytes)` on ENS Universal Resolver Contract to retrieve the resolver of an ENS name. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const resolverAddress = await client.getEnsResolver({ name: normalize('wevm.eth'), }) // '0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41' ``` |
| › `parentChainPublicClient.getEnsText` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `key`: `string` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsTextReturnType`\> | Gets a text record for specified ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const twitterRecord = await client.getEnsText({ name: normalize('wevm.eth'), key: 'com.twitter', }) // 'wagmi_sh' ``` |
| › `parentChainPublicClient.getFeeHistory` | (`args`: `GetFeeHistoryParameters`) => `Promise`\<`GetFeeHistoryReturnType`\> | Returns a collection of historical gas information. - Docs: https://viem.sh/docs/actions/public/getFeeHistory.html - JSON-RPC Methods: [`eth_feeHistory`](https://docs.alchemy.com/reference/eth-feehistory) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const feeHistory = await client.getFeeHistory({ blockCount: 4, rewardPercentiles: [25, 75], }) ``` |
| › `parentChainPublicClient.getFilterChanges` | \<TFilterType, TAbi, TEventName, TStrict, TFromBlock, TToBlock\>(`args`: `GetFilterChangesParameters`\<`TFilterType`, `TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetFilterChangesReturnType`\<`TFilterType`, `TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of logs or hashes based on a [Filter](/docs/glossary/terms#filter) since the last time it was called. - Docs: https://viem.sh/docs/actions/public/getFilterChanges.html - JSON-RPC Methods: [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges) **`Remarks`** A Filter can be created from the following actions: - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter.html) - [`createContractEventFilter`](https://viem.sh/docs/contract/createContractEventFilter.html) - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter.html) - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter.html) Depending on the type of filter, the return value will be different: - If the filter was created with `createContractEventFilter` or `createEventFilter`, it returns a list of logs. - If the filter was created with `createPendingTransactionFilter`, it returns a list of transaction hashes. - If the filter was created with `createBlockFilter`, it returns a list of block hashes. **`Example`** ```ts // Blocks import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createBlockFilter() const hashes = await client.getFilterChanges({ filter }) ``` **`Example`** ```ts // Contract Events import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createContractEventFilter({ address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']), eventName: 'Transfer', }) const logs = await client.getFilterChanges({ filter }) ``` **`Example`** ```ts // Raw Events import { createPublicClient, http, parseAbiItem } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createEventFilter({ address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'), }) const logs = await client.getFilterChanges({ filter }) ``` **`Example`** ```ts // Transactions import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createPendingTransactionFilter() const hashes = await client.getFilterChanges({ filter }) ``` |
| › `parentChainPublicClient.getFilterLogs` | \<TAbi, TEventName, TStrict, TFromBlock, TToBlock\>(`args`: `GetFilterLogsParameters`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetFilterLogsReturnType`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of event logs since the filter was created. - Docs: https://viem.sh/docs/actions/public/getFilterLogs.html - JSON-RPC Methods: [`eth_getFilterLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterlogs) **`Remarks`** `getFilterLogs` is only compatible with **event filters**. **`Example`** ```ts import { createPublicClient, http, parseAbiItem } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createEventFilter({ address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'), }) const logs = await client.getFilterLogs({ filter }) ``` |
| › `parentChainPublicClient.getGasPrice` | () => `Promise`\<`bigint`\> | Returns the current price of gas (in wei). - Docs: https://viem.sh/docs/actions/public/getGasPrice.html - JSON-RPC Methods: [`eth_gasPrice`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gasprice) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const gasPrice = await client.getGasPrice() ``` |
| › `parentChainPublicClient.getLogs` | \<TAbiEvent, TAbiEvents, TStrict, TFromBlock, TToBlock\>(`args?`: `GetLogsParameters`\<`TAbiEvent`, `TAbiEvents`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetLogsReturnType`\<`TAbiEvent`, `TAbiEvents`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of event logs matching the provided parameters. - Docs: https://viem.sh/docs/actions/public/getLogs.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/filters-and-logs/event-logs - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) **`Example`** ```ts import { createPublicClient, http, parseAbiItem } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const logs = await client.getLogs() ``` |
| › `parentChainPublicClient.getProof` | (`args`: `GetProofParameters`) => `Promise`\<`GetProofReturnType`\> | Returns the account and storage values of the specified account including the Merkle-proof. - Docs: https://viem.sh/docs/actions/public/getProof.html - JSON-RPC Methods: - Calls [`eth_getProof`](https://eips.ethereum.org/EIPS/eip-1186) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const block = await client.getProof({ address: '0x...', storageKeys: ['0x...'], }) ``` |
| › `parentChainPublicClient.getStorageAt` | (`args`: `GetStorageAtParameters`) => `Promise`\<`GetStorageAtReturnType`\> | Returns the value from a storage slot at a given address. - Docs: https://viem.sh/docs/contract/getStorageAt.html - JSON-RPC Methods: [`eth_getStorageAt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getstorageat) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { getStorageAt } from 'viem/contract' const client = createPublicClient({ chain: mainnet, transport: http(), }) const code = await client.getStorageAt({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', slot: toHex(0), }) ``` |
| › `parentChainPublicClient.getTransaction` | \<TBlockTag\>(`args`: `GetTransactionParameters`\<`TBlockTag`\>) => `Promise`\<`GetTransactionReturnType`\<`undefined` \| `Chain`, `TBlockTag`\>\> | Returns information about a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) given a hash or block identifier. - Docs: https://viem.sh/docs/actions/public/getTransaction.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/fetching-transactions - JSON-RPC Methods: [`eth_getTransactionByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionByHash) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transaction = await client.getTransaction({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `parentChainPublicClient.getTransactionConfirmations` | (`args`: `GetTransactionConfirmationsParameters`\<`undefined` \| `Chain`\>) => `Promise`\<`bigint`\> | Returns the number of blocks passed (confirmations) since the transaction was processed on a block. - Docs: https://viem.sh/docs/actions/public/getTransactionConfirmations.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/fetching-transactions - JSON-RPC Methods: [`eth_getTransactionConfirmations`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionConfirmations) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const confirmations = await client.getTransactionConfirmations({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `parentChainPublicClient.getTransactionCount` | (`args`: `GetTransactionCountParameters`) => `Promise`\<`number`\> | Returns the number of [Transactions](https://viem.sh/docs/glossary/terms.html#transaction) an Account has broadcast / sent. - Docs: https://viem.sh/docs/actions/public/getTransactionCount.html - JSON-RPC Methods: [`eth_getTransactionCount`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactioncount) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transactionCount = await client.getTransactionCount({ address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', }) ``` |
| › `parentChainPublicClient.getTransactionReceipt` | (`args`: `GetTransactionReceiptParameters`) => `Promise`\<`TransactionReceipt`\> | Returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt) given a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash. - Docs: https://viem.sh/docs/actions/public/getTransactionReceipt.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/fetching-transactions - JSON-RPC Methods: [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transactionReceipt = await client.getTransactionReceipt({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `parentChainPublicClient.key` | `string` | A key for the client. |
| › `parentChainPublicClient.multicall` | \<TContracts, TAllowFailure\>(`args`: `MulticallParameters`\<`TContracts`, `TAllowFailure`\>) => `Promise`\<`MulticallReturnType`\<`TContracts`, `TAllowFailure`\>\> | Similar to [`readContract`](https://viem.sh/docs/contract/readContract.html), but batches up multiple functions on a contract in a single RPC call via the [`multicall3` contract](https://github.com/mds1/multicall). - Docs: https://viem.sh/docs/contract/multicall.html **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const abi = parseAbi([ 'function balanceOf(address) view returns (uint256)', 'function totalSupply() view returns (uint256)', ]) const result = await client.multicall({ contracts: [ { address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi, functionName: 'balanceOf', args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'], }, { address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi, functionName: 'totalSupply', }, ], }) // [{ result: 424122n, status: 'success' }, { result: 1000000n, status: 'success' }] ``` |
| › `parentChainPublicClient.name` | `string` | A name for the client. |
| › `parentChainPublicClient.pollingInterval` | `number` | Frequency (in ms) for polling enabled actions & events. Defaults to 4_000 milliseconds. |
| › `parentChainPublicClient.prepareTransactionRequest` | \<TChainOverride\>(`args`: `PrepareTransactionRequestParameters`\<`undefined` \| `Chain`, `undefined` \| `Account`, `TChainOverride`\>) => `Promise`\<`PrepareTransactionRequestReturnType`\> | Prepares a transaction request for signing. - Docs: https://viem.sh/docs/actions/wallet/prepareTransactionRequest.html **`Example`** ```ts import { createWalletClient, custom } from 'viem' import { mainnet } from 'viem/chains' const client = createWalletClient({ chain: mainnet, transport: custom(window.ethereum), }) const request = await client.prepareTransactionRequest({ account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', to: '0x0000000000000000000000000000000000000000', value: 1n, }) ``` **`Example`** ```ts // Account Hoisting import { createWalletClient, http } from 'viem' import { privateKeyToAccount } from 'viem/accounts' import { mainnet } from 'viem/chains' const client = createWalletClient({ account: privateKeyToAccount('0x…'), chain: mainnet, transport: custom(window.ethereum), }) const request = await client.prepareTransactionRequest({ to: '0x0000000000000000000000000000000000000000', value: 1n, }) ``` |
| › `parentChainPublicClient.readContract` | \<TAbi, TFunctionName\>(`args`: `ReadContractParameters`\<`TAbi`, `TFunctionName`\>) => `Promise`\<`ReadContractReturnType`\<`TAbi`, `TFunctionName`\>\> | Calls a read-only function on a contract, and returns the response. - Docs: https://viem.sh/docs/contract/readContract.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts/reading-contracts **`Remarks`** A "read-only" function (constant function) on a Solidity contract is denoted by a `view` or `pure` keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas. Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html). **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' import { readContract } from 'viem/contract' const client = createPublicClient({ chain: mainnet, transport: http(), }) const result = await client.readContract({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['function balanceOf(address) view returns (uint256)']), functionName: 'balanceOf', args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'], }) // 424122n ``` |
| › `parentChainPublicClient.request` | `EIP1193RequestFn`\<`PublicRpcSchema`\> | Request function wrapped with friendly error handling |
| › `parentChainPublicClient.sendRawTransaction` | (`args`: `SendRawTransactionParameters`) => `Promise`\<\`0x$\{string}\`\> | Sends a **signed** transaction to the network - Docs: https://viem.sh/docs/actions/wallet/sendRawTransaction.html - JSON-RPC Method: [`eth_sendRawTransaction`](https://ethereum.github.io/execution-apis/api-documentation/) **`Example`** ```ts import { createWalletClient, custom } from 'viem' import { mainnet } from 'viem/chains' import { sendRawTransaction } from 'viem/wallet' const client = createWalletClient({ chain: mainnet, transport: custom(window.ethereum), }) const hash = await client.sendRawTransaction({ serializedTransaction: '0x02f850018203118080825208808080c080a04012522854168b27e5dc3d5839bab5e6b39e1a0ffd343901ce1622e3d64b48f1a04e00902ae0502c4728cbf12156290df99c3ed7de85b1dbfe20b5c36931733a33' }) ``` |
| › `parentChainPublicClient.simulateContract` | \<TAbi, TFunctionName, TChainOverride\>(`args`: `SimulateContractParameters`\<`TAbi`, `TFunctionName`, `undefined` \| `Chain`, `TChainOverride`\>) => `Promise`\<`SimulateContractReturnType`\<`TAbi`, `TFunctionName`, `undefined` \| `Chain`, `TChainOverride`\>\> | Simulates/validates a contract interaction. This is useful for retrieving **return data** and **revert reasons** of contract write functions. - Docs: https://viem.sh/docs/contract/simulateContract.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts/writing-to-contracts **`Remarks`** This function does not require gas to execute and _**does not**_ change the state of the blockchain. It is almost identical to [`readContract`](https://viem.sh/docs/contract/readContract.html), but also supports contract write functions. Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html). **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const result = await client.simulateContract({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['function mint(uint32) view returns (uint32)']), functionName: 'mint', args: ['69420'], account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', }) ``` |
| › `parentChainPublicClient.transport` | `TransportConfig`\<`string`, `EIP1193RequestFn`\> & `Record`\<`string`, `any`\> | The RPC transport |
| › `parentChainPublicClient.type` | `string` | The type of client. |
| › `parentChainPublicClient.uid` | `string` | A unique ID for the client. |
| › `parentChainPublicClient.uninstallFilter` | (`args`: `UninstallFilterParameters`) => `Promise`\<`boolean`\> | Destroys a Filter that was created from one of the following Actions: - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter.html) - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter.html) - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter.html) - Docs: https://viem.sh/docs/actions/public/uninstallFilter.html - JSON-RPC Methods: [`eth_uninstallFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_uninstallFilter) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { createPendingTransactionFilter, uninstallFilter } from 'viem/public' const filter = await client.createPendingTransactionFilter() const uninstalled = await client.uninstallFilter({ filter }) // true ``` |
| › `parentChainPublicClient.verifyMessage` | (`args`: `VerifyMessageParameters`) => `Promise`\<`boolean`\> | - |
| › `parentChainPublicClient.verifyTypedData` | (`args`: `VerifyTypedDataParameters`) => `Promise`\<`boolean`\> | - |
| › `parentChainPublicClient.waitForTransactionReceipt` | (`args`: `WaitForTransactionReceiptParameters`\<`undefined` \| `Chain`\>) => `Promise`\<`TransactionReceipt`\> | Waits for the [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms.html#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt). If the Transaction reverts, then the action will throw an error. - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/sending-transactions - JSON-RPC Methods: - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed. - If a Transaction has been replaced: - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions - Checks if one of the Transactions is a replacement - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt). **`Remarks`** The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions). Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce. There are 3 types of Transaction Replacement reasons: - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`) - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`) - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transactionReceipt = await client.waitForTransactionReceipt({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `parentChainPublicClient.watchBlockNumber` | (`args`: `WatchBlockNumberParameters`) => `WatchBlockNumberReturnType` | Watches and returns incoming block numbers. - Docs: https://viem.sh/docs/actions/public/watchBlockNumber.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/watching-blocks - JSON-RPC Methods: - When `poll: true`, calls [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) on a polling interval. - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newHeads"` event. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = await client.watchBlockNumber({ onBlockNumber: (blockNumber) => console.log(blockNumber), }) ``` |
| › `parentChainPublicClient.watchBlocks` | \<TIncludeTransactions, TBlockTag\>(`args`: `WatchBlocksParameters`\<`Transport`, `undefined` \| `Chain`, `TIncludeTransactions`, `TBlockTag`\>) => `WatchBlocksReturnType` | Watches and returns information for incoming blocks. - Docs: https://viem.sh/docs/actions/public/watchBlocks.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/watching-blocks - JSON-RPC Methods: - When `poll: true`, calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getBlockByNumber) on a polling interval. - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newHeads"` event. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = await client.watchBlocks({ onBlock: (block) => console.log(block), }) ``` |
| › `parentChainPublicClient.watchContractEvent` | \<TAbi, TEventName, TStrict\>(`args`: `WatchContractEventParameters`\<`TAbi`, `TEventName`, `TStrict`\>) => `WatchContractEventReturnType` | Watches and returns emitted contract event logs. - Docs: https://viem.sh/docs/contract/watchContractEvent.html **`Remarks`** This Action will batch up all the event logs found within the [`pollingInterval`](https://viem.sh/docs/contract/watchContractEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/contract/watchContractEvent.html#onLogs). `watchContractEvent` will attempt to create an [Event Filter](https://viem.sh/docs/contract/createContractEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchContractEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs.html) instead. **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = client.watchContractEvent({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['event Transfer(address indexed from, address indexed to, uint256 value)']), eventName: 'Transfer', args: { from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b' }, onLogs: (logs) => console.log(logs), }) ``` |
| › `parentChainPublicClient.watchEvent` | \<TAbiEvent, TAbiEvents, TStrict\>(`args`: `WatchEventParameters`\<`TAbiEvent`, `TAbiEvents`, `TStrict`\>) => `WatchEventReturnType` | Watches and returns emitted [Event Logs](https://viem.sh/docs/glossary/terms.html#event-log). - Docs: https://viem.sh/docs/actions/public/watchEvent.html - JSON-RPC Methods: - **RPC Provider supports `eth_newFilter`:** - Calls [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) to create a filter (called on initialize). - On a polling interval, it will call [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges). - **RPC Provider does not support `eth_newFilter`:** - Calls [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) for each block between the polling interval. **`Remarks`** This Action will batch up all the Event Logs found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/actions/public/watchEvent.html#onLogs). `watchEvent` will attempt to create an [Event Filter](https://viem.sh/docs/actions/public/createEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs.html) instead. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = client.watchEvent({ onLogs: (logs) => console.log(logs), }) ``` |
| › `parentChainPublicClient.watchPendingTransactions` | (`args`: `WatchPendingTransactionsParameters`\<`Transport`\>) => `WatchPendingTransactionsReturnType` | Watches and returns pending transaction hashes. - Docs: https://viem.sh/docs/actions/public/watchPendingTransactions.html - JSON-RPC Methods: - When `poll: true` - Calls [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) to initialize the filter. - Calls [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getFilterChanges) on a polling interval. - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newPendingTransactions"` event. **`Remarks`** This Action will batch up all the pending transactions found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#pollinginterval-optional), and invoke them via [`onTransactions`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#ontransactions). **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = await client.watchPendingTransactions({ onTransactions: (hashes) => console.log(hashes), }) ``` |
| › `tokenBridgeCreatorAddressOverride?` | \`0x$\{string}\` | Specifies a custom address for the TokenBridgeCreator. By default, the address will be automatically detected based on the provided chain. |

#### Returns

`Promise`\<`TokenBridgeContracts`\>

#### Defined in

[src/createTokenBridgeFetchTokenBridgeContracts.ts:17](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/createTokenBridgeFetchTokenBridgeContracts.ts#L17)

___

### createTokenBridgePrepareCustomFeeTokenApprovalTransactionRequest

**createTokenBridgePrepareCustomFeeTokenApprovalTransactionRequest**(`«destructured»`): `Promise`\<\{ `accessList?`: `undefined` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `bigint` ; `maxFeePerGas?`: `undefined` ; `maxPriorityFeePerGas?`: `undefined` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"legacy"`` ; `value?`: `bigint`  } \| \{ `accessList?`: `AccessList` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `bigint` ; `maxFeePerGas?`: `undefined` ; `maxPriorityFeePerGas?`: `undefined` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"eip2930"`` ; `value?`: `bigint`  } \| \{ `accessList?`: `AccessList` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `undefined` ; `maxFeePerGas?`: `bigint` ; `maxPriorityFeePerGas?`: `bigint` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"eip1559"`` ; `value?`: `bigint`  }\>

#### Parameters

| Name | Type | Default value | Description |
| :------ | :------ | :------ | :------ |
| `«destructured»` | `Object` | `undefined` | - |
| › `amount?` | `bigint` | `maxInt256` | - |
| › `nativeToken` | \`0x$\{string}\` | `undefined` | - |
| › `owner` | \`0x$\{string}\` | `undefined` | - |
| › `publicClient` | `Object` | `undefined` | - |
| › `publicClient.account` | `undefined` | `undefined` | The Account of the Client. |
| › `publicClient.batch?` | `Object` | `undefined` | Flags for batch settings. |
| › `publicClient.batch.multicall?` | `boolean` \| \{ `batchSize?`: `number` ; `wait?`: `number`  } | `undefined` | Toggle to enable `eth_call` multicall aggregation. |
| › `publicClient.cacheTime` | `number` | `undefined` | Time (in ms) that cached data will remain in memory. |
| › `publicClient.call` | (`parameters`: `CallParameters`\<`undefined` \| `Chain`\>) => `Promise`\<`CallReturnType`\> | `undefined` | Executes a new message call immediately without submitting a transaction to the network. - Docs: https://viem.sh/docs/actions/public/call.html - JSON-RPC Methods: [`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const data = await client.call({ account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', }) ``` |
| › `publicClient.chain` | `undefined` \| `Chain` | `undefined` | Chain for the client. |
| › `publicClient.createBlockFilter` | () => `Promise`\<\{ `id`: \`0x$\{string}\` ; `request`: `EIP1193RequestFn`\<readonly [\{ `Method`: ``"eth_getFilterChanges"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: \`0x$\{(...)}\`[] \| `RpcLog`[]  }, \{ `Method`: ``"eth_getFilterLogs"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `RpcLog`[]  }, \{ `Method`: ``"eth_uninstallFilter"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `boolean`  }]\> ; `type`: ``"block"``  }\> | `undefined` | Creates a Filter to listen for new block hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html). - Docs: https://viem.sh/docs/actions/public/createBlockFilter.html - JSON-RPC Methods: [`eth_newBlockFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newBlockFilter) **`Example`** ```ts import { createPublicClient, createBlockFilter, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await createBlockFilter(client) // { id: "0x345a6572337856574a76364e457a4366", type: 'block' } ``` |
| › `publicClient.createContractEventFilter` | \<TAbi, TEventName, TArgs, TStrict, TFromBlock, TToBlock\>(`args`: `CreateContractEventFilterParameters`\<`TAbi`, `TEventName`, `TArgs`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`CreateContractEventFilterReturnType`\<`TAbi`, `TEventName`, `TArgs`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | `undefined` | Creates a Filter to retrieve event logs that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html) or [`getFilterLogs`](https://viem.sh/docs/actions/public/getFilterLogs.html). - Docs: https://viem.sh/docs/contract/createContractEventFilter.html **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createContractEventFilter({ abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']), }) ``` |
| › `publicClient.createEventFilter` | \<TAbiEvent, TAbiEvents, TStrict, TFromBlock, TToBlock, _EventName, _Args\>(`args?`: `CreateEventFilterParameters`\<`TAbiEvent`, `TAbiEvents`, `TStrict`, `TFromBlock`, `TToBlock`, `_EventName`, `_Args`\>) => `Promise`\<\{ [K in string \| number \| symbol]: Filter\<"event", TAbiEvents, \_EventName, \_Args, TStrict, TFromBlock, TToBlock\>[K] }\> | `undefined` | Creates a [`Filter`](https://viem.sh/docs/glossary/types.html#filter) to listen for new events that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html). - Docs: https://viem.sh/docs/actions/public/createEventFilter.html - JSON-RPC Methods: [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createEventFilter({ address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2', }) ``` |
| › `publicClient.createPendingTransactionFilter` | () => `Promise`\<\{ `id`: \`0x$\{string}\` ; `request`: `EIP1193RequestFn`\<readonly [\{ `Method`: ``"eth_getFilterChanges"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: \`0x$\{(...)}\`[] \| `RpcLog`[]  }, \{ `Method`: ``"eth_getFilterLogs"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `RpcLog`[]  }, \{ `Method`: ``"eth_uninstallFilter"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `boolean`  }]\> ; `type`: ``"transaction"``  }\> | `undefined` | Creates a Filter to listen for new pending transaction hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html). - Docs: https://viem.sh/docs/actions/public/createPendingTransactionFilter.html - JSON-RPC Methods: [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createPendingTransactionFilter() // { id: "0x345a6572337856574a76364e457a4366", type: 'transaction' } ``` |
| › `publicClient.estimateContractGas` | \<TChain, TAbi, TFunctionName\>(`args`: `EstimateContractGasParameters`\<`TAbi`, `TFunctionName`, `TChain`, `undefined` \| `Account`\>) => `Promise`\<`bigint`\> | `undefined` | Estimates the gas required to successfully execute a contract write function call. - Docs: https://viem.sh/docs/contract/estimateContractGas.html **`Remarks`** Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`estimateGas` action](https://viem.sh/docs/actions/public/estimateGas.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html). **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const gas = await client.estimateContractGas({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['function mint() public']), functionName: 'mint', account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', }) ``` |
| › `publicClient.estimateFeesPerGas` | \<TChainOverride, TType\>(`args?`: `EstimateFeesPerGasParameters`\<`undefined` \| `Chain`, `TChainOverride`, `TType`\>) => `Promise`\<`EstimateFeesPerGasReturnType`\> | `undefined` | Returns an estimate for the fees per gas for a transaction to be included in the next block. - Docs: https://viem.sh/docs/actions/public/estimateFeesPerGas.html **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const maxPriorityFeePerGas = await client.estimateFeesPerGas() // { maxFeePerGas: ..., maxPriorityFeePerGas: ... } ``` |
| › `publicClient.estimateGas` | (`args`: `EstimateGasParameters`\<`undefined` \| `Chain`, `undefined` \| `Account`\>) => `Promise`\<`bigint`\> | `undefined` | Estimates the gas necessary to complete a transaction without submitting it to the network. - Docs: https://viem.sh/docs/actions/public/estimateGas.html - JSON-RPC Methods: [`eth_estimateGas`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas) **`Example`** ```ts import { createPublicClient, http, parseEther } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const gasEstimate = await client.estimateGas({ account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', value: parseEther('1'), }) ``` |
| › `publicClient.estimateMaxPriorityFeePerGas` | \<TChainOverride\>(`args?`: \{ `chain`: ``null`` \| `TChainOverride`  }) => `Promise`\<`bigint`\> | `undefined` | Returns an estimate for the max priority fee per gas (in wei) for a transaction to be included in the next block. - Docs: https://viem.sh/docs/actions/public/estimateMaxPriorityFeePerGas.html **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const maxPriorityFeePerGas = await client.estimateMaxPriorityFeePerGas() // 10000000n ``` |
| › `publicClient.extend` | \<client\>(`fn`: (`client`: `Client`\<`Transport`, `undefined` \| `Chain`, `undefined`, `PublicRpcSchema`, `PublicActions`\<`Transport`, `undefined` \| `Chain`\>\>) => `client`) => `Client`\<`Transport`, `undefined` \| `Chain`, `undefined`, `PublicRpcSchema`, \{ [K in string \| number \| symbol]: client[K] } & `PublicActions`\<`Transport`, `undefined` \| `Chain`\>\> | `undefined` | - |
| › `publicClient.getBalance` | (`args`: `GetBalanceParameters`) => `Promise`\<`bigint`\> | `undefined` | Returns the balance of an address in wei. - Docs: https://viem.sh/docs/actions/public/getBalance.html - JSON-RPC Methods: [`eth_getBalance`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getbalance) **`Remarks`** You can convert the balance to ether units with [`formatEther`](https://viem.sh/docs/utilities/formatEther.html). ```ts const balance = await getBalance(client, { address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', blockTag: 'safe' }) const balanceAsEther = formatEther(balance) // "6.942" ``` **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const balance = await client.getBalance({ address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', }) // 10000000000000000000000n (wei) ``` |
| › `publicClient.getBlock` | \<TIncludeTransactions, TBlockTag\>(`args?`: `GetBlockParameters`\<`TIncludeTransactions`, `TBlockTag`\>) => `Promise`\<`GetBlockReturnType`\<`undefined` \| `Chain`, `TIncludeTransactions`, `TBlockTag`\>\> | `undefined` | Returns information about a block at a block number, hash, or tag. - Docs: https://viem.sh/docs/actions/public/getBlock.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/fetching-blocks - JSON-RPC Methods: - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) for `blockNumber` & `blockTag`. - Calls [`eth_getBlockByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbyhash) for `blockHash`. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const block = await client.getBlock() ``` |
| › `publicClient.getBlockNumber` | (`args?`: `GetBlockNumberParameters`) => `Promise`\<`bigint`\> | `undefined` | Returns the number of the most recent block seen. - Docs: https://viem.sh/docs/actions/public/getBlockNumber.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/fetching-blocks - JSON-RPC Methods: [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const blockNumber = await client.getBlockNumber() // 69420n ``` |
| › `publicClient.getBlockTransactionCount` | (`args?`: `GetBlockTransactionCountParameters`) => `Promise`\<`number`\> | `undefined` | Returns the number of Transactions at a block number, hash, or tag. - Docs: https://viem.sh/docs/actions/public/getBlockTransactionCount.html - JSON-RPC Methods: - Calls [`eth_getBlockTransactionCountByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbynumber) for `blockNumber` & `blockTag`. - Calls [`eth_getBlockTransactionCountByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbyhash) for `blockHash`. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const count = await client.getBlockTransactionCount() ``` |
| › `publicClient.getBytecode` | (`args`: `GetBytecodeParameters`) => `Promise`\<`GetBytecodeReturnType`\> | `undefined` | Retrieves the bytecode at an address. - Docs: https://viem.sh/docs/contract/getBytecode.html - JSON-RPC Methods: [`eth_getCode`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getcode) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const code = await client.getBytecode({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', }) ``` |
| › `publicClient.getChainId` | () => `Promise`\<`number`\> | `undefined` | Returns the chain ID associated with the current network. - Docs: https://viem.sh/docs/actions/public/getChainId.html - JSON-RPC Methods: [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const chainId = await client.getChainId() // 1 ``` |
| › `publicClient.getContractEvents` | \<TAbi, TEventName, TStrict, TFromBlock, TToBlock\>(`args`: `GetContractEventsParameters`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetContractEventsReturnType`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | `undefined` | Returns a list of event logs emitted by a contract. - Docs: https://viem.sh/docs/actions/public/getContractEvents.html - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { wagmiAbi } from './abi' const client = createPublicClient({ chain: mainnet, transport: http(), }) const logs = await client.getContractEvents(client, { address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: wagmiAbi, eventName: 'Transfer' }) ``` |
| › `publicClient.getEnsAddress` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `coinType?`: `number` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsAddressReturnType`\> | `undefined` | Gets address for ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsAddress.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const ensAddress = await client.getEnsAddress({ name: normalize('wevm.eth'), }) // '0xd2135CfB216b74109775236E36d4b433F1DF507B' ``` |
| › `publicClient.getEnsAvatar` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `gatewayUrls?`: `AssetGatewayUrls` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsAvatarReturnType`\> | `undefined` | Gets the avatar of an ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsAvatar.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls [`getEnsText`](https://viem.sh/docs/ens/actions/getEnsText.html) with `key` set to `'avatar'`. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const ensAvatar = await client.getEnsAvatar({ name: normalize('wevm.eth'), }) // 'https://ipfs.io/ipfs/Qma8mnp6xV3J2cRNf3mTth5C8nV11CAnceVinc3y8jSbio' ``` |
| › `publicClient.getEnsName` | (`args`: \{ `address`: \`0x$\{string}\` ; `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsNameReturnType`\> | `undefined` | Gets primary name for specified address. - Docs: https://viem.sh/docs/ens/actions/getEnsName.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `reverse(bytes)` on ENS Universal Resolver Contract to "reverse resolve" the address to the primary ENS name. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const ensName = await client.getEnsName({ address: '0xd2135CfB216b74109775236E36d4b433F1DF507B', }) // 'wevm.eth' ``` |
| › `publicClient.getEnsResolver` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<\`0x$\{string}\`\> | `undefined` | Gets resolver for ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `findResolver(bytes)` on ENS Universal Resolver Contract to retrieve the resolver of an ENS name. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const resolverAddress = await client.getEnsResolver({ name: normalize('wevm.eth'), }) // '0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41' ``` |
| › `publicClient.getEnsText` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `key`: `string` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsTextReturnType`\> | `undefined` | Gets a text record for specified ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const twitterRecord = await client.getEnsText({ name: normalize('wevm.eth'), key: 'com.twitter', }) // 'wagmi_sh' ``` |
| › `publicClient.getFeeHistory` | (`args`: `GetFeeHistoryParameters`) => `Promise`\<`GetFeeHistoryReturnType`\> | `undefined` | Returns a collection of historical gas information. - Docs: https://viem.sh/docs/actions/public/getFeeHistory.html - JSON-RPC Methods: [`eth_feeHistory`](https://docs.alchemy.com/reference/eth-feehistory) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const feeHistory = await client.getFeeHistory({ blockCount: 4, rewardPercentiles: [25, 75], }) ``` |
| › `publicClient.getFilterChanges` | \<TFilterType, TAbi, TEventName, TStrict, TFromBlock, TToBlock\>(`args`: `GetFilterChangesParameters`\<`TFilterType`, `TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetFilterChangesReturnType`\<`TFilterType`, `TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | `undefined` | Returns a list of logs or hashes based on a [Filter](/docs/glossary/terms#filter) since the last time it was called. - Docs: https://viem.sh/docs/actions/public/getFilterChanges.html - JSON-RPC Methods: [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges) **`Remarks`** A Filter can be created from the following actions: - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter.html) - [`createContractEventFilter`](https://viem.sh/docs/contract/createContractEventFilter.html) - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter.html) - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter.html) Depending on the type of filter, the return value will be different: - If the filter was created with `createContractEventFilter` or `createEventFilter`, it returns a list of logs. - If the filter was created with `createPendingTransactionFilter`, it returns a list of transaction hashes. - If the filter was created with `createBlockFilter`, it returns a list of block hashes. **`Example`** ```ts // Blocks import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createBlockFilter() const hashes = await client.getFilterChanges({ filter }) ``` **`Example`** ```ts // Contract Events import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createContractEventFilter({ address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']), eventName: 'Transfer', }) const logs = await client.getFilterChanges({ filter }) ``` **`Example`** ```ts // Raw Events import { createPublicClient, http, parseAbiItem } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createEventFilter({ address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'), }) const logs = await client.getFilterChanges({ filter }) ``` **`Example`** ```ts // Transactions import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createPendingTransactionFilter() const hashes = await client.getFilterChanges({ filter }) ``` |
| › `publicClient.getFilterLogs` | \<TAbi, TEventName, TStrict, TFromBlock, TToBlock\>(`args`: `GetFilterLogsParameters`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetFilterLogsReturnType`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | `undefined` | Returns a list of event logs since the filter was created. - Docs: https://viem.sh/docs/actions/public/getFilterLogs.html - JSON-RPC Methods: [`eth_getFilterLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterlogs) **`Remarks`** `getFilterLogs` is only compatible with **event filters**. **`Example`** ```ts import { createPublicClient, http, parseAbiItem } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createEventFilter({ address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'), }) const logs = await client.getFilterLogs({ filter }) ``` |
| › `publicClient.getGasPrice` | () => `Promise`\<`bigint`\> | `undefined` | Returns the current price of gas (in wei). - Docs: https://viem.sh/docs/actions/public/getGasPrice.html - JSON-RPC Methods: [`eth_gasPrice`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gasprice) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const gasPrice = await client.getGasPrice() ``` |
| › `publicClient.getLogs` | \<TAbiEvent, TAbiEvents, TStrict, TFromBlock, TToBlock\>(`args?`: `GetLogsParameters`\<`TAbiEvent`, `TAbiEvents`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetLogsReturnType`\<`TAbiEvent`, `TAbiEvents`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | `undefined` | Returns a list of event logs matching the provided parameters. - Docs: https://viem.sh/docs/actions/public/getLogs.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/filters-and-logs/event-logs - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) **`Example`** ```ts import { createPublicClient, http, parseAbiItem } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const logs = await client.getLogs() ``` |
| › `publicClient.getProof` | (`args`: `GetProofParameters`) => `Promise`\<`GetProofReturnType`\> | `undefined` | Returns the account and storage values of the specified account including the Merkle-proof. - Docs: https://viem.sh/docs/actions/public/getProof.html - JSON-RPC Methods: - Calls [`eth_getProof`](https://eips.ethereum.org/EIPS/eip-1186) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const block = await client.getProof({ address: '0x...', storageKeys: ['0x...'], }) ``` |
| › `publicClient.getStorageAt` | (`args`: `GetStorageAtParameters`) => `Promise`\<`GetStorageAtReturnType`\> | `undefined` | Returns the value from a storage slot at a given address. - Docs: https://viem.sh/docs/contract/getStorageAt.html - JSON-RPC Methods: [`eth_getStorageAt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getstorageat) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { getStorageAt } from 'viem/contract' const client = createPublicClient({ chain: mainnet, transport: http(), }) const code = await client.getStorageAt({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', slot: toHex(0), }) ``` |
| › `publicClient.getTransaction` | \<TBlockTag\>(`args`: `GetTransactionParameters`\<`TBlockTag`\>) => `Promise`\<`GetTransactionReturnType`\<`undefined` \| `Chain`, `TBlockTag`\>\> | `undefined` | Returns information about a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) given a hash or block identifier. - Docs: https://viem.sh/docs/actions/public/getTransaction.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/fetching-transactions - JSON-RPC Methods: [`eth_getTransactionByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionByHash) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transaction = await client.getTransaction({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `publicClient.getTransactionConfirmations` | (`args`: `GetTransactionConfirmationsParameters`\<`undefined` \| `Chain`\>) => `Promise`\<`bigint`\> | `undefined` | Returns the number of blocks passed (confirmations) since the transaction was processed on a block. - Docs: https://viem.sh/docs/actions/public/getTransactionConfirmations.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/fetching-transactions - JSON-RPC Methods: [`eth_getTransactionConfirmations`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionConfirmations) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const confirmations = await client.getTransactionConfirmations({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `publicClient.getTransactionCount` | (`args`: `GetTransactionCountParameters`) => `Promise`\<`number`\> | `undefined` | Returns the number of [Transactions](https://viem.sh/docs/glossary/terms.html#transaction) an Account has broadcast / sent. - Docs: https://viem.sh/docs/actions/public/getTransactionCount.html - JSON-RPC Methods: [`eth_getTransactionCount`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactioncount) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transactionCount = await client.getTransactionCount({ address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', }) ``` |
| › `publicClient.getTransactionReceipt` | (`args`: `GetTransactionReceiptParameters`) => `Promise`\<`TransactionReceipt`\> | `undefined` | Returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt) given a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash. - Docs: https://viem.sh/docs/actions/public/getTransactionReceipt.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/fetching-transactions - JSON-RPC Methods: [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transactionReceipt = await client.getTransactionReceipt({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `publicClient.key` | `string` | `undefined` | A key for the client. |
| › `publicClient.multicall` | \<TContracts, TAllowFailure\>(`args`: `MulticallParameters`\<`TContracts`, `TAllowFailure`\>) => `Promise`\<`MulticallReturnType`\<`TContracts`, `TAllowFailure`\>\> | `undefined` | Similar to [`readContract`](https://viem.sh/docs/contract/readContract.html), but batches up multiple functions on a contract in a single RPC call via the [`multicall3` contract](https://github.com/mds1/multicall). - Docs: https://viem.sh/docs/contract/multicall.html **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const abi = parseAbi([ 'function balanceOf(address) view returns (uint256)', 'function totalSupply() view returns (uint256)', ]) const result = await client.multicall({ contracts: [ { address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi, functionName: 'balanceOf', args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'], }, { address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi, functionName: 'totalSupply', }, ], }) // [{ result: 424122n, status: 'success' }, { result: 1000000n, status: 'success' }] ``` |
| › `publicClient.name` | `string` | `undefined` | A name for the client. |
| › `publicClient.pollingInterval` | `number` | `undefined` | Frequency (in ms) for polling enabled actions & events. Defaults to 4_000 milliseconds. |
| › `publicClient.prepareTransactionRequest` | \<TChainOverride\>(`args`: `PrepareTransactionRequestParameters`\<`undefined` \| `Chain`, `undefined` \| `Account`, `TChainOverride`\>) => `Promise`\<`PrepareTransactionRequestReturnType`\> | `undefined` | Prepares a transaction request for signing. - Docs: https://viem.sh/docs/actions/wallet/prepareTransactionRequest.html **`Example`** ```ts import { createWalletClient, custom } from 'viem' import { mainnet } from 'viem/chains' const client = createWalletClient({ chain: mainnet, transport: custom(window.ethereum), }) const request = await client.prepareTransactionRequest({ account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', to: '0x0000000000000000000000000000000000000000', value: 1n, }) ``` **`Example`** ```ts // Account Hoisting import { createWalletClient, http } from 'viem' import { privateKeyToAccount } from 'viem/accounts' import { mainnet } from 'viem/chains' const client = createWalletClient({ account: privateKeyToAccount('0x…'), chain: mainnet, transport: custom(window.ethereum), }) const request = await client.prepareTransactionRequest({ to: '0x0000000000000000000000000000000000000000', value: 1n, }) ``` |
| › `publicClient.readContract` | \<TAbi, TFunctionName\>(`args`: `ReadContractParameters`\<`TAbi`, `TFunctionName`\>) => `Promise`\<`ReadContractReturnType`\<`TAbi`, `TFunctionName`\>\> | `undefined` | Calls a read-only function on a contract, and returns the response. - Docs: https://viem.sh/docs/contract/readContract.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts/reading-contracts **`Remarks`** A "read-only" function (constant function) on a Solidity contract is denoted by a `view` or `pure` keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas. Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html). **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' import { readContract } from 'viem/contract' const client = createPublicClient({ chain: mainnet, transport: http(), }) const result = await client.readContract({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['function balanceOf(address) view returns (uint256)']), functionName: 'balanceOf', args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'], }) // 424122n ``` |
| › `publicClient.request` | `EIP1193RequestFn`\<`PublicRpcSchema`\> | `undefined` | Request function wrapped with friendly error handling |
| › `publicClient.sendRawTransaction` | (`args`: `SendRawTransactionParameters`) => `Promise`\<\`0x$\{string}\`\> | `undefined` | Sends a **signed** transaction to the network - Docs: https://viem.sh/docs/actions/wallet/sendRawTransaction.html - JSON-RPC Method: [`eth_sendRawTransaction`](https://ethereum.github.io/execution-apis/api-documentation/) **`Example`** ```ts import { createWalletClient, custom } from 'viem' import { mainnet } from 'viem/chains' import { sendRawTransaction } from 'viem/wallet' const client = createWalletClient({ chain: mainnet, transport: custom(window.ethereum), }) const hash = await client.sendRawTransaction({ serializedTransaction: '0x02f850018203118080825208808080c080a04012522854168b27e5dc3d5839bab5e6b39e1a0ffd343901ce1622e3d64b48f1a04e00902ae0502c4728cbf12156290df99c3ed7de85b1dbfe20b5c36931733a33' }) ``` |
| › `publicClient.simulateContract` | \<TAbi, TFunctionName, TChainOverride\>(`args`: `SimulateContractParameters`\<`TAbi`, `TFunctionName`, `undefined` \| `Chain`, `TChainOverride`\>) => `Promise`\<`SimulateContractReturnType`\<`TAbi`, `TFunctionName`, `undefined` \| `Chain`, `TChainOverride`\>\> | `undefined` | Simulates/validates a contract interaction. This is useful for retrieving **return data** and **revert reasons** of contract write functions. - Docs: https://viem.sh/docs/contract/simulateContract.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts/writing-to-contracts **`Remarks`** This function does not require gas to execute and _**does not**_ change the state of the blockchain. It is almost identical to [`readContract`](https://viem.sh/docs/contract/readContract.html), but also supports contract write functions. Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html). **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const result = await client.simulateContract({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['function mint(uint32) view returns (uint32)']), functionName: 'mint', args: ['69420'], account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', }) ``` |
| › `publicClient.transport` | `TransportConfig`\<`string`, `EIP1193RequestFn`\> & `Record`\<`string`, `any`\> | `undefined` | The RPC transport |
| › `publicClient.type` | `string` | `undefined` | The type of client. |
| › `publicClient.uid` | `string` | `undefined` | A unique ID for the client. |
| › `publicClient.uninstallFilter` | (`args`: `UninstallFilterParameters`) => `Promise`\<`boolean`\> | `undefined` | Destroys a Filter that was created from one of the following Actions: - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter.html) - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter.html) - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter.html) - Docs: https://viem.sh/docs/actions/public/uninstallFilter.html - JSON-RPC Methods: [`eth_uninstallFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_uninstallFilter) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { createPendingTransactionFilter, uninstallFilter } from 'viem/public' const filter = await client.createPendingTransactionFilter() const uninstalled = await client.uninstallFilter({ filter }) // true ``` |
| › `publicClient.verifyMessage` | (`args`: `VerifyMessageParameters`) => `Promise`\<`boolean`\> | `undefined` | - |
| › `publicClient.verifyTypedData` | (`args`: `VerifyTypedDataParameters`) => `Promise`\<`boolean`\> | `undefined` | - |
| › `publicClient.waitForTransactionReceipt` | (`args`: `WaitForTransactionReceiptParameters`\<`undefined` \| `Chain`\>) => `Promise`\<`TransactionReceipt`\> | `undefined` | Waits for the [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms.html#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt). If the Transaction reverts, then the action will throw an error. - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/sending-transactions - JSON-RPC Methods: - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed. - If a Transaction has been replaced: - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions - Checks if one of the Transactions is a replacement - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt). **`Remarks`** The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions). Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce. There are 3 types of Transaction Replacement reasons: - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`) - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`) - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transactionReceipt = await client.waitForTransactionReceipt({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `publicClient.watchBlockNumber` | (`args`: `WatchBlockNumberParameters`) => `WatchBlockNumberReturnType` | `undefined` | Watches and returns incoming block numbers. - Docs: https://viem.sh/docs/actions/public/watchBlockNumber.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/watching-blocks - JSON-RPC Methods: - When `poll: true`, calls [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) on a polling interval. - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newHeads"` event. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = await client.watchBlockNumber({ onBlockNumber: (blockNumber) => console.log(blockNumber), }) ``` |
| › `publicClient.watchBlocks` | \<TIncludeTransactions, TBlockTag\>(`args`: `WatchBlocksParameters`\<`Transport`, `undefined` \| `Chain`, `TIncludeTransactions`, `TBlockTag`\>) => `WatchBlocksReturnType` | `undefined` | Watches and returns information for incoming blocks. - Docs: https://viem.sh/docs/actions/public/watchBlocks.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/watching-blocks - JSON-RPC Methods: - When `poll: true`, calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getBlockByNumber) on a polling interval. - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newHeads"` event. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = await client.watchBlocks({ onBlock: (block) => console.log(block), }) ``` |
| › `publicClient.watchContractEvent` | \<TAbi, TEventName, TStrict\>(`args`: `WatchContractEventParameters`\<`TAbi`, `TEventName`, `TStrict`\>) => `WatchContractEventReturnType` | `undefined` | Watches and returns emitted contract event logs. - Docs: https://viem.sh/docs/contract/watchContractEvent.html **`Remarks`** This Action will batch up all the event logs found within the [`pollingInterval`](https://viem.sh/docs/contract/watchContractEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/contract/watchContractEvent.html#onLogs). `watchContractEvent` will attempt to create an [Event Filter](https://viem.sh/docs/contract/createContractEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchContractEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs.html) instead. **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = client.watchContractEvent({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['event Transfer(address indexed from, address indexed to, uint256 value)']), eventName: 'Transfer', args: { from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b' }, onLogs: (logs) => console.log(logs), }) ``` |
| › `publicClient.watchEvent` | \<TAbiEvent, TAbiEvents, TStrict\>(`args`: `WatchEventParameters`\<`TAbiEvent`, `TAbiEvents`, `TStrict`\>) => `WatchEventReturnType` | `undefined` | Watches and returns emitted [Event Logs](https://viem.sh/docs/glossary/terms.html#event-log). - Docs: https://viem.sh/docs/actions/public/watchEvent.html - JSON-RPC Methods: - **RPC Provider supports `eth_newFilter`:** - Calls [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) to create a filter (called on initialize). - On a polling interval, it will call [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges). - **RPC Provider does not support `eth_newFilter`:** - Calls [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) for each block between the polling interval. **`Remarks`** This Action will batch up all the Event Logs found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/actions/public/watchEvent.html#onLogs). `watchEvent` will attempt to create an [Event Filter](https://viem.sh/docs/actions/public/createEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs.html) instead. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = client.watchEvent({ onLogs: (logs) => console.log(logs), }) ``` |
| › `publicClient.watchPendingTransactions` | (`args`: `WatchPendingTransactionsParameters`\<`Transport`\>) => `WatchPendingTransactionsReturnType` | `undefined` | Watches and returns pending transaction hashes. - Docs: https://viem.sh/docs/actions/public/watchPendingTransactions.html - JSON-RPC Methods: - When `poll: true` - Calls [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) to initialize the filter. - Calls [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getFilterChanges) on a polling interval. - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newPendingTransactions"` event. **`Remarks`** This Action will batch up all the pending transactions found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#pollinginterval-optional), and invoke them via [`onTransactions`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#ontransactions). **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = await client.watchPendingTransactions({ onTransactions: (hashes) => console.log(hashes), }) ``` |
| › `tokenBridgeCreatorAddressOverride?` | \`0x$\{string}\` | `undefined` | Specifies a custom address for the TokenBridgeCreator. By default, the address will be automatically detected based on the provided chain. |

#### Returns

`Promise`\<\{ `accessList?`: `undefined` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `bigint` ; `maxFeePerGas?`: `undefined` ; `maxPriorityFeePerGas?`: `undefined` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"legacy"`` ; `value?`: `bigint`  } \| \{ `accessList?`: `AccessList` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `bigint` ; `maxFeePerGas?`: `undefined` ; `maxPriorityFeePerGas?`: `undefined` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"eip2930"`` ; `value?`: `bigint`  } \| \{ `accessList?`: `AccessList` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `undefined` ; `maxFeePerGas?`: `bigint` ; `maxPriorityFeePerGas?`: `bigint` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"eip1559"`` ; `value?`: `bigint`  }\>

#### Defined in

[src/createTokenBridgePrepareCustomFeeTokenApprovalTransactionRequest.ts:19](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/createTokenBridgePrepareCustomFeeTokenApprovalTransactionRequest.ts#L19)

___

### createTokenBridgePrepareSetWethGatewayTransactionReceipt

**createTokenBridgePrepareSetWethGatewayTransactionReceipt**(`txReceipt`): `CreateTokenBridgeSetWethGatewayTransactionReceipt`

#### Parameters

| Name | Type |
| :------ | :------ |
| `txReceipt` | `TransactionReceipt` |

#### Returns

`CreateTokenBridgeSetWethGatewayTransactionReceipt`

#### Defined in

[src/createTokenBridgePrepareSetWethGatewayTransactionReceipt.ts:24](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/createTokenBridgePrepareSetWethGatewayTransactionReceipt.ts#L24)

___

### createTokenBridgePrepareSetWethGatewayTransactionRequest

**createTokenBridgePrepareSetWethGatewayTransactionRequest**(`«destructured»`): `Promise`\<\{ `accessList?`: `undefined` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `bigint` ; `maxFeePerGas?`: `undefined` ; `maxPriorityFeePerGas?`: `undefined` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"legacy"`` ; `value?`: `bigint`  } \| \{ `accessList?`: `AccessList` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `bigint` ; `maxFeePerGas?`: `undefined` ; `maxPriorityFeePerGas?`: `undefined` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"eip2930"`` ; `value?`: `bigint`  } \| \{ `accessList?`: `AccessList` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `undefined` ; `maxFeePerGas?`: `bigint` ; `maxPriorityFeePerGas?`: `bigint` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"eip1559"`` ; `value?`: `bigint`  }\>

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `«destructured»` | `Object` | - |
| › `account` | \`0x$\{string}\` | - |
| › `orbitChainPublicClient` | `Object` | - |
| › `orbitChainPublicClient.account` | `undefined` | The Account of the Client. |
| › `orbitChainPublicClient.batch?` | `Object` | Flags for batch settings. |
| › `orbitChainPublicClient.batch.multicall?` | `boolean` \| \{ `batchSize?`: `number` ; `wait?`: `number`  } | Toggle to enable `eth_call` multicall aggregation. |
| › `orbitChainPublicClient.cacheTime` | `number` | Time (in ms) that cached data will remain in memory. |
| › `orbitChainPublicClient.call` | (`parameters`: `CallParameters`\<`undefined` \| `Chain`\>) => `Promise`\<`CallReturnType`\> | Executes a new message call immediately without submitting a transaction to the network. - Docs: https://viem.sh/docs/actions/public/call.html - JSON-RPC Methods: [`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const data = await client.call({ account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', }) ``` |
| › `orbitChainPublicClient.chain` | `undefined` \| `Chain` | Chain for the client. |
| › `orbitChainPublicClient.createBlockFilter` | () => `Promise`\<\{ `id`: \`0x$\{string}\` ; `request`: `EIP1193RequestFn`\<readonly [\{ `Method`: ``"eth_getFilterChanges"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: \`0x$\{(...)}\`[] \| `RpcLog`[]  }, \{ `Method`: ``"eth_getFilterLogs"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `RpcLog`[]  }, \{ `Method`: ``"eth_uninstallFilter"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `boolean`  }]\> ; `type`: ``"block"``  }\> | Creates a Filter to listen for new block hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html). - Docs: https://viem.sh/docs/actions/public/createBlockFilter.html - JSON-RPC Methods: [`eth_newBlockFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newBlockFilter) **`Example`** ```ts import { createPublicClient, createBlockFilter, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await createBlockFilter(client) // { id: "0x345a6572337856574a76364e457a4366", type: 'block' } ``` |
| › `orbitChainPublicClient.createContractEventFilter` | \<TAbi, TEventName, TArgs, TStrict, TFromBlock, TToBlock\>(`args`: `CreateContractEventFilterParameters`\<`TAbi`, `TEventName`, `TArgs`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`CreateContractEventFilterReturnType`\<`TAbi`, `TEventName`, `TArgs`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Creates a Filter to retrieve event logs that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html) or [`getFilterLogs`](https://viem.sh/docs/actions/public/getFilterLogs.html). - Docs: https://viem.sh/docs/contract/createContractEventFilter.html **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createContractEventFilter({ abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']), }) ``` |
| › `orbitChainPublicClient.createEventFilter` | \<TAbiEvent, TAbiEvents, TStrict, TFromBlock, TToBlock, _EventName, _Args\>(`args?`: `CreateEventFilterParameters`\<`TAbiEvent`, `TAbiEvents`, `TStrict`, `TFromBlock`, `TToBlock`, `_EventName`, `_Args`\>) => `Promise`\<\{ [K in string \| number \| symbol]: Filter\<"event", TAbiEvents, \_EventName, \_Args, TStrict, TFromBlock, TToBlock\>[K] }\> | Creates a [`Filter`](https://viem.sh/docs/glossary/types.html#filter) to listen for new events that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html). - Docs: https://viem.sh/docs/actions/public/createEventFilter.html - JSON-RPC Methods: [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createEventFilter({ address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2', }) ``` |
| › `orbitChainPublicClient.createPendingTransactionFilter` | () => `Promise`\<\{ `id`: \`0x$\{string}\` ; `request`: `EIP1193RequestFn`\<readonly [\{ `Method`: ``"eth_getFilterChanges"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: \`0x$\{(...)}\`[] \| `RpcLog`[]  }, \{ `Method`: ``"eth_getFilterLogs"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `RpcLog`[]  }, \{ `Method`: ``"eth_uninstallFilter"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `boolean`  }]\> ; `type`: ``"transaction"``  }\> | Creates a Filter to listen for new pending transaction hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html). - Docs: https://viem.sh/docs/actions/public/createPendingTransactionFilter.html - JSON-RPC Methods: [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createPendingTransactionFilter() // { id: "0x345a6572337856574a76364e457a4366", type: 'transaction' } ``` |
| › `orbitChainPublicClient.estimateContractGas` | \<TChain, TAbi, TFunctionName\>(`args`: `EstimateContractGasParameters`\<`TAbi`, `TFunctionName`, `TChain`, `undefined` \| `Account`\>) => `Promise`\<`bigint`\> | Estimates the gas required to successfully execute a contract write function call. - Docs: https://viem.sh/docs/contract/estimateContractGas.html **`Remarks`** Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`estimateGas` action](https://viem.sh/docs/actions/public/estimateGas.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html). **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const gas = await client.estimateContractGas({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['function mint() public']), functionName: 'mint', account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', }) ``` |
| › `orbitChainPublicClient.estimateFeesPerGas` | \<TChainOverride, TType\>(`args?`: `EstimateFeesPerGasParameters`\<`undefined` \| `Chain`, `TChainOverride`, `TType`\>) => `Promise`\<`EstimateFeesPerGasReturnType`\> | Returns an estimate for the fees per gas for a transaction to be included in the next block. - Docs: https://viem.sh/docs/actions/public/estimateFeesPerGas.html **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const maxPriorityFeePerGas = await client.estimateFeesPerGas() // { maxFeePerGas: ..., maxPriorityFeePerGas: ... } ``` |
| › `orbitChainPublicClient.estimateGas` | (`args`: `EstimateGasParameters`\<`undefined` \| `Chain`, `undefined` \| `Account`\>) => `Promise`\<`bigint`\> | Estimates the gas necessary to complete a transaction without submitting it to the network. - Docs: https://viem.sh/docs/actions/public/estimateGas.html - JSON-RPC Methods: [`eth_estimateGas`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas) **`Example`** ```ts import { createPublicClient, http, parseEther } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const gasEstimate = await client.estimateGas({ account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', value: parseEther('1'), }) ``` |
| › `orbitChainPublicClient.estimateMaxPriorityFeePerGas` | \<TChainOverride\>(`args?`: \{ `chain`: ``null`` \| `TChainOverride`  }) => `Promise`\<`bigint`\> | Returns an estimate for the max priority fee per gas (in wei) for a transaction to be included in the next block. - Docs: https://viem.sh/docs/actions/public/estimateMaxPriorityFeePerGas.html **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const maxPriorityFeePerGas = await client.estimateMaxPriorityFeePerGas() // 10000000n ``` |
| › `orbitChainPublicClient.extend` | \<client\>(`fn`: (`client`: `Client`\<`Transport`, `undefined` \| `Chain`, `undefined`, `PublicRpcSchema`, `PublicActions`\<`Transport`, `undefined` \| `Chain`\>\>) => `client`) => `Client`\<`Transport`, `undefined` \| `Chain`, `undefined`, `PublicRpcSchema`, \{ [K in string \| number \| symbol]: client[K] } & `PublicActions`\<`Transport`, `undefined` \| `Chain`\>\> | - |
| › `orbitChainPublicClient.getBalance` | (`args`: `GetBalanceParameters`) => `Promise`\<`bigint`\> | Returns the balance of an address in wei. - Docs: https://viem.sh/docs/actions/public/getBalance.html - JSON-RPC Methods: [`eth_getBalance`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getbalance) **`Remarks`** You can convert the balance to ether units with [`formatEther`](https://viem.sh/docs/utilities/formatEther.html). ```ts const balance = await getBalance(client, { address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', blockTag: 'safe' }) const balanceAsEther = formatEther(balance) // "6.942" ``` **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const balance = await client.getBalance({ address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', }) // 10000000000000000000000n (wei) ``` |
| › `orbitChainPublicClient.getBlock` | \<TIncludeTransactions, TBlockTag\>(`args?`: `GetBlockParameters`\<`TIncludeTransactions`, `TBlockTag`\>) => `Promise`\<`GetBlockReturnType`\<`undefined` \| `Chain`, `TIncludeTransactions`, `TBlockTag`\>\> | Returns information about a block at a block number, hash, or tag. - Docs: https://viem.sh/docs/actions/public/getBlock.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/fetching-blocks - JSON-RPC Methods: - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) for `blockNumber` & `blockTag`. - Calls [`eth_getBlockByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbyhash) for `blockHash`. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const block = await client.getBlock() ``` |
| › `orbitChainPublicClient.getBlockNumber` | (`args?`: `GetBlockNumberParameters`) => `Promise`\<`bigint`\> | Returns the number of the most recent block seen. - Docs: https://viem.sh/docs/actions/public/getBlockNumber.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/fetching-blocks - JSON-RPC Methods: [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const blockNumber = await client.getBlockNumber() // 69420n ``` |
| › `orbitChainPublicClient.getBlockTransactionCount` | (`args?`: `GetBlockTransactionCountParameters`) => `Promise`\<`number`\> | Returns the number of Transactions at a block number, hash, or tag. - Docs: https://viem.sh/docs/actions/public/getBlockTransactionCount.html - JSON-RPC Methods: - Calls [`eth_getBlockTransactionCountByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbynumber) for `blockNumber` & `blockTag`. - Calls [`eth_getBlockTransactionCountByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbyhash) for `blockHash`. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const count = await client.getBlockTransactionCount() ``` |
| › `orbitChainPublicClient.getBytecode` | (`args`: `GetBytecodeParameters`) => `Promise`\<`GetBytecodeReturnType`\> | Retrieves the bytecode at an address. - Docs: https://viem.sh/docs/contract/getBytecode.html - JSON-RPC Methods: [`eth_getCode`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getcode) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const code = await client.getBytecode({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', }) ``` |
| › `orbitChainPublicClient.getChainId` | () => `Promise`\<`number`\> | Returns the chain ID associated with the current network. - Docs: https://viem.sh/docs/actions/public/getChainId.html - JSON-RPC Methods: [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const chainId = await client.getChainId() // 1 ``` |
| › `orbitChainPublicClient.getContractEvents` | \<TAbi, TEventName, TStrict, TFromBlock, TToBlock\>(`args`: `GetContractEventsParameters`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetContractEventsReturnType`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of event logs emitted by a contract. - Docs: https://viem.sh/docs/actions/public/getContractEvents.html - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { wagmiAbi } from './abi' const client = createPublicClient({ chain: mainnet, transport: http(), }) const logs = await client.getContractEvents(client, { address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: wagmiAbi, eventName: 'Transfer' }) ``` |
| › `orbitChainPublicClient.getEnsAddress` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `coinType?`: `number` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsAddressReturnType`\> | Gets address for ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsAddress.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const ensAddress = await client.getEnsAddress({ name: normalize('wevm.eth'), }) // '0xd2135CfB216b74109775236E36d4b433F1DF507B' ``` |
| › `orbitChainPublicClient.getEnsAvatar` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `gatewayUrls?`: `AssetGatewayUrls` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsAvatarReturnType`\> | Gets the avatar of an ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsAvatar.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls [`getEnsText`](https://viem.sh/docs/ens/actions/getEnsText.html) with `key` set to `'avatar'`. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const ensAvatar = await client.getEnsAvatar({ name: normalize('wevm.eth'), }) // 'https://ipfs.io/ipfs/Qma8mnp6xV3J2cRNf3mTth5C8nV11CAnceVinc3y8jSbio' ``` |
| › `orbitChainPublicClient.getEnsName` | (`args`: \{ `address`: \`0x$\{string}\` ; `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsNameReturnType`\> | Gets primary name for specified address. - Docs: https://viem.sh/docs/ens/actions/getEnsName.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `reverse(bytes)` on ENS Universal Resolver Contract to "reverse resolve" the address to the primary ENS name. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const ensName = await client.getEnsName({ address: '0xd2135CfB216b74109775236E36d4b433F1DF507B', }) // 'wevm.eth' ``` |
| › `orbitChainPublicClient.getEnsResolver` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<\`0x$\{string}\`\> | Gets resolver for ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `findResolver(bytes)` on ENS Universal Resolver Contract to retrieve the resolver of an ENS name. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const resolverAddress = await client.getEnsResolver({ name: normalize('wevm.eth'), }) // '0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41' ``` |
| › `orbitChainPublicClient.getEnsText` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `key`: `string` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsTextReturnType`\> | Gets a text record for specified ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const twitterRecord = await client.getEnsText({ name: normalize('wevm.eth'), key: 'com.twitter', }) // 'wagmi_sh' ``` |
| › `orbitChainPublicClient.getFeeHistory` | (`args`: `GetFeeHistoryParameters`) => `Promise`\<`GetFeeHistoryReturnType`\> | Returns a collection of historical gas information. - Docs: https://viem.sh/docs/actions/public/getFeeHistory.html - JSON-RPC Methods: [`eth_feeHistory`](https://docs.alchemy.com/reference/eth-feehistory) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const feeHistory = await client.getFeeHistory({ blockCount: 4, rewardPercentiles: [25, 75], }) ``` |
| › `orbitChainPublicClient.getFilterChanges` | \<TFilterType, TAbi, TEventName, TStrict, TFromBlock, TToBlock\>(`args`: `GetFilterChangesParameters`\<`TFilterType`, `TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetFilterChangesReturnType`\<`TFilterType`, `TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of logs or hashes based on a [Filter](/docs/glossary/terms#filter) since the last time it was called. - Docs: https://viem.sh/docs/actions/public/getFilterChanges.html - JSON-RPC Methods: [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges) **`Remarks`** A Filter can be created from the following actions: - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter.html) - [`createContractEventFilter`](https://viem.sh/docs/contract/createContractEventFilter.html) - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter.html) - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter.html) Depending on the type of filter, the return value will be different: - If the filter was created with `createContractEventFilter` or `createEventFilter`, it returns a list of logs. - If the filter was created with `createPendingTransactionFilter`, it returns a list of transaction hashes. - If the filter was created with `createBlockFilter`, it returns a list of block hashes. **`Example`** ```ts // Blocks import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createBlockFilter() const hashes = await client.getFilterChanges({ filter }) ``` **`Example`** ```ts // Contract Events import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createContractEventFilter({ address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']), eventName: 'Transfer', }) const logs = await client.getFilterChanges({ filter }) ``` **`Example`** ```ts // Raw Events import { createPublicClient, http, parseAbiItem } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createEventFilter({ address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'), }) const logs = await client.getFilterChanges({ filter }) ``` **`Example`** ```ts // Transactions import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createPendingTransactionFilter() const hashes = await client.getFilterChanges({ filter }) ``` |
| › `orbitChainPublicClient.getFilterLogs` | \<TAbi, TEventName, TStrict, TFromBlock, TToBlock\>(`args`: `GetFilterLogsParameters`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetFilterLogsReturnType`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of event logs since the filter was created. - Docs: https://viem.sh/docs/actions/public/getFilterLogs.html - JSON-RPC Methods: [`eth_getFilterLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterlogs) **`Remarks`** `getFilterLogs` is only compatible with **event filters**. **`Example`** ```ts import { createPublicClient, http, parseAbiItem } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createEventFilter({ address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'), }) const logs = await client.getFilterLogs({ filter }) ``` |
| › `orbitChainPublicClient.getGasPrice` | () => `Promise`\<`bigint`\> | Returns the current price of gas (in wei). - Docs: https://viem.sh/docs/actions/public/getGasPrice.html - JSON-RPC Methods: [`eth_gasPrice`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gasprice) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const gasPrice = await client.getGasPrice() ``` |
| › `orbitChainPublicClient.getLogs` | \<TAbiEvent, TAbiEvents, TStrict, TFromBlock, TToBlock\>(`args?`: `GetLogsParameters`\<`TAbiEvent`, `TAbiEvents`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetLogsReturnType`\<`TAbiEvent`, `TAbiEvents`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of event logs matching the provided parameters. - Docs: https://viem.sh/docs/actions/public/getLogs.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/filters-and-logs/event-logs - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) **`Example`** ```ts import { createPublicClient, http, parseAbiItem } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const logs = await client.getLogs() ``` |
| › `orbitChainPublicClient.getProof` | (`args`: `GetProofParameters`) => `Promise`\<`GetProofReturnType`\> | Returns the account and storage values of the specified account including the Merkle-proof. - Docs: https://viem.sh/docs/actions/public/getProof.html - JSON-RPC Methods: - Calls [`eth_getProof`](https://eips.ethereum.org/EIPS/eip-1186) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const block = await client.getProof({ address: '0x...', storageKeys: ['0x...'], }) ``` |
| › `orbitChainPublicClient.getStorageAt` | (`args`: `GetStorageAtParameters`) => `Promise`\<`GetStorageAtReturnType`\> | Returns the value from a storage slot at a given address. - Docs: https://viem.sh/docs/contract/getStorageAt.html - JSON-RPC Methods: [`eth_getStorageAt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getstorageat) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { getStorageAt } from 'viem/contract' const client = createPublicClient({ chain: mainnet, transport: http(), }) const code = await client.getStorageAt({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', slot: toHex(0), }) ``` |
| › `orbitChainPublicClient.getTransaction` | \<TBlockTag\>(`args`: `GetTransactionParameters`\<`TBlockTag`\>) => `Promise`\<`GetTransactionReturnType`\<`undefined` \| `Chain`, `TBlockTag`\>\> | Returns information about a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) given a hash or block identifier. - Docs: https://viem.sh/docs/actions/public/getTransaction.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/fetching-transactions - JSON-RPC Methods: [`eth_getTransactionByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionByHash) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transaction = await client.getTransaction({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `orbitChainPublicClient.getTransactionConfirmations` | (`args`: `GetTransactionConfirmationsParameters`\<`undefined` \| `Chain`\>) => `Promise`\<`bigint`\> | Returns the number of blocks passed (confirmations) since the transaction was processed on a block. - Docs: https://viem.sh/docs/actions/public/getTransactionConfirmations.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/fetching-transactions - JSON-RPC Methods: [`eth_getTransactionConfirmations`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionConfirmations) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const confirmations = await client.getTransactionConfirmations({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `orbitChainPublicClient.getTransactionCount` | (`args`: `GetTransactionCountParameters`) => `Promise`\<`number`\> | Returns the number of [Transactions](https://viem.sh/docs/glossary/terms.html#transaction) an Account has broadcast / sent. - Docs: https://viem.sh/docs/actions/public/getTransactionCount.html - JSON-RPC Methods: [`eth_getTransactionCount`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactioncount) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transactionCount = await client.getTransactionCount({ address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', }) ``` |
| › `orbitChainPublicClient.getTransactionReceipt` | (`args`: `GetTransactionReceiptParameters`) => `Promise`\<`TransactionReceipt`\> | Returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt) given a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash. - Docs: https://viem.sh/docs/actions/public/getTransactionReceipt.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/fetching-transactions - JSON-RPC Methods: [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transactionReceipt = await client.getTransactionReceipt({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `orbitChainPublicClient.key` | `string` | A key for the client. |
| › `orbitChainPublicClient.multicall` | \<TContracts, TAllowFailure\>(`args`: `MulticallParameters`\<`TContracts`, `TAllowFailure`\>) => `Promise`\<`MulticallReturnType`\<`TContracts`, `TAllowFailure`\>\> | Similar to [`readContract`](https://viem.sh/docs/contract/readContract.html), but batches up multiple functions on a contract in a single RPC call via the [`multicall3` contract](https://github.com/mds1/multicall). - Docs: https://viem.sh/docs/contract/multicall.html **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const abi = parseAbi([ 'function balanceOf(address) view returns (uint256)', 'function totalSupply() view returns (uint256)', ]) const result = await client.multicall({ contracts: [ { address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi, functionName: 'balanceOf', args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'], }, { address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi, functionName: 'totalSupply', }, ], }) // [{ result: 424122n, status: 'success' }, { result: 1000000n, status: 'success' }] ``` |
| › `orbitChainPublicClient.name` | `string` | A name for the client. |
| › `orbitChainPublicClient.pollingInterval` | `number` | Frequency (in ms) for polling enabled actions & events. Defaults to 4_000 milliseconds. |
| › `orbitChainPublicClient.prepareTransactionRequest` | \<TChainOverride\>(`args`: `PrepareTransactionRequestParameters`\<`undefined` \| `Chain`, `undefined` \| `Account`, `TChainOverride`\>) => `Promise`\<`PrepareTransactionRequestReturnType`\> | Prepares a transaction request for signing. - Docs: https://viem.sh/docs/actions/wallet/prepareTransactionRequest.html **`Example`** ```ts import { createWalletClient, custom } from 'viem' import { mainnet } from 'viem/chains' const client = createWalletClient({ chain: mainnet, transport: custom(window.ethereum), }) const request = await client.prepareTransactionRequest({ account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', to: '0x0000000000000000000000000000000000000000', value: 1n, }) ``` **`Example`** ```ts // Account Hoisting import { createWalletClient, http } from 'viem' import { privateKeyToAccount } from 'viem/accounts' import { mainnet } from 'viem/chains' const client = createWalletClient({ account: privateKeyToAccount('0x…'), chain: mainnet, transport: custom(window.ethereum), }) const request = await client.prepareTransactionRequest({ to: '0x0000000000000000000000000000000000000000', value: 1n, }) ``` |
| › `orbitChainPublicClient.readContract` | \<TAbi, TFunctionName\>(`args`: `ReadContractParameters`\<`TAbi`, `TFunctionName`\>) => `Promise`\<`ReadContractReturnType`\<`TAbi`, `TFunctionName`\>\> | Calls a read-only function on a contract, and returns the response. - Docs: https://viem.sh/docs/contract/readContract.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts/reading-contracts **`Remarks`** A "read-only" function (constant function) on a Solidity contract is denoted by a `view` or `pure` keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas. Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html). **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' import { readContract } from 'viem/contract' const client = createPublicClient({ chain: mainnet, transport: http(), }) const result = await client.readContract({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['function balanceOf(address) view returns (uint256)']), functionName: 'balanceOf', args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'], }) // 424122n ``` |
| › `orbitChainPublicClient.request` | `EIP1193RequestFn`\<`PublicRpcSchema`\> | Request function wrapped with friendly error handling |
| › `orbitChainPublicClient.sendRawTransaction` | (`args`: `SendRawTransactionParameters`) => `Promise`\<\`0x$\{string}\`\> | Sends a **signed** transaction to the network - Docs: https://viem.sh/docs/actions/wallet/sendRawTransaction.html - JSON-RPC Method: [`eth_sendRawTransaction`](https://ethereum.github.io/execution-apis/api-documentation/) **`Example`** ```ts import { createWalletClient, custom } from 'viem' import { mainnet } from 'viem/chains' import { sendRawTransaction } from 'viem/wallet' const client = createWalletClient({ chain: mainnet, transport: custom(window.ethereum), }) const hash = await client.sendRawTransaction({ serializedTransaction: '0x02f850018203118080825208808080c080a04012522854168b27e5dc3d5839bab5e6b39e1a0ffd343901ce1622e3d64b48f1a04e00902ae0502c4728cbf12156290df99c3ed7de85b1dbfe20b5c36931733a33' }) ``` |
| › `orbitChainPublicClient.simulateContract` | \<TAbi, TFunctionName, TChainOverride\>(`args`: `SimulateContractParameters`\<`TAbi`, `TFunctionName`, `undefined` \| `Chain`, `TChainOverride`\>) => `Promise`\<`SimulateContractReturnType`\<`TAbi`, `TFunctionName`, `undefined` \| `Chain`, `TChainOverride`\>\> | Simulates/validates a contract interaction. This is useful for retrieving **return data** and **revert reasons** of contract write functions. - Docs: https://viem.sh/docs/contract/simulateContract.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts/writing-to-contracts **`Remarks`** This function does not require gas to execute and _**does not**_ change the state of the blockchain. It is almost identical to [`readContract`](https://viem.sh/docs/contract/readContract.html), but also supports contract write functions. Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html). **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const result = await client.simulateContract({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['function mint(uint32) view returns (uint32)']), functionName: 'mint', args: ['69420'], account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', }) ``` |
| › `orbitChainPublicClient.transport` | `TransportConfig`\<`string`, `EIP1193RequestFn`\> & `Record`\<`string`, `any`\> | The RPC transport |
| › `orbitChainPublicClient.type` | `string` | The type of client. |
| › `orbitChainPublicClient.uid` | `string` | A unique ID for the client. |
| › `orbitChainPublicClient.uninstallFilter` | (`args`: `UninstallFilterParameters`) => `Promise`\<`boolean`\> | Destroys a Filter that was created from one of the following Actions: - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter.html) - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter.html) - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter.html) - Docs: https://viem.sh/docs/actions/public/uninstallFilter.html - JSON-RPC Methods: [`eth_uninstallFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_uninstallFilter) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { createPendingTransactionFilter, uninstallFilter } from 'viem/public' const filter = await client.createPendingTransactionFilter() const uninstalled = await client.uninstallFilter({ filter }) // true ``` |
| › `orbitChainPublicClient.verifyMessage` | (`args`: `VerifyMessageParameters`) => `Promise`\<`boolean`\> | - |
| › `orbitChainPublicClient.verifyTypedData` | (`args`: `VerifyTypedDataParameters`) => `Promise`\<`boolean`\> | - |
| › `orbitChainPublicClient.waitForTransactionReceipt` | (`args`: `WaitForTransactionReceiptParameters`\<`undefined` \| `Chain`\>) => `Promise`\<`TransactionReceipt`\> | Waits for the [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms.html#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt). If the Transaction reverts, then the action will throw an error. - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/sending-transactions - JSON-RPC Methods: - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed. - If a Transaction has been replaced: - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions - Checks if one of the Transactions is a replacement - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt). **`Remarks`** The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions). Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce. There are 3 types of Transaction Replacement reasons: - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`) - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`) - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transactionReceipt = await client.waitForTransactionReceipt({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `orbitChainPublicClient.watchBlockNumber` | (`args`: `WatchBlockNumberParameters`) => `WatchBlockNumberReturnType` | Watches and returns incoming block numbers. - Docs: https://viem.sh/docs/actions/public/watchBlockNumber.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/watching-blocks - JSON-RPC Methods: - When `poll: true`, calls [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) on a polling interval. - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newHeads"` event. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = await client.watchBlockNumber({ onBlockNumber: (blockNumber) => console.log(blockNumber), }) ``` |
| › `orbitChainPublicClient.watchBlocks` | \<TIncludeTransactions, TBlockTag\>(`args`: `WatchBlocksParameters`\<`Transport`, `undefined` \| `Chain`, `TIncludeTransactions`, `TBlockTag`\>) => `WatchBlocksReturnType` | Watches and returns information for incoming blocks. - Docs: https://viem.sh/docs/actions/public/watchBlocks.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/watching-blocks - JSON-RPC Methods: - When `poll: true`, calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getBlockByNumber) on a polling interval. - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newHeads"` event. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = await client.watchBlocks({ onBlock: (block) => console.log(block), }) ``` |
| › `orbitChainPublicClient.watchContractEvent` | \<TAbi, TEventName, TStrict\>(`args`: `WatchContractEventParameters`\<`TAbi`, `TEventName`, `TStrict`\>) => `WatchContractEventReturnType` | Watches and returns emitted contract event logs. - Docs: https://viem.sh/docs/contract/watchContractEvent.html **`Remarks`** This Action will batch up all the event logs found within the [`pollingInterval`](https://viem.sh/docs/contract/watchContractEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/contract/watchContractEvent.html#onLogs). `watchContractEvent` will attempt to create an [Event Filter](https://viem.sh/docs/contract/createContractEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchContractEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs.html) instead. **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = client.watchContractEvent({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['event Transfer(address indexed from, address indexed to, uint256 value)']), eventName: 'Transfer', args: { from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b' }, onLogs: (logs) => console.log(logs), }) ``` |
| › `orbitChainPublicClient.watchEvent` | \<TAbiEvent, TAbiEvents, TStrict\>(`args`: `WatchEventParameters`\<`TAbiEvent`, `TAbiEvents`, `TStrict`\>) => `WatchEventReturnType` | Watches and returns emitted [Event Logs](https://viem.sh/docs/glossary/terms.html#event-log). - Docs: https://viem.sh/docs/actions/public/watchEvent.html - JSON-RPC Methods: - **RPC Provider supports `eth_newFilter`:** - Calls [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) to create a filter (called on initialize). - On a polling interval, it will call [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges). - **RPC Provider does not support `eth_newFilter`:** - Calls [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) for each block between the polling interval. **`Remarks`** This Action will batch up all the Event Logs found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/actions/public/watchEvent.html#onLogs). `watchEvent` will attempt to create an [Event Filter](https://viem.sh/docs/actions/public/createEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs.html) instead. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = client.watchEvent({ onLogs: (logs) => console.log(logs), }) ``` |
| › `orbitChainPublicClient.watchPendingTransactions` | (`args`: `WatchPendingTransactionsParameters`\<`Transport`\>) => `WatchPendingTransactionsReturnType` | Watches and returns pending transaction hashes. - Docs: https://viem.sh/docs/actions/public/watchPendingTransactions.html - JSON-RPC Methods: - When `poll: true` - Calls [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) to initialize the filter. - Calls [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getFilterChanges) on a polling interval. - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newPendingTransactions"` event. **`Remarks`** This Action will batch up all the pending transactions found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#pollinginterval-optional), and invoke them via [`onTransactions`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#ontransactions). **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = await client.watchPendingTransactions({ onTransactions: (hashes) => console.log(hashes), }) ``` |
| › `parentChainPublicClient` | `Object` | - |
| › `parentChainPublicClient.account` | `undefined` | The Account of the Client. |
| › `parentChainPublicClient.batch?` | `Object` | Flags for batch settings. |
| › `parentChainPublicClient.batch.multicall?` | `boolean` \| \{ `batchSize?`: `number` ; `wait?`: `number`  } | Toggle to enable `eth_call` multicall aggregation. |
| › `parentChainPublicClient.cacheTime` | `number` | Time (in ms) that cached data will remain in memory. |
| › `parentChainPublicClient.call` | (`parameters`: `CallParameters`\<`undefined` \| `Chain`\>) => `Promise`\<`CallReturnType`\> | Executes a new message call immediately without submitting a transaction to the network. - Docs: https://viem.sh/docs/actions/public/call.html - JSON-RPC Methods: [`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const data = await client.call({ account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', }) ``` |
| › `parentChainPublicClient.chain` | `undefined` \| `Chain` | Chain for the client. |
| › `parentChainPublicClient.createBlockFilter` | () => `Promise`\<\{ `id`: \`0x$\{string}\` ; `request`: `EIP1193RequestFn`\<readonly [\{ `Method`: ``"eth_getFilterChanges"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: \`0x$\{(...)}\`[] \| `RpcLog`[]  }, \{ `Method`: ``"eth_getFilterLogs"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `RpcLog`[]  }, \{ `Method`: ``"eth_uninstallFilter"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `boolean`  }]\> ; `type`: ``"block"``  }\> | Creates a Filter to listen for new block hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html). - Docs: https://viem.sh/docs/actions/public/createBlockFilter.html - JSON-RPC Methods: [`eth_newBlockFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newBlockFilter) **`Example`** ```ts import { createPublicClient, createBlockFilter, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await createBlockFilter(client) // { id: "0x345a6572337856574a76364e457a4366", type: 'block' } ``` |
| › `parentChainPublicClient.createContractEventFilter` | \<TAbi, TEventName, TArgs, TStrict, TFromBlock, TToBlock\>(`args`: `CreateContractEventFilterParameters`\<`TAbi`, `TEventName`, `TArgs`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`CreateContractEventFilterReturnType`\<`TAbi`, `TEventName`, `TArgs`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Creates a Filter to retrieve event logs that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html) or [`getFilterLogs`](https://viem.sh/docs/actions/public/getFilterLogs.html). - Docs: https://viem.sh/docs/contract/createContractEventFilter.html **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createContractEventFilter({ abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']), }) ``` |
| › `parentChainPublicClient.createEventFilter` | \<TAbiEvent, TAbiEvents, TStrict, TFromBlock, TToBlock, _EventName, _Args\>(`args?`: `CreateEventFilterParameters`\<`TAbiEvent`, `TAbiEvents`, `TStrict`, `TFromBlock`, `TToBlock`, `_EventName`, `_Args`\>) => `Promise`\<\{ [K in string \| number \| symbol]: Filter\<"event", TAbiEvents, \_EventName, \_Args, TStrict, TFromBlock, TToBlock\>[K] }\> | Creates a [`Filter`](https://viem.sh/docs/glossary/types.html#filter) to listen for new events that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html). - Docs: https://viem.sh/docs/actions/public/createEventFilter.html - JSON-RPC Methods: [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createEventFilter({ address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2', }) ``` |
| › `parentChainPublicClient.createPendingTransactionFilter` | () => `Promise`\<\{ `id`: \`0x$\{string}\` ; `request`: `EIP1193RequestFn`\<readonly [\{ `Method`: ``"eth_getFilterChanges"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: \`0x$\{(...)}\`[] \| `RpcLog`[]  }, \{ `Method`: ``"eth_getFilterLogs"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `RpcLog`[]  }, \{ `Method`: ``"eth_uninstallFilter"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `boolean`  }]\> ; `type`: ``"transaction"``  }\> | Creates a Filter to listen for new pending transaction hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html). - Docs: https://viem.sh/docs/actions/public/createPendingTransactionFilter.html - JSON-RPC Methods: [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createPendingTransactionFilter() // { id: "0x345a6572337856574a76364e457a4366", type: 'transaction' } ``` |
| › `parentChainPublicClient.estimateContractGas` | \<TChain, TAbi, TFunctionName\>(`args`: `EstimateContractGasParameters`\<`TAbi`, `TFunctionName`, `TChain`, `undefined` \| `Account`\>) => `Promise`\<`bigint`\> | Estimates the gas required to successfully execute a contract write function call. - Docs: https://viem.sh/docs/contract/estimateContractGas.html **`Remarks`** Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`estimateGas` action](https://viem.sh/docs/actions/public/estimateGas.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html). **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const gas = await client.estimateContractGas({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['function mint() public']), functionName: 'mint', account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', }) ``` |
| › `parentChainPublicClient.estimateFeesPerGas` | \<TChainOverride, TType\>(`args?`: `EstimateFeesPerGasParameters`\<`undefined` \| `Chain`, `TChainOverride`, `TType`\>) => `Promise`\<`EstimateFeesPerGasReturnType`\> | Returns an estimate for the fees per gas for a transaction to be included in the next block. - Docs: https://viem.sh/docs/actions/public/estimateFeesPerGas.html **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const maxPriorityFeePerGas = await client.estimateFeesPerGas() // { maxFeePerGas: ..., maxPriorityFeePerGas: ... } ``` |
| › `parentChainPublicClient.estimateGas` | (`args`: `EstimateGasParameters`\<`undefined` \| `Chain`, `undefined` \| `Account`\>) => `Promise`\<`bigint`\> | Estimates the gas necessary to complete a transaction without submitting it to the network. - Docs: https://viem.sh/docs/actions/public/estimateGas.html - JSON-RPC Methods: [`eth_estimateGas`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas) **`Example`** ```ts import { createPublicClient, http, parseEther } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const gasEstimate = await client.estimateGas({ account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', value: parseEther('1'), }) ``` |
| › `parentChainPublicClient.estimateMaxPriorityFeePerGas` | \<TChainOverride\>(`args?`: \{ `chain`: ``null`` \| `TChainOverride`  }) => `Promise`\<`bigint`\> | Returns an estimate for the max priority fee per gas (in wei) for a transaction to be included in the next block. - Docs: https://viem.sh/docs/actions/public/estimateMaxPriorityFeePerGas.html **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const maxPriorityFeePerGas = await client.estimateMaxPriorityFeePerGas() // 10000000n ``` |
| › `parentChainPublicClient.extend` | \<client\>(`fn`: (`client`: `Client`\<`Transport`, `undefined` \| `Chain`, `undefined`, `PublicRpcSchema`, `PublicActions`\<`Transport`, `undefined` \| `Chain`\>\>) => `client`) => `Client`\<`Transport`, `undefined` \| `Chain`, `undefined`, `PublicRpcSchema`, \{ [K in string \| number \| symbol]: client[K] } & `PublicActions`\<`Transport`, `undefined` \| `Chain`\>\> | - |
| › `parentChainPublicClient.getBalance` | (`args`: `GetBalanceParameters`) => `Promise`\<`bigint`\> | Returns the balance of an address in wei. - Docs: https://viem.sh/docs/actions/public/getBalance.html - JSON-RPC Methods: [`eth_getBalance`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getbalance) **`Remarks`** You can convert the balance to ether units with [`formatEther`](https://viem.sh/docs/utilities/formatEther.html). ```ts const balance = await getBalance(client, { address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', blockTag: 'safe' }) const balanceAsEther = formatEther(balance) // "6.942" ``` **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const balance = await client.getBalance({ address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', }) // 10000000000000000000000n (wei) ``` |
| › `parentChainPublicClient.getBlock` | \<TIncludeTransactions, TBlockTag\>(`args?`: `GetBlockParameters`\<`TIncludeTransactions`, `TBlockTag`\>) => `Promise`\<`GetBlockReturnType`\<`undefined` \| `Chain`, `TIncludeTransactions`, `TBlockTag`\>\> | Returns information about a block at a block number, hash, or tag. - Docs: https://viem.sh/docs/actions/public/getBlock.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/fetching-blocks - JSON-RPC Methods: - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) for `blockNumber` & `blockTag`. - Calls [`eth_getBlockByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbyhash) for `blockHash`. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const block = await client.getBlock() ``` |
| › `parentChainPublicClient.getBlockNumber` | (`args?`: `GetBlockNumberParameters`) => `Promise`\<`bigint`\> | Returns the number of the most recent block seen. - Docs: https://viem.sh/docs/actions/public/getBlockNumber.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/fetching-blocks - JSON-RPC Methods: [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const blockNumber = await client.getBlockNumber() // 69420n ``` |
| › `parentChainPublicClient.getBlockTransactionCount` | (`args?`: `GetBlockTransactionCountParameters`) => `Promise`\<`number`\> | Returns the number of Transactions at a block number, hash, or tag. - Docs: https://viem.sh/docs/actions/public/getBlockTransactionCount.html - JSON-RPC Methods: - Calls [`eth_getBlockTransactionCountByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbynumber) for `blockNumber` & `blockTag`. - Calls [`eth_getBlockTransactionCountByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbyhash) for `blockHash`. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const count = await client.getBlockTransactionCount() ``` |
| › `parentChainPublicClient.getBytecode` | (`args`: `GetBytecodeParameters`) => `Promise`\<`GetBytecodeReturnType`\> | Retrieves the bytecode at an address. - Docs: https://viem.sh/docs/contract/getBytecode.html - JSON-RPC Methods: [`eth_getCode`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getcode) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const code = await client.getBytecode({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', }) ``` |
| › `parentChainPublicClient.getChainId` | () => `Promise`\<`number`\> | Returns the chain ID associated with the current network. - Docs: https://viem.sh/docs/actions/public/getChainId.html - JSON-RPC Methods: [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const chainId = await client.getChainId() // 1 ``` |
| › `parentChainPublicClient.getContractEvents` | \<TAbi, TEventName, TStrict, TFromBlock, TToBlock\>(`args`: `GetContractEventsParameters`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetContractEventsReturnType`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of event logs emitted by a contract. - Docs: https://viem.sh/docs/actions/public/getContractEvents.html - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { wagmiAbi } from './abi' const client = createPublicClient({ chain: mainnet, transport: http(), }) const logs = await client.getContractEvents(client, { address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: wagmiAbi, eventName: 'Transfer' }) ``` |
| › `parentChainPublicClient.getEnsAddress` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `coinType?`: `number` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsAddressReturnType`\> | Gets address for ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsAddress.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const ensAddress = await client.getEnsAddress({ name: normalize('wevm.eth'), }) // '0xd2135CfB216b74109775236E36d4b433F1DF507B' ``` |
| › `parentChainPublicClient.getEnsAvatar` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `gatewayUrls?`: `AssetGatewayUrls` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsAvatarReturnType`\> | Gets the avatar of an ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsAvatar.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls [`getEnsText`](https://viem.sh/docs/ens/actions/getEnsText.html) with `key` set to `'avatar'`. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const ensAvatar = await client.getEnsAvatar({ name: normalize('wevm.eth'), }) // 'https://ipfs.io/ipfs/Qma8mnp6xV3J2cRNf3mTth5C8nV11CAnceVinc3y8jSbio' ``` |
| › `parentChainPublicClient.getEnsName` | (`args`: \{ `address`: \`0x$\{string}\` ; `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsNameReturnType`\> | Gets primary name for specified address. - Docs: https://viem.sh/docs/ens/actions/getEnsName.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `reverse(bytes)` on ENS Universal Resolver Contract to "reverse resolve" the address to the primary ENS name. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const ensName = await client.getEnsName({ address: '0xd2135CfB216b74109775236E36d4b433F1DF507B', }) // 'wevm.eth' ``` |
| › `parentChainPublicClient.getEnsResolver` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<\`0x$\{string}\`\> | Gets resolver for ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `findResolver(bytes)` on ENS Universal Resolver Contract to retrieve the resolver of an ENS name. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const resolverAddress = await client.getEnsResolver({ name: normalize('wevm.eth'), }) // '0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41' ``` |
| › `parentChainPublicClient.getEnsText` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `key`: `string` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsTextReturnType`\> | Gets a text record for specified ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const twitterRecord = await client.getEnsText({ name: normalize('wevm.eth'), key: 'com.twitter', }) // 'wagmi_sh' ``` |
| › `parentChainPublicClient.getFeeHistory` | (`args`: `GetFeeHistoryParameters`) => `Promise`\<`GetFeeHistoryReturnType`\> | Returns a collection of historical gas information. - Docs: https://viem.sh/docs/actions/public/getFeeHistory.html - JSON-RPC Methods: [`eth_feeHistory`](https://docs.alchemy.com/reference/eth-feehistory) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const feeHistory = await client.getFeeHistory({ blockCount: 4, rewardPercentiles: [25, 75], }) ``` |
| › `parentChainPublicClient.getFilterChanges` | \<TFilterType, TAbi, TEventName, TStrict, TFromBlock, TToBlock\>(`args`: `GetFilterChangesParameters`\<`TFilterType`, `TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetFilterChangesReturnType`\<`TFilterType`, `TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of logs or hashes based on a [Filter](/docs/glossary/terms#filter) since the last time it was called. - Docs: https://viem.sh/docs/actions/public/getFilterChanges.html - JSON-RPC Methods: [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges) **`Remarks`** A Filter can be created from the following actions: - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter.html) - [`createContractEventFilter`](https://viem.sh/docs/contract/createContractEventFilter.html) - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter.html) - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter.html) Depending on the type of filter, the return value will be different: - If the filter was created with `createContractEventFilter` or `createEventFilter`, it returns a list of logs. - If the filter was created with `createPendingTransactionFilter`, it returns a list of transaction hashes. - If the filter was created with `createBlockFilter`, it returns a list of block hashes. **`Example`** ```ts // Blocks import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createBlockFilter() const hashes = await client.getFilterChanges({ filter }) ``` **`Example`** ```ts // Contract Events import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createContractEventFilter({ address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']), eventName: 'Transfer', }) const logs = await client.getFilterChanges({ filter }) ``` **`Example`** ```ts // Raw Events import { createPublicClient, http, parseAbiItem } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createEventFilter({ address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'), }) const logs = await client.getFilterChanges({ filter }) ``` **`Example`** ```ts // Transactions import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createPendingTransactionFilter() const hashes = await client.getFilterChanges({ filter }) ``` |
| › `parentChainPublicClient.getFilterLogs` | \<TAbi, TEventName, TStrict, TFromBlock, TToBlock\>(`args`: `GetFilterLogsParameters`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetFilterLogsReturnType`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of event logs since the filter was created. - Docs: https://viem.sh/docs/actions/public/getFilterLogs.html - JSON-RPC Methods: [`eth_getFilterLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterlogs) **`Remarks`** `getFilterLogs` is only compatible with **event filters**. **`Example`** ```ts import { createPublicClient, http, parseAbiItem } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createEventFilter({ address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'), }) const logs = await client.getFilterLogs({ filter }) ``` |
| › `parentChainPublicClient.getGasPrice` | () => `Promise`\<`bigint`\> | Returns the current price of gas (in wei). - Docs: https://viem.sh/docs/actions/public/getGasPrice.html - JSON-RPC Methods: [`eth_gasPrice`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gasprice) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const gasPrice = await client.getGasPrice() ``` |
| › `parentChainPublicClient.getLogs` | \<TAbiEvent, TAbiEvents, TStrict, TFromBlock, TToBlock\>(`args?`: `GetLogsParameters`\<`TAbiEvent`, `TAbiEvents`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetLogsReturnType`\<`TAbiEvent`, `TAbiEvents`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of event logs matching the provided parameters. - Docs: https://viem.sh/docs/actions/public/getLogs.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/filters-and-logs/event-logs - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) **`Example`** ```ts import { createPublicClient, http, parseAbiItem } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const logs = await client.getLogs() ``` |
| › `parentChainPublicClient.getProof` | (`args`: `GetProofParameters`) => `Promise`\<`GetProofReturnType`\> | Returns the account and storage values of the specified account including the Merkle-proof. - Docs: https://viem.sh/docs/actions/public/getProof.html - JSON-RPC Methods: - Calls [`eth_getProof`](https://eips.ethereum.org/EIPS/eip-1186) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const block = await client.getProof({ address: '0x...', storageKeys: ['0x...'], }) ``` |
| › `parentChainPublicClient.getStorageAt` | (`args`: `GetStorageAtParameters`) => `Promise`\<`GetStorageAtReturnType`\> | Returns the value from a storage slot at a given address. - Docs: https://viem.sh/docs/contract/getStorageAt.html - JSON-RPC Methods: [`eth_getStorageAt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getstorageat) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { getStorageAt } from 'viem/contract' const client = createPublicClient({ chain: mainnet, transport: http(), }) const code = await client.getStorageAt({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', slot: toHex(0), }) ``` |
| › `parentChainPublicClient.getTransaction` | \<TBlockTag\>(`args`: `GetTransactionParameters`\<`TBlockTag`\>) => `Promise`\<`GetTransactionReturnType`\<`undefined` \| `Chain`, `TBlockTag`\>\> | Returns information about a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) given a hash or block identifier. - Docs: https://viem.sh/docs/actions/public/getTransaction.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/fetching-transactions - JSON-RPC Methods: [`eth_getTransactionByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionByHash) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transaction = await client.getTransaction({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `parentChainPublicClient.getTransactionConfirmations` | (`args`: `GetTransactionConfirmationsParameters`\<`undefined` \| `Chain`\>) => `Promise`\<`bigint`\> | Returns the number of blocks passed (confirmations) since the transaction was processed on a block. - Docs: https://viem.sh/docs/actions/public/getTransactionConfirmations.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/fetching-transactions - JSON-RPC Methods: [`eth_getTransactionConfirmations`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionConfirmations) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const confirmations = await client.getTransactionConfirmations({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `parentChainPublicClient.getTransactionCount` | (`args`: `GetTransactionCountParameters`) => `Promise`\<`number`\> | Returns the number of [Transactions](https://viem.sh/docs/glossary/terms.html#transaction) an Account has broadcast / sent. - Docs: https://viem.sh/docs/actions/public/getTransactionCount.html - JSON-RPC Methods: [`eth_getTransactionCount`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactioncount) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transactionCount = await client.getTransactionCount({ address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', }) ``` |
| › `parentChainPublicClient.getTransactionReceipt` | (`args`: `GetTransactionReceiptParameters`) => `Promise`\<`TransactionReceipt`\> | Returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt) given a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash. - Docs: https://viem.sh/docs/actions/public/getTransactionReceipt.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/fetching-transactions - JSON-RPC Methods: [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transactionReceipt = await client.getTransactionReceipt({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `parentChainPublicClient.key` | `string` | A key for the client. |
| › `parentChainPublicClient.multicall` | \<TContracts, TAllowFailure\>(`args`: `MulticallParameters`\<`TContracts`, `TAllowFailure`\>) => `Promise`\<`MulticallReturnType`\<`TContracts`, `TAllowFailure`\>\> | Similar to [`readContract`](https://viem.sh/docs/contract/readContract.html), but batches up multiple functions on a contract in a single RPC call via the [`multicall3` contract](https://github.com/mds1/multicall). - Docs: https://viem.sh/docs/contract/multicall.html **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const abi = parseAbi([ 'function balanceOf(address) view returns (uint256)', 'function totalSupply() view returns (uint256)', ]) const result = await client.multicall({ contracts: [ { address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi, functionName: 'balanceOf', args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'], }, { address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi, functionName: 'totalSupply', }, ], }) // [{ result: 424122n, status: 'success' }, { result: 1000000n, status: 'success' }] ``` |
| › `parentChainPublicClient.name` | `string` | A name for the client. |
| › `parentChainPublicClient.pollingInterval` | `number` | Frequency (in ms) for polling enabled actions & events. Defaults to 4_000 milliseconds. |
| › `parentChainPublicClient.prepareTransactionRequest` | \<TChainOverride\>(`args`: `PrepareTransactionRequestParameters`\<`undefined` \| `Chain`, `undefined` \| `Account`, `TChainOverride`\>) => `Promise`\<`PrepareTransactionRequestReturnType`\> | Prepares a transaction request for signing. - Docs: https://viem.sh/docs/actions/wallet/prepareTransactionRequest.html **`Example`** ```ts import { createWalletClient, custom } from 'viem' import { mainnet } from 'viem/chains' const client = createWalletClient({ chain: mainnet, transport: custom(window.ethereum), }) const request = await client.prepareTransactionRequest({ account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', to: '0x0000000000000000000000000000000000000000', value: 1n, }) ``` **`Example`** ```ts // Account Hoisting import { createWalletClient, http } from 'viem' import { privateKeyToAccount } from 'viem/accounts' import { mainnet } from 'viem/chains' const client = createWalletClient({ account: privateKeyToAccount('0x…'), chain: mainnet, transport: custom(window.ethereum), }) const request = await client.prepareTransactionRequest({ to: '0x0000000000000000000000000000000000000000', value: 1n, }) ``` |
| › `parentChainPublicClient.readContract` | \<TAbi, TFunctionName\>(`args`: `ReadContractParameters`\<`TAbi`, `TFunctionName`\>) => `Promise`\<`ReadContractReturnType`\<`TAbi`, `TFunctionName`\>\> | Calls a read-only function on a contract, and returns the response. - Docs: https://viem.sh/docs/contract/readContract.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts/reading-contracts **`Remarks`** A "read-only" function (constant function) on a Solidity contract is denoted by a `view` or `pure` keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas. Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html). **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' import { readContract } from 'viem/contract' const client = createPublicClient({ chain: mainnet, transport: http(), }) const result = await client.readContract({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['function balanceOf(address) view returns (uint256)']), functionName: 'balanceOf', args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'], }) // 424122n ``` |
| › `parentChainPublicClient.request` | `EIP1193RequestFn`\<`PublicRpcSchema`\> | Request function wrapped with friendly error handling |
| › `parentChainPublicClient.sendRawTransaction` | (`args`: `SendRawTransactionParameters`) => `Promise`\<\`0x$\{string}\`\> | Sends a **signed** transaction to the network - Docs: https://viem.sh/docs/actions/wallet/sendRawTransaction.html - JSON-RPC Method: [`eth_sendRawTransaction`](https://ethereum.github.io/execution-apis/api-documentation/) **`Example`** ```ts import { createWalletClient, custom } from 'viem' import { mainnet } from 'viem/chains' import { sendRawTransaction } from 'viem/wallet' const client = createWalletClient({ chain: mainnet, transport: custom(window.ethereum), }) const hash = await client.sendRawTransaction({ serializedTransaction: '0x02f850018203118080825208808080c080a04012522854168b27e5dc3d5839bab5e6b39e1a0ffd343901ce1622e3d64b48f1a04e00902ae0502c4728cbf12156290df99c3ed7de85b1dbfe20b5c36931733a33' }) ``` |
| › `parentChainPublicClient.simulateContract` | \<TAbi, TFunctionName, TChainOverride\>(`args`: `SimulateContractParameters`\<`TAbi`, `TFunctionName`, `undefined` \| `Chain`, `TChainOverride`\>) => `Promise`\<`SimulateContractReturnType`\<`TAbi`, `TFunctionName`, `undefined` \| `Chain`, `TChainOverride`\>\> | Simulates/validates a contract interaction. This is useful for retrieving **return data** and **revert reasons** of contract write functions. - Docs: https://viem.sh/docs/contract/simulateContract.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts/writing-to-contracts **`Remarks`** This function does not require gas to execute and _**does not**_ change the state of the blockchain. It is almost identical to [`readContract`](https://viem.sh/docs/contract/readContract.html), but also supports contract write functions. Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html). **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const result = await client.simulateContract({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['function mint(uint32) view returns (uint32)']), functionName: 'mint', args: ['69420'], account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', }) ``` |
| › `parentChainPublicClient.transport` | `TransportConfig`\<`string`, `EIP1193RequestFn`\> & `Record`\<`string`, `any`\> | The RPC transport |
| › `parentChainPublicClient.type` | `string` | The type of client. |
| › `parentChainPublicClient.uid` | `string` | A unique ID for the client. |
| › `parentChainPublicClient.uninstallFilter` | (`args`: `UninstallFilterParameters`) => `Promise`\<`boolean`\> | Destroys a Filter that was created from one of the following Actions: - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter.html) - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter.html) - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter.html) - Docs: https://viem.sh/docs/actions/public/uninstallFilter.html - JSON-RPC Methods: [`eth_uninstallFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_uninstallFilter) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { createPendingTransactionFilter, uninstallFilter } from 'viem/public' const filter = await client.createPendingTransactionFilter() const uninstalled = await client.uninstallFilter({ filter }) // true ``` |
| › `parentChainPublicClient.verifyMessage` | (`args`: `VerifyMessageParameters`) => `Promise`\<`boolean`\> | - |
| › `parentChainPublicClient.verifyTypedData` | (`args`: `VerifyTypedDataParameters`) => `Promise`\<`boolean`\> | - |
| › `parentChainPublicClient.waitForTransactionReceipt` | (`args`: `WaitForTransactionReceiptParameters`\<`undefined` \| `Chain`\>) => `Promise`\<`TransactionReceipt`\> | Waits for the [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms.html#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt). If the Transaction reverts, then the action will throw an error. - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/sending-transactions - JSON-RPC Methods: - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed. - If a Transaction has been replaced: - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions - Checks if one of the Transactions is a replacement - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt). **`Remarks`** The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions). Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce. There are 3 types of Transaction Replacement reasons: - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`) - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`) - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transactionReceipt = await client.waitForTransactionReceipt({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `parentChainPublicClient.watchBlockNumber` | (`args`: `WatchBlockNumberParameters`) => `WatchBlockNumberReturnType` | Watches and returns incoming block numbers. - Docs: https://viem.sh/docs/actions/public/watchBlockNumber.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/watching-blocks - JSON-RPC Methods: - When `poll: true`, calls [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) on a polling interval. - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newHeads"` event. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = await client.watchBlockNumber({ onBlockNumber: (blockNumber) => console.log(blockNumber), }) ``` |
| › `parentChainPublicClient.watchBlocks` | \<TIncludeTransactions, TBlockTag\>(`args`: `WatchBlocksParameters`\<`Transport`, `undefined` \| `Chain`, `TIncludeTransactions`, `TBlockTag`\>) => `WatchBlocksReturnType` | Watches and returns information for incoming blocks. - Docs: https://viem.sh/docs/actions/public/watchBlocks.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/watching-blocks - JSON-RPC Methods: - When `poll: true`, calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getBlockByNumber) on a polling interval. - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newHeads"` event. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = await client.watchBlocks({ onBlock: (block) => console.log(block), }) ``` |
| › `parentChainPublicClient.watchContractEvent` | \<TAbi, TEventName, TStrict\>(`args`: `WatchContractEventParameters`\<`TAbi`, `TEventName`, `TStrict`\>) => `WatchContractEventReturnType` | Watches and returns emitted contract event logs. - Docs: https://viem.sh/docs/contract/watchContractEvent.html **`Remarks`** This Action will batch up all the event logs found within the [`pollingInterval`](https://viem.sh/docs/contract/watchContractEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/contract/watchContractEvent.html#onLogs). `watchContractEvent` will attempt to create an [Event Filter](https://viem.sh/docs/contract/createContractEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchContractEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs.html) instead. **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = client.watchContractEvent({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['event Transfer(address indexed from, address indexed to, uint256 value)']), eventName: 'Transfer', args: { from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b' }, onLogs: (logs) => console.log(logs), }) ``` |
| › `parentChainPublicClient.watchEvent` | \<TAbiEvent, TAbiEvents, TStrict\>(`args`: `WatchEventParameters`\<`TAbiEvent`, `TAbiEvents`, `TStrict`\>) => `WatchEventReturnType` | Watches and returns emitted [Event Logs](https://viem.sh/docs/glossary/terms.html#event-log). - Docs: https://viem.sh/docs/actions/public/watchEvent.html - JSON-RPC Methods: - **RPC Provider supports `eth_newFilter`:** - Calls [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) to create a filter (called on initialize). - On a polling interval, it will call [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges). - **RPC Provider does not support `eth_newFilter`:** - Calls [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) for each block between the polling interval. **`Remarks`** This Action will batch up all the Event Logs found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/actions/public/watchEvent.html#onLogs). `watchEvent` will attempt to create an [Event Filter](https://viem.sh/docs/actions/public/createEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs.html) instead. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = client.watchEvent({ onLogs: (logs) => console.log(logs), }) ``` |
| › `parentChainPublicClient.watchPendingTransactions` | (`args`: `WatchPendingTransactionsParameters`\<`Transport`\>) => `WatchPendingTransactionsReturnType` | Watches and returns pending transaction hashes. - Docs: https://viem.sh/docs/actions/public/watchPendingTransactions.html - JSON-RPC Methods: - When `poll: true` - Calls [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) to initialize the filter. - Calls [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getFilterChanges) on a polling interval. - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newPendingTransactions"` event. **`Remarks`** This Action will batch up all the pending transactions found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#pollinginterval-optional), and invoke them via [`onTransactions`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#ontransactions). **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = await client.watchPendingTransactions({ onTransactions: (hashes) => console.log(hashes), }) ``` |
| › `retryableGasOverrides?` | `TransactionRequestRetryableGasOverrides` | - |
| › `rollup` | \`0x$\{string}\` | - |
| › `tokenBridgeCreatorAddressOverride?` | \`0x$\{string}\` | Specifies a custom address for the TokenBridgeCreator. By default, the address will be automatically detected based on the provided chain. |

#### Returns

`Promise`\<\{ `accessList?`: `undefined` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `bigint` ; `maxFeePerGas?`: `undefined` ; `maxPriorityFeePerGas?`: `undefined` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"legacy"`` ; `value?`: `bigint`  } \| \{ `accessList?`: `AccessList` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `bigint` ; `maxFeePerGas?`: `undefined` ; `maxPriorityFeePerGas?`: `undefined` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"eip2930"`` ; `value?`: `bigint`  } \| \{ `accessList?`: `AccessList` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `undefined` ; `maxFeePerGas?`: `bigint` ; `maxPriorityFeePerGas?`: `bigint` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"eip1559"`` ; `value?`: `bigint`  }\>

#### Defined in

[src/createTokenBridgePrepareSetWethGatewayTransactionRequest.ts:91](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/createTokenBridgePrepareSetWethGatewayTransactionRequest.ts#L91)

___

### createTokenBridgePrepareTransactionReceipt

**createTokenBridgePrepareTransactionReceipt**(`txReceipt`): `Object`

#### Parameters

| Name | Type |
| :------ | :------ |
| `txReceipt` | `TransactionReceipt` |

#### Returns

`Object`

| Name | Type | Description |
| :------ | :------ | :------ |
| `blockHash` | \`0x$\{string}\` | Hash of block containing this transaction |
| `blockNumber` | `bigint` | Number of block containing this transaction |
| `contractAddress` | ``null`` \| \`0x$\{string}\` | Address of new contract or `null` if no contract was created |
| `cumulativeGasUsed` | `bigint` | Gas used by this and all preceding transactions in this block |
| `effectiveGasPrice` | `bigint` | Pre-London, it is equal to the transaction's gasPrice. Post-London, it is equal to the actual gas price paid for inclusion. |
| `from` | \`0x$\{string}\` | Transaction sender |
| `gasUsed` | `bigint` | Gas used by this transaction |
| `getTokenBridgeContracts` | (`__namedParameters`: `GetTokenBridgeContractsParameters`) => `Promise`\<`TokenBridgeContracts`\> | - |
| `logs` | `Log`\<`bigint`, `number`, ``false``\>[] | List of log objects generated by this transaction |
| `logsBloom` | \`0x$\{string}\` | Logs bloom filter |
| `status` | ``"success"`` \| ``"reverted"`` | `success` if this transaction was successful or `reverted` if it failed |
| `to` | ``null`` \| \`0x$\{string}\` | Transaction recipient or `null` if deploying a contract |
| `transactionHash` | \`0x$\{string}\` | Hash of this transaction |
| `transactionIndex` | `number` | Index of this transaction in the block |
| `type` | `TransactionType` | Transaction type |
| `waitForRetryables` | (`__namedParameters`: `WaitForRetryablesParameters`) => `Promise`\<`WaitForRetryablesResult`\> | - |

#### Defined in

[src/createTokenBridgePrepareTransactionReceipt.ts:65](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/createTokenBridgePrepareTransactionReceipt.ts#L65)

___

### createTokenBridgePrepareTransactionRequest

**createTokenBridgePrepareTransactionRequest**(`«destructured»`): `Promise`\<\{ `accessList?`: `undefined` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `bigint` ; `maxFeePerGas?`: `undefined` ; `maxPriorityFeePerGas?`: `undefined` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"legacy"`` ; `value?`: `bigint`  } \| \{ `accessList?`: `AccessList` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `bigint` ; `maxFeePerGas?`: `undefined` ; `maxPriorityFeePerGas?`: `undefined` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"eip2930"`` ; `value?`: `bigint`  } \| \{ `accessList?`: `AccessList` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `undefined` ; `maxFeePerGas?`: `bigint` ; `maxPriorityFeePerGas?`: `bigint` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"eip1559"`` ; `value?`: `bigint`  }\>

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `«destructured»` | `Object` | - |
| › `account` | \`0x$\{string}\` | - |
| › `gasOverrides?` | `TransactionRequestGasOverrides` | - |
| › `orbitChainPublicClient` | `Object` | - |
| › `orbitChainPublicClient.account` | `undefined` | The Account of the Client. |
| › `orbitChainPublicClient.batch?` | `Object` | Flags for batch settings. |
| › `orbitChainPublicClient.batch.multicall?` | `boolean` \| \{ `batchSize?`: `number` ; `wait?`: `number`  } | Toggle to enable `eth_call` multicall aggregation. |
| › `orbitChainPublicClient.cacheTime` | `number` | Time (in ms) that cached data will remain in memory. |
| › `orbitChainPublicClient.call` | (`parameters`: `CallParameters`\<`undefined` \| `Chain`\>) => `Promise`\<`CallReturnType`\> | Executes a new message call immediately without submitting a transaction to the network. - Docs: https://viem.sh/docs/actions/public/call.html - JSON-RPC Methods: [`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const data = await client.call({ account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', }) ``` |
| › `orbitChainPublicClient.chain` | `undefined` \| `Chain` | Chain for the client. |
| › `orbitChainPublicClient.createBlockFilter` | () => `Promise`\<\{ `id`: \`0x$\{string}\` ; `request`: `EIP1193RequestFn`\<readonly [\{ `Method`: ``"eth_getFilterChanges"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: \`0x$\{(...)}\`[] \| `RpcLog`[]  }, \{ `Method`: ``"eth_getFilterLogs"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `RpcLog`[]  }, \{ `Method`: ``"eth_uninstallFilter"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `boolean`  }]\> ; `type`: ``"block"``  }\> | Creates a Filter to listen for new block hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html). - Docs: https://viem.sh/docs/actions/public/createBlockFilter.html - JSON-RPC Methods: [`eth_newBlockFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newBlockFilter) **`Example`** ```ts import { createPublicClient, createBlockFilter, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await createBlockFilter(client) // { id: "0x345a6572337856574a76364e457a4366", type: 'block' } ``` |
| › `orbitChainPublicClient.createContractEventFilter` | \<TAbi, TEventName, TArgs, TStrict, TFromBlock, TToBlock\>(`args`: `CreateContractEventFilterParameters`\<`TAbi`, `TEventName`, `TArgs`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`CreateContractEventFilterReturnType`\<`TAbi`, `TEventName`, `TArgs`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Creates a Filter to retrieve event logs that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html) or [`getFilterLogs`](https://viem.sh/docs/actions/public/getFilterLogs.html). - Docs: https://viem.sh/docs/contract/createContractEventFilter.html **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createContractEventFilter({ abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']), }) ``` |
| › `orbitChainPublicClient.createEventFilter` | \<TAbiEvent, TAbiEvents, TStrict, TFromBlock, TToBlock, _EventName, _Args\>(`args?`: `CreateEventFilterParameters`\<`TAbiEvent`, `TAbiEvents`, `TStrict`, `TFromBlock`, `TToBlock`, `_EventName`, `_Args`\>) => `Promise`\<\{ [K in string \| number \| symbol]: Filter\<"event", TAbiEvents, \_EventName, \_Args, TStrict, TFromBlock, TToBlock\>[K] }\> | Creates a [`Filter`](https://viem.sh/docs/glossary/types.html#filter) to listen for new events that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html). - Docs: https://viem.sh/docs/actions/public/createEventFilter.html - JSON-RPC Methods: [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createEventFilter({ address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2', }) ``` |
| › `orbitChainPublicClient.createPendingTransactionFilter` | () => `Promise`\<\{ `id`: \`0x$\{string}\` ; `request`: `EIP1193RequestFn`\<readonly [\{ `Method`: ``"eth_getFilterChanges"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: \`0x$\{(...)}\`[] \| `RpcLog`[]  }, \{ `Method`: ``"eth_getFilterLogs"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `RpcLog`[]  }, \{ `Method`: ``"eth_uninstallFilter"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `boolean`  }]\> ; `type`: ``"transaction"``  }\> | Creates a Filter to listen for new pending transaction hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html). - Docs: https://viem.sh/docs/actions/public/createPendingTransactionFilter.html - JSON-RPC Methods: [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createPendingTransactionFilter() // { id: "0x345a6572337856574a76364e457a4366", type: 'transaction' } ``` |
| › `orbitChainPublicClient.estimateContractGas` | \<TChain, TAbi, TFunctionName\>(`args`: `EstimateContractGasParameters`\<`TAbi`, `TFunctionName`, `TChain`, `undefined` \| `Account`\>) => `Promise`\<`bigint`\> | Estimates the gas required to successfully execute a contract write function call. - Docs: https://viem.sh/docs/contract/estimateContractGas.html **`Remarks`** Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`estimateGas` action](https://viem.sh/docs/actions/public/estimateGas.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html). **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const gas = await client.estimateContractGas({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['function mint() public']), functionName: 'mint', account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', }) ``` |
| › `orbitChainPublicClient.estimateFeesPerGas` | \<TChainOverride, TType\>(`args?`: `EstimateFeesPerGasParameters`\<`undefined` \| `Chain`, `TChainOverride`, `TType`\>) => `Promise`\<`EstimateFeesPerGasReturnType`\> | Returns an estimate for the fees per gas for a transaction to be included in the next block. - Docs: https://viem.sh/docs/actions/public/estimateFeesPerGas.html **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const maxPriorityFeePerGas = await client.estimateFeesPerGas() // { maxFeePerGas: ..., maxPriorityFeePerGas: ... } ``` |
| › `orbitChainPublicClient.estimateGas` | (`args`: `EstimateGasParameters`\<`undefined` \| `Chain`, `undefined` \| `Account`\>) => `Promise`\<`bigint`\> | Estimates the gas necessary to complete a transaction without submitting it to the network. - Docs: https://viem.sh/docs/actions/public/estimateGas.html - JSON-RPC Methods: [`eth_estimateGas`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas) **`Example`** ```ts import { createPublicClient, http, parseEther } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const gasEstimate = await client.estimateGas({ account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', value: parseEther('1'), }) ``` |
| › `orbitChainPublicClient.estimateMaxPriorityFeePerGas` | \<TChainOverride\>(`args?`: \{ `chain`: ``null`` \| `TChainOverride`  }) => `Promise`\<`bigint`\> | Returns an estimate for the max priority fee per gas (in wei) for a transaction to be included in the next block. - Docs: https://viem.sh/docs/actions/public/estimateMaxPriorityFeePerGas.html **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const maxPriorityFeePerGas = await client.estimateMaxPriorityFeePerGas() // 10000000n ``` |
| › `orbitChainPublicClient.extend` | \<client\>(`fn`: (`client`: `Client`\<`Transport`, `undefined` \| `Chain`, `undefined`, `PublicRpcSchema`, `PublicActions`\<`Transport`, `undefined` \| `Chain`\>\>) => `client`) => `Client`\<`Transport`, `undefined` \| `Chain`, `undefined`, `PublicRpcSchema`, \{ [K in string \| number \| symbol]: client[K] } & `PublicActions`\<`Transport`, `undefined` \| `Chain`\>\> | - |
| › `orbitChainPublicClient.getBalance` | (`args`: `GetBalanceParameters`) => `Promise`\<`bigint`\> | Returns the balance of an address in wei. - Docs: https://viem.sh/docs/actions/public/getBalance.html - JSON-RPC Methods: [`eth_getBalance`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getbalance) **`Remarks`** You can convert the balance to ether units with [`formatEther`](https://viem.sh/docs/utilities/formatEther.html). ```ts const balance = await getBalance(client, { address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', blockTag: 'safe' }) const balanceAsEther = formatEther(balance) // "6.942" ``` **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const balance = await client.getBalance({ address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', }) // 10000000000000000000000n (wei) ``` |
| › `orbitChainPublicClient.getBlock` | \<TIncludeTransactions, TBlockTag\>(`args?`: `GetBlockParameters`\<`TIncludeTransactions`, `TBlockTag`\>) => `Promise`\<`GetBlockReturnType`\<`undefined` \| `Chain`, `TIncludeTransactions`, `TBlockTag`\>\> | Returns information about a block at a block number, hash, or tag. - Docs: https://viem.sh/docs/actions/public/getBlock.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/fetching-blocks - JSON-RPC Methods: - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) for `blockNumber` & `blockTag`. - Calls [`eth_getBlockByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbyhash) for `blockHash`. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const block = await client.getBlock() ``` |
| › `orbitChainPublicClient.getBlockNumber` | (`args?`: `GetBlockNumberParameters`) => `Promise`\<`bigint`\> | Returns the number of the most recent block seen. - Docs: https://viem.sh/docs/actions/public/getBlockNumber.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/fetching-blocks - JSON-RPC Methods: [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const blockNumber = await client.getBlockNumber() // 69420n ``` |
| › `orbitChainPublicClient.getBlockTransactionCount` | (`args?`: `GetBlockTransactionCountParameters`) => `Promise`\<`number`\> | Returns the number of Transactions at a block number, hash, or tag. - Docs: https://viem.sh/docs/actions/public/getBlockTransactionCount.html - JSON-RPC Methods: - Calls [`eth_getBlockTransactionCountByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbynumber) for `blockNumber` & `blockTag`. - Calls [`eth_getBlockTransactionCountByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbyhash) for `blockHash`. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const count = await client.getBlockTransactionCount() ``` |
| › `orbitChainPublicClient.getBytecode` | (`args`: `GetBytecodeParameters`) => `Promise`\<`GetBytecodeReturnType`\> | Retrieves the bytecode at an address. - Docs: https://viem.sh/docs/contract/getBytecode.html - JSON-RPC Methods: [`eth_getCode`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getcode) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const code = await client.getBytecode({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', }) ``` |
| › `orbitChainPublicClient.getChainId` | () => `Promise`\<`number`\> | Returns the chain ID associated with the current network. - Docs: https://viem.sh/docs/actions/public/getChainId.html - JSON-RPC Methods: [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const chainId = await client.getChainId() // 1 ``` |
| › `orbitChainPublicClient.getContractEvents` | \<TAbi, TEventName, TStrict, TFromBlock, TToBlock\>(`args`: `GetContractEventsParameters`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetContractEventsReturnType`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of event logs emitted by a contract. - Docs: https://viem.sh/docs/actions/public/getContractEvents.html - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { wagmiAbi } from './abi' const client = createPublicClient({ chain: mainnet, transport: http(), }) const logs = await client.getContractEvents(client, { address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: wagmiAbi, eventName: 'Transfer' }) ``` |
| › `orbitChainPublicClient.getEnsAddress` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `coinType?`: `number` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsAddressReturnType`\> | Gets address for ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsAddress.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const ensAddress = await client.getEnsAddress({ name: normalize('wevm.eth'), }) // '0xd2135CfB216b74109775236E36d4b433F1DF507B' ``` |
| › `orbitChainPublicClient.getEnsAvatar` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `gatewayUrls?`: `AssetGatewayUrls` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsAvatarReturnType`\> | Gets the avatar of an ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsAvatar.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls [`getEnsText`](https://viem.sh/docs/ens/actions/getEnsText.html) with `key` set to `'avatar'`. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const ensAvatar = await client.getEnsAvatar({ name: normalize('wevm.eth'), }) // 'https://ipfs.io/ipfs/Qma8mnp6xV3J2cRNf3mTth5C8nV11CAnceVinc3y8jSbio' ``` |
| › `orbitChainPublicClient.getEnsName` | (`args`: \{ `address`: \`0x$\{string}\` ; `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsNameReturnType`\> | Gets primary name for specified address. - Docs: https://viem.sh/docs/ens/actions/getEnsName.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `reverse(bytes)` on ENS Universal Resolver Contract to "reverse resolve" the address to the primary ENS name. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const ensName = await client.getEnsName({ address: '0xd2135CfB216b74109775236E36d4b433F1DF507B', }) // 'wevm.eth' ``` |
| › `orbitChainPublicClient.getEnsResolver` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<\`0x$\{string}\`\> | Gets resolver for ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `findResolver(bytes)` on ENS Universal Resolver Contract to retrieve the resolver of an ENS name. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const resolverAddress = await client.getEnsResolver({ name: normalize('wevm.eth'), }) // '0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41' ``` |
| › `orbitChainPublicClient.getEnsText` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `key`: `string` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsTextReturnType`\> | Gets a text record for specified ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const twitterRecord = await client.getEnsText({ name: normalize('wevm.eth'), key: 'com.twitter', }) // 'wagmi_sh' ``` |
| › `orbitChainPublicClient.getFeeHistory` | (`args`: `GetFeeHistoryParameters`) => `Promise`\<`GetFeeHistoryReturnType`\> | Returns a collection of historical gas information. - Docs: https://viem.sh/docs/actions/public/getFeeHistory.html - JSON-RPC Methods: [`eth_feeHistory`](https://docs.alchemy.com/reference/eth-feehistory) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const feeHistory = await client.getFeeHistory({ blockCount: 4, rewardPercentiles: [25, 75], }) ``` |
| › `orbitChainPublicClient.getFilterChanges` | \<TFilterType, TAbi, TEventName, TStrict, TFromBlock, TToBlock\>(`args`: `GetFilterChangesParameters`\<`TFilterType`, `TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetFilterChangesReturnType`\<`TFilterType`, `TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of logs or hashes based on a [Filter](/docs/glossary/terms#filter) since the last time it was called. - Docs: https://viem.sh/docs/actions/public/getFilterChanges.html - JSON-RPC Methods: [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges) **`Remarks`** A Filter can be created from the following actions: - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter.html) - [`createContractEventFilter`](https://viem.sh/docs/contract/createContractEventFilter.html) - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter.html) - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter.html) Depending on the type of filter, the return value will be different: - If the filter was created with `createContractEventFilter` or `createEventFilter`, it returns a list of logs. - If the filter was created with `createPendingTransactionFilter`, it returns a list of transaction hashes. - If the filter was created with `createBlockFilter`, it returns a list of block hashes. **`Example`** ```ts // Blocks import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createBlockFilter() const hashes = await client.getFilterChanges({ filter }) ``` **`Example`** ```ts // Contract Events import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createContractEventFilter({ address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']), eventName: 'Transfer', }) const logs = await client.getFilterChanges({ filter }) ``` **`Example`** ```ts // Raw Events import { createPublicClient, http, parseAbiItem } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createEventFilter({ address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'), }) const logs = await client.getFilterChanges({ filter }) ``` **`Example`** ```ts // Transactions import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createPendingTransactionFilter() const hashes = await client.getFilterChanges({ filter }) ``` |
| › `orbitChainPublicClient.getFilterLogs` | \<TAbi, TEventName, TStrict, TFromBlock, TToBlock\>(`args`: `GetFilterLogsParameters`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetFilterLogsReturnType`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of event logs since the filter was created. - Docs: https://viem.sh/docs/actions/public/getFilterLogs.html - JSON-RPC Methods: [`eth_getFilterLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterlogs) **`Remarks`** `getFilterLogs` is only compatible with **event filters**. **`Example`** ```ts import { createPublicClient, http, parseAbiItem } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createEventFilter({ address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'), }) const logs = await client.getFilterLogs({ filter }) ``` |
| › `orbitChainPublicClient.getGasPrice` | () => `Promise`\<`bigint`\> | Returns the current price of gas (in wei). - Docs: https://viem.sh/docs/actions/public/getGasPrice.html - JSON-RPC Methods: [`eth_gasPrice`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gasprice) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const gasPrice = await client.getGasPrice() ``` |
| › `orbitChainPublicClient.getLogs` | \<TAbiEvent, TAbiEvents, TStrict, TFromBlock, TToBlock\>(`args?`: `GetLogsParameters`\<`TAbiEvent`, `TAbiEvents`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetLogsReturnType`\<`TAbiEvent`, `TAbiEvents`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of event logs matching the provided parameters. - Docs: https://viem.sh/docs/actions/public/getLogs.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/filters-and-logs/event-logs - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) **`Example`** ```ts import { createPublicClient, http, parseAbiItem } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const logs = await client.getLogs() ``` |
| › `orbitChainPublicClient.getProof` | (`args`: `GetProofParameters`) => `Promise`\<`GetProofReturnType`\> | Returns the account and storage values of the specified account including the Merkle-proof. - Docs: https://viem.sh/docs/actions/public/getProof.html - JSON-RPC Methods: - Calls [`eth_getProof`](https://eips.ethereum.org/EIPS/eip-1186) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const block = await client.getProof({ address: '0x...', storageKeys: ['0x...'], }) ``` |
| › `orbitChainPublicClient.getStorageAt` | (`args`: `GetStorageAtParameters`) => `Promise`\<`GetStorageAtReturnType`\> | Returns the value from a storage slot at a given address. - Docs: https://viem.sh/docs/contract/getStorageAt.html - JSON-RPC Methods: [`eth_getStorageAt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getstorageat) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { getStorageAt } from 'viem/contract' const client = createPublicClient({ chain: mainnet, transport: http(), }) const code = await client.getStorageAt({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', slot: toHex(0), }) ``` |
| › `orbitChainPublicClient.getTransaction` | \<TBlockTag\>(`args`: `GetTransactionParameters`\<`TBlockTag`\>) => `Promise`\<`GetTransactionReturnType`\<`undefined` \| `Chain`, `TBlockTag`\>\> | Returns information about a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) given a hash or block identifier. - Docs: https://viem.sh/docs/actions/public/getTransaction.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/fetching-transactions - JSON-RPC Methods: [`eth_getTransactionByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionByHash) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transaction = await client.getTransaction({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `orbitChainPublicClient.getTransactionConfirmations` | (`args`: `GetTransactionConfirmationsParameters`\<`undefined` \| `Chain`\>) => `Promise`\<`bigint`\> | Returns the number of blocks passed (confirmations) since the transaction was processed on a block. - Docs: https://viem.sh/docs/actions/public/getTransactionConfirmations.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/fetching-transactions - JSON-RPC Methods: [`eth_getTransactionConfirmations`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionConfirmations) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const confirmations = await client.getTransactionConfirmations({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `orbitChainPublicClient.getTransactionCount` | (`args`: `GetTransactionCountParameters`) => `Promise`\<`number`\> | Returns the number of [Transactions](https://viem.sh/docs/glossary/terms.html#transaction) an Account has broadcast / sent. - Docs: https://viem.sh/docs/actions/public/getTransactionCount.html - JSON-RPC Methods: [`eth_getTransactionCount`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactioncount) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transactionCount = await client.getTransactionCount({ address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', }) ``` |
| › `orbitChainPublicClient.getTransactionReceipt` | (`args`: `GetTransactionReceiptParameters`) => `Promise`\<`TransactionReceipt`\> | Returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt) given a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash. - Docs: https://viem.sh/docs/actions/public/getTransactionReceipt.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/fetching-transactions - JSON-RPC Methods: [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transactionReceipt = await client.getTransactionReceipt({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `orbitChainPublicClient.key` | `string` | A key for the client. |
| › `orbitChainPublicClient.multicall` | \<TContracts, TAllowFailure\>(`args`: `MulticallParameters`\<`TContracts`, `TAllowFailure`\>) => `Promise`\<`MulticallReturnType`\<`TContracts`, `TAllowFailure`\>\> | Similar to [`readContract`](https://viem.sh/docs/contract/readContract.html), but batches up multiple functions on a contract in a single RPC call via the [`multicall3` contract](https://github.com/mds1/multicall). - Docs: https://viem.sh/docs/contract/multicall.html **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const abi = parseAbi([ 'function balanceOf(address) view returns (uint256)', 'function totalSupply() view returns (uint256)', ]) const result = await client.multicall({ contracts: [ { address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi, functionName: 'balanceOf', args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'], }, { address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi, functionName: 'totalSupply', }, ], }) // [{ result: 424122n, status: 'success' }, { result: 1000000n, status: 'success' }] ``` |
| › `orbitChainPublicClient.name` | `string` | A name for the client. |
| › `orbitChainPublicClient.pollingInterval` | `number` | Frequency (in ms) for polling enabled actions & events. Defaults to 4_000 milliseconds. |
| › `orbitChainPublicClient.prepareTransactionRequest` | \<TChainOverride\>(`args`: `PrepareTransactionRequestParameters`\<`undefined` \| `Chain`, `undefined` \| `Account`, `TChainOverride`\>) => `Promise`\<`PrepareTransactionRequestReturnType`\> | Prepares a transaction request for signing. - Docs: https://viem.sh/docs/actions/wallet/prepareTransactionRequest.html **`Example`** ```ts import { createWalletClient, custom } from 'viem' import { mainnet } from 'viem/chains' const client = createWalletClient({ chain: mainnet, transport: custom(window.ethereum), }) const request = await client.prepareTransactionRequest({ account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', to: '0x0000000000000000000000000000000000000000', value: 1n, }) ``` **`Example`** ```ts // Account Hoisting import { createWalletClient, http } from 'viem' import { privateKeyToAccount } from 'viem/accounts' import { mainnet } from 'viem/chains' const client = createWalletClient({ account: privateKeyToAccount('0x…'), chain: mainnet, transport: custom(window.ethereum), }) const request = await client.prepareTransactionRequest({ to: '0x0000000000000000000000000000000000000000', value: 1n, }) ``` |
| › `orbitChainPublicClient.readContract` | \<TAbi, TFunctionName\>(`args`: `ReadContractParameters`\<`TAbi`, `TFunctionName`\>) => `Promise`\<`ReadContractReturnType`\<`TAbi`, `TFunctionName`\>\> | Calls a read-only function on a contract, and returns the response. - Docs: https://viem.sh/docs/contract/readContract.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts/reading-contracts **`Remarks`** A "read-only" function (constant function) on a Solidity contract is denoted by a `view` or `pure` keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas. Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html). **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' import { readContract } from 'viem/contract' const client = createPublicClient({ chain: mainnet, transport: http(), }) const result = await client.readContract({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['function balanceOf(address) view returns (uint256)']), functionName: 'balanceOf', args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'], }) // 424122n ``` |
| › `orbitChainPublicClient.request` | `EIP1193RequestFn`\<`PublicRpcSchema`\> | Request function wrapped with friendly error handling |
| › `orbitChainPublicClient.sendRawTransaction` | (`args`: `SendRawTransactionParameters`) => `Promise`\<\`0x$\{string}\`\> | Sends a **signed** transaction to the network - Docs: https://viem.sh/docs/actions/wallet/sendRawTransaction.html - JSON-RPC Method: [`eth_sendRawTransaction`](https://ethereum.github.io/execution-apis/api-documentation/) **`Example`** ```ts import { createWalletClient, custom } from 'viem' import { mainnet } from 'viem/chains' import { sendRawTransaction } from 'viem/wallet' const client = createWalletClient({ chain: mainnet, transport: custom(window.ethereum), }) const hash = await client.sendRawTransaction({ serializedTransaction: '0x02f850018203118080825208808080c080a04012522854168b27e5dc3d5839bab5e6b39e1a0ffd343901ce1622e3d64b48f1a04e00902ae0502c4728cbf12156290df99c3ed7de85b1dbfe20b5c36931733a33' }) ``` |
| › `orbitChainPublicClient.simulateContract` | \<TAbi, TFunctionName, TChainOverride\>(`args`: `SimulateContractParameters`\<`TAbi`, `TFunctionName`, `undefined` \| `Chain`, `TChainOverride`\>) => `Promise`\<`SimulateContractReturnType`\<`TAbi`, `TFunctionName`, `undefined` \| `Chain`, `TChainOverride`\>\> | Simulates/validates a contract interaction. This is useful for retrieving **return data** and **revert reasons** of contract write functions. - Docs: https://viem.sh/docs/contract/simulateContract.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts/writing-to-contracts **`Remarks`** This function does not require gas to execute and _**does not**_ change the state of the blockchain. It is almost identical to [`readContract`](https://viem.sh/docs/contract/readContract.html), but also supports contract write functions. Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html). **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const result = await client.simulateContract({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['function mint(uint32) view returns (uint32)']), functionName: 'mint', args: ['69420'], account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', }) ``` |
| › `orbitChainPublicClient.transport` | `TransportConfig`\<`string`, `EIP1193RequestFn`\> & `Record`\<`string`, `any`\> | The RPC transport |
| › `orbitChainPublicClient.type` | `string` | The type of client. |
| › `orbitChainPublicClient.uid` | `string` | A unique ID for the client. |
| › `orbitChainPublicClient.uninstallFilter` | (`args`: `UninstallFilterParameters`) => `Promise`\<`boolean`\> | Destroys a Filter that was created from one of the following Actions: - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter.html) - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter.html) - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter.html) - Docs: https://viem.sh/docs/actions/public/uninstallFilter.html - JSON-RPC Methods: [`eth_uninstallFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_uninstallFilter) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { createPendingTransactionFilter, uninstallFilter } from 'viem/public' const filter = await client.createPendingTransactionFilter() const uninstalled = await client.uninstallFilter({ filter }) // true ``` |
| › `orbitChainPublicClient.verifyMessage` | (`args`: `VerifyMessageParameters`) => `Promise`\<`boolean`\> | - |
| › `orbitChainPublicClient.verifyTypedData` | (`args`: `VerifyTypedDataParameters`) => `Promise`\<`boolean`\> | - |
| › `orbitChainPublicClient.waitForTransactionReceipt` | (`args`: `WaitForTransactionReceiptParameters`\<`undefined` \| `Chain`\>) => `Promise`\<`TransactionReceipt`\> | Waits for the [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms.html#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt). If the Transaction reverts, then the action will throw an error. - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/sending-transactions - JSON-RPC Methods: - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed. - If a Transaction has been replaced: - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions - Checks if one of the Transactions is a replacement - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt). **`Remarks`** The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions). Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce. There are 3 types of Transaction Replacement reasons: - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`) - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`) - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transactionReceipt = await client.waitForTransactionReceipt({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `orbitChainPublicClient.watchBlockNumber` | (`args`: `WatchBlockNumberParameters`) => `WatchBlockNumberReturnType` | Watches and returns incoming block numbers. - Docs: https://viem.sh/docs/actions/public/watchBlockNumber.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/watching-blocks - JSON-RPC Methods: - When `poll: true`, calls [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) on a polling interval. - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newHeads"` event. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = await client.watchBlockNumber({ onBlockNumber: (blockNumber) => console.log(blockNumber), }) ``` |
| › `orbitChainPublicClient.watchBlocks` | \<TIncludeTransactions, TBlockTag\>(`args`: `WatchBlocksParameters`\<`Transport`, `undefined` \| `Chain`, `TIncludeTransactions`, `TBlockTag`\>) => `WatchBlocksReturnType` | Watches and returns information for incoming blocks. - Docs: https://viem.sh/docs/actions/public/watchBlocks.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/watching-blocks - JSON-RPC Methods: - When `poll: true`, calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getBlockByNumber) on a polling interval. - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newHeads"` event. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = await client.watchBlocks({ onBlock: (block) => console.log(block), }) ``` |
| › `orbitChainPublicClient.watchContractEvent` | \<TAbi, TEventName, TStrict\>(`args`: `WatchContractEventParameters`\<`TAbi`, `TEventName`, `TStrict`\>) => `WatchContractEventReturnType` | Watches and returns emitted contract event logs. - Docs: https://viem.sh/docs/contract/watchContractEvent.html **`Remarks`** This Action will batch up all the event logs found within the [`pollingInterval`](https://viem.sh/docs/contract/watchContractEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/contract/watchContractEvent.html#onLogs). `watchContractEvent` will attempt to create an [Event Filter](https://viem.sh/docs/contract/createContractEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchContractEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs.html) instead. **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = client.watchContractEvent({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['event Transfer(address indexed from, address indexed to, uint256 value)']), eventName: 'Transfer', args: { from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b' }, onLogs: (logs) => console.log(logs), }) ``` |
| › `orbitChainPublicClient.watchEvent` | \<TAbiEvent, TAbiEvents, TStrict\>(`args`: `WatchEventParameters`\<`TAbiEvent`, `TAbiEvents`, `TStrict`\>) => `WatchEventReturnType` | Watches and returns emitted [Event Logs](https://viem.sh/docs/glossary/terms.html#event-log). - Docs: https://viem.sh/docs/actions/public/watchEvent.html - JSON-RPC Methods: - **RPC Provider supports `eth_newFilter`:** - Calls [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) to create a filter (called on initialize). - On a polling interval, it will call [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges). - **RPC Provider does not support `eth_newFilter`:** - Calls [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) for each block between the polling interval. **`Remarks`** This Action will batch up all the Event Logs found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/actions/public/watchEvent.html#onLogs). `watchEvent` will attempt to create an [Event Filter](https://viem.sh/docs/actions/public/createEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs.html) instead. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = client.watchEvent({ onLogs: (logs) => console.log(logs), }) ``` |
| › `orbitChainPublicClient.watchPendingTransactions` | (`args`: `WatchPendingTransactionsParameters`\<`Transport`\>) => `WatchPendingTransactionsReturnType` | Watches and returns pending transaction hashes. - Docs: https://viem.sh/docs/actions/public/watchPendingTransactions.html - JSON-RPC Methods: - When `poll: true` - Calls [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) to initialize the filter. - Calls [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getFilterChanges) on a polling interval. - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newPendingTransactions"` event. **`Remarks`** This Action will batch up all the pending transactions found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#pollinginterval-optional), and invoke them via [`onTransactions`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#ontransactions). **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = await client.watchPendingTransactions({ onTransactions: (hashes) => console.log(hashes), }) ``` |
| › `params` | `Object` | - |
| › `params.rollup` | \`0x$\{string}\` | - |
| › `params.rollupOwner` | \`0x$\{string}\` | - |
| › `parentChainPublicClient` | `Object` | - |
| › `parentChainPublicClient.account` | `undefined` | The Account of the Client. |
| › `parentChainPublicClient.batch?` | `Object` | Flags for batch settings. |
| › `parentChainPublicClient.batch.multicall?` | `boolean` \| \{ `batchSize?`: `number` ; `wait?`: `number`  } | Toggle to enable `eth_call` multicall aggregation. |
| › `parentChainPublicClient.cacheTime` | `number` | Time (in ms) that cached data will remain in memory. |
| › `parentChainPublicClient.call` | (`parameters`: `CallParameters`\<`undefined` \| `Chain`\>) => `Promise`\<`CallReturnType`\> | Executes a new message call immediately without submitting a transaction to the network. - Docs: https://viem.sh/docs/actions/public/call.html - JSON-RPC Methods: [`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const data = await client.call({ account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', }) ``` |
| › `parentChainPublicClient.chain` | `undefined` \| `Chain` | Chain for the client. |
| › `parentChainPublicClient.createBlockFilter` | () => `Promise`\<\{ `id`: \`0x$\{string}\` ; `request`: `EIP1193RequestFn`\<readonly [\{ `Method`: ``"eth_getFilterChanges"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: \`0x$\{(...)}\`[] \| `RpcLog`[]  }, \{ `Method`: ``"eth_getFilterLogs"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `RpcLog`[]  }, \{ `Method`: ``"eth_uninstallFilter"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `boolean`  }]\> ; `type`: ``"block"``  }\> | Creates a Filter to listen for new block hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html). - Docs: https://viem.sh/docs/actions/public/createBlockFilter.html - JSON-RPC Methods: [`eth_newBlockFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newBlockFilter) **`Example`** ```ts import { createPublicClient, createBlockFilter, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await createBlockFilter(client) // { id: "0x345a6572337856574a76364e457a4366", type: 'block' } ``` |
| › `parentChainPublicClient.createContractEventFilter` | \<TAbi, TEventName, TArgs, TStrict, TFromBlock, TToBlock\>(`args`: `CreateContractEventFilterParameters`\<`TAbi`, `TEventName`, `TArgs`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`CreateContractEventFilterReturnType`\<`TAbi`, `TEventName`, `TArgs`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Creates a Filter to retrieve event logs that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html) or [`getFilterLogs`](https://viem.sh/docs/actions/public/getFilterLogs.html). - Docs: https://viem.sh/docs/contract/createContractEventFilter.html **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createContractEventFilter({ abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']), }) ``` |
| › `parentChainPublicClient.createEventFilter` | \<TAbiEvent, TAbiEvents, TStrict, TFromBlock, TToBlock, _EventName, _Args\>(`args?`: `CreateEventFilterParameters`\<`TAbiEvent`, `TAbiEvents`, `TStrict`, `TFromBlock`, `TToBlock`, `_EventName`, `_Args`\>) => `Promise`\<\{ [K in string \| number \| symbol]: Filter\<"event", TAbiEvents, \_EventName, \_Args, TStrict, TFromBlock, TToBlock\>[K] }\> | Creates a [`Filter`](https://viem.sh/docs/glossary/types.html#filter) to listen for new events that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html). - Docs: https://viem.sh/docs/actions/public/createEventFilter.html - JSON-RPC Methods: [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createEventFilter({ address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2', }) ``` |
| › `parentChainPublicClient.createPendingTransactionFilter` | () => `Promise`\<\{ `id`: \`0x$\{string}\` ; `request`: `EIP1193RequestFn`\<readonly [\{ `Method`: ``"eth_getFilterChanges"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: \`0x$\{(...)}\`[] \| `RpcLog`[]  }, \{ `Method`: ``"eth_getFilterLogs"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `RpcLog`[]  }, \{ `Method`: ``"eth_uninstallFilter"`` ; `Parameters`: [filterId: \`0x$\{string}\`] ; `ReturnType`: `boolean`  }]\> ; `type`: ``"transaction"``  }\> | Creates a Filter to listen for new pending transaction hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html). - Docs: https://viem.sh/docs/actions/public/createPendingTransactionFilter.html - JSON-RPC Methods: [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createPendingTransactionFilter() // { id: "0x345a6572337856574a76364e457a4366", type: 'transaction' } ``` |
| › `parentChainPublicClient.estimateContractGas` | \<TChain, TAbi, TFunctionName\>(`args`: `EstimateContractGasParameters`\<`TAbi`, `TFunctionName`, `TChain`, `undefined` \| `Account`\>) => `Promise`\<`bigint`\> | Estimates the gas required to successfully execute a contract write function call. - Docs: https://viem.sh/docs/contract/estimateContractGas.html **`Remarks`** Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`estimateGas` action](https://viem.sh/docs/actions/public/estimateGas.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html). **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const gas = await client.estimateContractGas({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['function mint() public']), functionName: 'mint', account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', }) ``` |
| › `parentChainPublicClient.estimateFeesPerGas` | \<TChainOverride, TType\>(`args?`: `EstimateFeesPerGasParameters`\<`undefined` \| `Chain`, `TChainOverride`, `TType`\>) => `Promise`\<`EstimateFeesPerGasReturnType`\> | Returns an estimate for the fees per gas for a transaction to be included in the next block. - Docs: https://viem.sh/docs/actions/public/estimateFeesPerGas.html **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const maxPriorityFeePerGas = await client.estimateFeesPerGas() // { maxFeePerGas: ..., maxPriorityFeePerGas: ... } ``` |
| › `parentChainPublicClient.estimateGas` | (`args`: `EstimateGasParameters`\<`undefined` \| `Chain`, `undefined` \| `Account`\>) => `Promise`\<`bigint`\> | Estimates the gas necessary to complete a transaction without submitting it to the network. - Docs: https://viem.sh/docs/actions/public/estimateGas.html - JSON-RPC Methods: [`eth_estimateGas`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas) **`Example`** ```ts import { createPublicClient, http, parseEther } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const gasEstimate = await client.estimateGas({ account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', value: parseEther('1'), }) ``` |
| › `parentChainPublicClient.estimateMaxPriorityFeePerGas` | \<TChainOverride\>(`args?`: \{ `chain`: ``null`` \| `TChainOverride`  }) => `Promise`\<`bigint`\> | Returns an estimate for the max priority fee per gas (in wei) for a transaction to be included in the next block. - Docs: https://viem.sh/docs/actions/public/estimateMaxPriorityFeePerGas.html **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const maxPriorityFeePerGas = await client.estimateMaxPriorityFeePerGas() // 10000000n ``` |
| › `parentChainPublicClient.extend` | \<client\>(`fn`: (`client`: `Client`\<`Transport`, `undefined` \| `Chain`, `undefined`, `PublicRpcSchema`, `PublicActions`\<`Transport`, `undefined` \| `Chain`\>\>) => `client`) => `Client`\<`Transport`, `undefined` \| `Chain`, `undefined`, `PublicRpcSchema`, \{ [K in string \| number \| symbol]: client[K] } & `PublicActions`\<`Transport`, `undefined` \| `Chain`\>\> | - |
| › `parentChainPublicClient.getBalance` | (`args`: `GetBalanceParameters`) => `Promise`\<`bigint`\> | Returns the balance of an address in wei. - Docs: https://viem.sh/docs/actions/public/getBalance.html - JSON-RPC Methods: [`eth_getBalance`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getbalance) **`Remarks`** You can convert the balance to ether units with [`formatEther`](https://viem.sh/docs/utilities/formatEther.html). ```ts const balance = await getBalance(client, { address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', blockTag: 'safe' }) const balanceAsEther = formatEther(balance) // "6.942" ``` **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const balance = await client.getBalance({ address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', }) // 10000000000000000000000n (wei) ``` |
| › `parentChainPublicClient.getBlock` | \<TIncludeTransactions, TBlockTag\>(`args?`: `GetBlockParameters`\<`TIncludeTransactions`, `TBlockTag`\>) => `Promise`\<`GetBlockReturnType`\<`undefined` \| `Chain`, `TIncludeTransactions`, `TBlockTag`\>\> | Returns information about a block at a block number, hash, or tag. - Docs: https://viem.sh/docs/actions/public/getBlock.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/fetching-blocks - JSON-RPC Methods: - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) for `blockNumber` & `blockTag`. - Calls [`eth_getBlockByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbyhash) for `blockHash`. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const block = await client.getBlock() ``` |
| › `parentChainPublicClient.getBlockNumber` | (`args?`: `GetBlockNumberParameters`) => `Promise`\<`bigint`\> | Returns the number of the most recent block seen. - Docs: https://viem.sh/docs/actions/public/getBlockNumber.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/fetching-blocks - JSON-RPC Methods: [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const blockNumber = await client.getBlockNumber() // 69420n ``` |
| › `parentChainPublicClient.getBlockTransactionCount` | (`args?`: `GetBlockTransactionCountParameters`) => `Promise`\<`number`\> | Returns the number of Transactions at a block number, hash, or tag. - Docs: https://viem.sh/docs/actions/public/getBlockTransactionCount.html - JSON-RPC Methods: - Calls [`eth_getBlockTransactionCountByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbynumber) for `blockNumber` & `blockTag`. - Calls [`eth_getBlockTransactionCountByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbyhash) for `blockHash`. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const count = await client.getBlockTransactionCount() ``` |
| › `parentChainPublicClient.getBytecode` | (`args`: `GetBytecodeParameters`) => `Promise`\<`GetBytecodeReturnType`\> | Retrieves the bytecode at an address. - Docs: https://viem.sh/docs/contract/getBytecode.html - JSON-RPC Methods: [`eth_getCode`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getcode) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const code = await client.getBytecode({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', }) ``` |
| › `parentChainPublicClient.getChainId` | () => `Promise`\<`number`\> | Returns the chain ID associated with the current network. - Docs: https://viem.sh/docs/actions/public/getChainId.html - JSON-RPC Methods: [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const chainId = await client.getChainId() // 1 ``` |
| › `parentChainPublicClient.getContractEvents` | \<TAbi, TEventName, TStrict, TFromBlock, TToBlock\>(`args`: `GetContractEventsParameters`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetContractEventsReturnType`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of event logs emitted by a contract. - Docs: https://viem.sh/docs/actions/public/getContractEvents.html - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { wagmiAbi } from './abi' const client = createPublicClient({ chain: mainnet, transport: http(), }) const logs = await client.getContractEvents(client, { address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: wagmiAbi, eventName: 'Transfer' }) ``` |
| › `parentChainPublicClient.getEnsAddress` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `coinType?`: `number` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsAddressReturnType`\> | Gets address for ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsAddress.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const ensAddress = await client.getEnsAddress({ name: normalize('wevm.eth'), }) // '0xd2135CfB216b74109775236E36d4b433F1DF507B' ``` |
| › `parentChainPublicClient.getEnsAvatar` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `gatewayUrls?`: `AssetGatewayUrls` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsAvatarReturnType`\> | Gets the avatar of an ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsAvatar.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls [`getEnsText`](https://viem.sh/docs/ens/actions/getEnsText.html) with `key` set to `'avatar'`. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const ensAvatar = await client.getEnsAvatar({ name: normalize('wevm.eth'), }) // 'https://ipfs.io/ipfs/Qma8mnp6xV3J2cRNf3mTth5C8nV11CAnceVinc3y8jSbio' ``` |
| › `parentChainPublicClient.getEnsName` | (`args`: \{ `address`: \`0x$\{string}\` ; `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsNameReturnType`\> | Gets primary name for specified address. - Docs: https://viem.sh/docs/ens/actions/getEnsName.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `reverse(bytes)` on ENS Universal Resolver Contract to "reverse resolve" the address to the primary ENS name. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const ensName = await client.getEnsName({ address: '0xd2135CfB216b74109775236E36d4b433F1DF507B', }) // 'wevm.eth' ``` |
| › `parentChainPublicClient.getEnsResolver` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<\`0x$\{string}\`\> | Gets resolver for ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `findResolver(bytes)` on ENS Universal Resolver Contract to retrieve the resolver of an ENS name. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const resolverAddress = await client.getEnsResolver({ name: normalize('wevm.eth'), }) // '0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41' ``` |
| › `parentChainPublicClient.getEnsText` | (`args`: \{ `blockNumber?`: `bigint` ; `blockTag?`: `BlockTag` ; `key`: `string` ; `name`: `string` ; `universalResolverAddress?`: \`0x$\{string}\`  }) => `Promise`\<`GetEnsTextReturnType`\> | Gets a text record for specified ENS name. - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens **`Remarks`** Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract. Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { normalize } from 'viem/ens' const client = createPublicClient({ chain: mainnet, transport: http(), }) const twitterRecord = await client.getEnsText({ name: normalize('wevm.eth'), key: 'com.twitter', }) // 'wagmi_sh' ``` |
| › `parentChainPublicClient.getFeeHistory` | (`args`: `GetFeeHistoryParameters`) => `Promise`\<`GetFeeHistoryReturnType`\> | Returns a collection of historical gas information. - Docs: https://viem.sh/docs/actions/public/getFeeHistory.html - JSON-RPC Methods: [`eth_feeHistory`](https://docs.alchemy.com/reference/eth-feehistory) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const feeHistory = await client.getFeeHistory({ blockCount: 4, rewardPercentiles: [25, 75], }) ``` |
| › `parentChainPublicClient.getFilterChanges` | \<TFilterType, TAbi, TEventName, TStrict, TFromBlock, TToBlock\>(`args`: `GetFilterChangesParameters`\<`TFilterType`, `TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetFilterChangesReturnType`\<`TFilterType`, `TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of logs or hashes based on a [Filter](/docs/glossary/terms#filter) since the last time it was called. - Docs: https://viem.sh/docs/actions/public/getFilterChanges.html - JSON-RPC Methods: [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges) **`Remarks`** A Filter can be created from the following actions: - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter.html) - [`createContractEventFilter`](https://viem.sh/docs/contract/createContractEventFilter.html) - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter.html) - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter.html) Depending on the type of filter, the return value will be different: - If the filter was created with `createContractEventFilter` or `createEventFilter`, it returns a list of logs. - If the filter was created with `createPendingTransactionFilter`, it returns a list of transaction hashes. - If the filter was created with `createBlockFilter`, it returns a list of block hashes. **`Example`** ```ts // Blocks import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createBlockFilter() const hashes = await client.getFilterChanges({ filter }) ``` **`Example`** ```ts // Contract Events import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createContractEventFilter({ address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']), eventName: 'Transfer', }) const logs = await client.getFilterChanges({ filter }) ``` **`Example`** ```ts // Raw Events import { createPublicClient, http, parseAbiItem } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createEventFilter({ address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'), }) const logs = await client.getFilterChanges({ filter }) ``` **`Example`** ```ts // Transactions import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createPendingTransactionFilter() const hashes = await client.getFilterChanges({ filter }) ``` |
| › `parentChainPublicClient.getFilterLogs` | \<TAbi, TEventName, TStrict, TFromBlock, TToBlock\>(`args`: `GetFilterLogsParameters`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetFilterLogsReturnType`\<`TAbi`, `TEventName`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of event logs since the filter was created. - Docs: https://viem.sh/docs/actions/public/getFilterLogs.html - JSON-RPC Methods: [`eth_getFilterLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterlogs) **`Remarks`** `getFilterLogs` is only compatible with **event filters**. **`Example`** ```ts import { createPublicClient, http, parseAbiItem } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const filter = await client.createEventFilter({ address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'), }) const logs = await client.getFilterLogs({ filter }) ``` |
| › `parentChainPublicClient.getGasPrice` | () => `Promise`\<`bigint`\> | Returns the current price of gas (in wei). - Docs: https://viem.sh/docs/actions/public/getGasPrice.html - JSON-RPC Methods: [`eth_gasPrice`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gasprice) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const gasPrice = await client.getGasPrice() ``` |
| › `parentChainPublicClient.getLogs` | \<TAbiEvent, TAbiEvents, TStrict, TFromBlock, TToBlock\>(`args?`: `GetLogsParameters`\<`TAbiEvent`, `TAbiEvents`, `TStrict`, `TFromBlock`, `TToBlock`\>) => `Promise`\<`GetLogsReturnType`\<`TAbiEvent`, `TAbiEvents`, `TStrict`, `TFromBlock`, `TToBlock`\>\> | Returns a list of event logs matching the provided parameters. - Docs: https://viem.sh/docs/actions/public/getLogs.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/filters-and-logs/event-logs - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) **`Example`** ```ts import { createPublicClient, http, parseAbiItem } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const logs = await client.getLogs() ``` |
| › `parentChainPublicClient.getProof` | (`args`: `GetProofParameters`) => `Promise`\<`GetProofReturnType`\> | Returns the account and storage values of the specified account including the Merkle-proof. - Docs: https://viem.sh/docs/actions/public/getProof.html - JSON-RPC Methods: - Calls [`eth_getProof`](https://eips.ethereum.org/EIPS/eip-1186) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const block = await client.getProof({ address: '0x...', storageKeys: ['0x...'], }) ``` |
| › `parentChainPublicClient.getStorageAt` | (`args`: `GetStorageAtParameters`) => `Promise`\<`GetStorageAtReturnType`\> | Returns the value from a storage slot at a given address. - Docs: https://viem.sh/docs/contract/getStorageAt.html - JSON-RPC Methods: [`eth_getStorageAt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getstorageat) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { getStorageAt } from 'viem/contract' const client = createPublicClient({ chain: mainnet, transport: http(), }) const code = await client.getStorageAt({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', slot: toHex(0), }) ``` |
| › `parentChainPublicClient.getTransaction` | \<TBlockTag\>(`args`: `GetTransactionParameters`\<`TBlockTag`\>) => `Promise`\<`GetTransactionReturnType`\<`undefined` \| `Chain`, `TBlockTag`\>\> | Returns information about a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) given a hash or block identifier. - Docs: https://viem.sh/docs/actions/public/getTransaction.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/fetching-transactions - JSON-RPC Methods: [`eth_getTransactionByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionByHash) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transaction = await client.getTransaction({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `parentChainPublicClient.getTransactionConfirmations` | (`args`: `GetTransactionConfirmationsParameters`\<`undefined` \| `Chain`\>) => `Promise`\<`bigint`\> | Returns the number of blocks passed (confirmations) since the transaction was processed on a block. - Docs: https://viem.sh/docs/actions/public/getTransactionConfirmations.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/fetching-transactions - JSON-RPC Methods: [`eth_getTransactionConfirmations`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionConfirmations) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const confirmations = await client.getTransactionConfirmations({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `parentChainPublicClient.getTransactionCount` | (`args`: `GetTransactionCountParameters`) => `Promise`\<`number`\> | Returns the number of [Transactions](https://viem.sh/docs/glossary/terms.html#transaction) an Account has broadcast / sent. - Docs: https://viem.sh/docs/actions/public/getTransactionCount.html - JSON-RPC Methods: [`eth_getTransactionCount`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactioncount) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transactionCount = await client.getTransactionCount({ address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', }) ``` |
| › `parentChainPublicClient.getTransactionReceipt` | (`args`: `GetTransactionReceiptParameters`) => `Promise`\<`TransactionReceipt`\> | Returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt) given a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash. - Docs: https://viem.sh/docs/actions/public/getTransactionReceipt.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/fetching-transactions - JSON-RPC Methods: [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transactionReceipt = await client.getTransactionReceipt({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `parentChainPublicClient.key` | `string` | A key for the client. |
| › `parentChainPublicClient.multicall` | \<TContracts, TAllowFailure\>(`args`: `MulticallParameters`\<`TContracts`, `TAllowFailure`\>) => `Promise`\<`MulticallReturnType`\<`TContracts`, `TAllowFailure`\>\> | Similar to [`readContract`](https://viem.sh/docs/contract/readContract.html), but batches up multiple functions on a contract in a single RPC call via the [`multicall3` contract](https://github.com/mds1/multicall). - Docs: https://viem.sh/docs/contract/multicall.html **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const abi = parseAbi([ 'function balanceOf(address) view returns (uint256)', 'function totalSupply() view returns (uint256)', ]) const result = await client.multicall({ contracts: [ { address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi, functionName: 'balanceOf', args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'], }, { address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi, functionName: 'totalSupply', }, ], }) // [{ result: 424122n, status: 'success' }, { result: 1000000n, status: 'success' }] ``` |
| › `parentChainPublicClient.name` | `string` | A name for the client. |
| › `parentChainPublicClient.pollingInterval` | `number` | Frequency (in ms) for polling enabled actions & events. Defaults to 4_000 milliseconds. |
| › `parentChainPublicClient.prepareTransactionRequest` | \<TChainOverride\>(`args`: `PrepareTransactionRequestParameters`\<`undefined` \| `Chain`, `undefined` \| `Account`, `TChainOverride`\>) => `Promise`\<`PrepareTransactionRequestReturnType`\> | Prepares a transaction request for signing. - Docs: https://viem.sh/docs/actions/wallet/prepareTransactionRequest.html **`Example`** ```ts import { createWalletClient, custom } from 'viem' import { mainnet } from 'viem/chains' const client = createWalletClient({ chain: mainnet, transport: custom(window.ethereum), }) const request = await client.prepareTransactionRequest({ account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', to: '0x0000000000000000000000000000000000000000', value: 1n, }) ``` **`Example`** ```ts // Account Hoisting import { createWalletClient, http } from 'viem' import { privateKeyToAccount } from 'viem/accounts' import { mainnet } from 'viem/chains' const client = createWalletClient({ account: privateKeyToAccount('0x…'), chain: mainnet, transport: custom(window.ethereum), }) const request = await client.prepareTransactionRequest({ to: '0x0000000000000000000000000000000000000000', value: 1n, }) ``` |
| › `parentChainPublicClient.readContract` | \<TAbi, TFunctionName\>(`args`: `ReadContractParameters`\<`TAbi`, `TFunctionName`\>) => `Promise`\<`ReadContractReturnType`\<`TAbi`, `TFunctionName`\>\> | Calls a read-only function on a contract, and returns the response. - Docs: https://viem.sh/docs/contract/readContract.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts/reading-contracts **`Remarks`** A "read-only" function (constant function) on a Solidity contract is denoted by a `view` or `pure` keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas. Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html). **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' import { readContract } from 'viem/contract' const client = createPublicClient({ chain: mainnet, transport: http(), }) const result = await client.readContract({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['function balanceOf(address) view returns (uint256)']), functionName: 'balanceOf', args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'], }) // 424122n ``` |
| › `parentChainPublicClient.request` | `EIP1193RequestFn`\<`PublicRpcSchema`\> | Request function wrapped with friendly error handling |
| › `parentChainPublicClient.sendRawTransaction` | (`args`: `SendRawTransactionParameters`) => `Promise`\<\`0x$\{string}\`\> | Sends a **signed** transaction to the network - Docs: https://viem.sh/docs/actions/wallet/sendRawTransaction.html - JSON-RPC Method: [`eth_sendRawTransaction`](https://ethereum.github.io/execution-apis/api-documentation/) **`Example`** ```ts import { createWalletClient, custom } from 'viem' import { mainnet } from 'viem/chains' import { sendRawTransaction } from 'viem/wallet' const client = createWalletClient({ chain: mainnet, transport: custom(window.ethereum), }) const hash = await client.sendRawTransaction({ serializedTransaction: '0x02f850018203118080825208808080c080a04012522854168b27e5dc3d5839bab5e6b39e1a0ffd343901ce1622e3d64b48f1a04e00902ae0502c4728cbf12156290df99c3ed7de85b1dbfe20b5c36931733a33' }) ``` |
| › `parentChainPublicClient.simulateContract` | \<TAbi, TFunctionName, TChainOverride\>(`args`: `SimulateContractParameters`\<`TAbi`, `TFunctionName`, `undefined` \| `Chain`, `TChainOverride`\>) => `Promise`\<`SimulateContractReturnType`\<`TAbi`, `TFunctionName`, `undefined` \| `Chain`, `TChainOverride`\>\> | Simulates/validates a contract interaction. This is useful for retrieving **return data** and **revert reasons** of contract write functions. - Docs: https://viem.sh/docs/contract/simulateContract.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts/writing-to-contracts **`Remarks`** This function does not require gas to execute and _**does not**_ change the state of the blockchain. It is almost identical to [`readContract`](https://viem.sh/docs/contract/readContract.html), but also supports contract write functions. Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html). **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const result = await client.simulateContract({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['function mint(uint32) view returns (uint32)']), functionName: 'mint', args: ['69420'], account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e', }) ``` |
| › `parentChainPublicClient.transport` | `TransportConfig`\<`string`, `EIP1193RequestFn`\> & `Record`\<`string`, `any`\> | The RPC transport |
| › `parentChainPublicClient.type` | `string` | The type of client. |
| › `parentChainPublicClient.uid` | `string` | A unique ID for the client. |
| › `parentChainPublicClient.uninstallFilter` | (`args`: `UninstallFilterParameters`) => `Promise`\<`boolean`\> | Destroys a Filter that was created from one of the following Actions: - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter.html) - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter.html) - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter.html) - Docs: https://viem.sh/docs/actions/public/uninstallFilter.html - JSON-RPC Methods: [`eth_uninstallFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_uninstallFilter) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' import { createPendingTransactionFilter, uninstallFilter } from 'viem/public' const filter = await client.createPendingTransactionFilter() const uninstalled = await client.uninstallFilter({ filter }) // true ``` |
| › `parentChainPublicClient.verifyMessage` | (`args`: `VerifyMessageParameters`) => `Promise`\<`boolean`\> | - |
| › `parentChainPublicClient.verifyTypedData` | (`args`: `VerifyTypedDataParameters`) => `Promise`\<`boolean`\> | - |
| › `parentChainPublicClient.waitForTransactionReceipt` | (`args`: `WaitForTransactionReceiptParameters`\<`undefined` \| `Chain`\>) => `Promise`\<`TransactionReceipt`\> | Waits for the [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms.html#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt). If the Transaction reverts, then the action will throw an error. - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt.html - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/sending-transactions - JSON-RPC Methods: - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed. - If a Transaction has been replaced: - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions - Checks if one of the Transactions is a replacement - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt). **`Remarks`** The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions). Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce. There are 3 types of Transaction Replacement reasons: - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`) - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`) - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`) **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const transactionReceipt = await client.waitForTransactionReceipt({ hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d', }) ``` |
| › `parentChainPublicClient.watchBlockNumber` | (`args`: `WatchBlockNumberParameters`) => `WatchBlockNumberReturnType` | Watches and returns incoming block numbers. - Docs: https://viem.sh/docs/actions/public/watchBlockNumber.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/watching-blocks - JSON-RPC Methods: - When `poll: true`, calls [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) on a polling interval. - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newHeads"` event. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = await client.watchBlockNumber({ onBlockNumber: (blockNumber) => console.log(blockNumber), }) ``` |
| › `parentChainPublicClient.watchBlocks` | \<TIncludeTransactions, TBlockTag\>(`args`: `WatchBlocksParameters`\<`Transport`, `undefined` \| `Chain`, `TIncludeTransactions`, `TBlockTag`\>) => `WatchBlocksReturnType` | Watches and returns information for incoming blocks. - Docs: https://viem.sh/docs/actions/public/watchBlocks.html - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/watching-blocks - JSON-RPC Methods: - When `poll: true`, calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getBlockByNumber) on a polling interval. - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newHeads"` event. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = await client.watchBlocks({ onBlock: (block) => console.log(block), }) ``` |
| › `parentChainPublicClient.watchContractEvent` | \<TAbi, TEventName, TStrict\>(`args`: `WatchContractEventParameters`\<`TAbi`, `TEventName`, `TStrict`\>) => `WatchContractEventReturnType` | Watches and returns emitted contract event logs. - Docs: https://viem.sh/docs/contract/watchContractEvent.html **`Remarks`** This Action will batch up all the event logs found within the [`pollingInterval`](https://viem.sh/docs/contract/watchContractEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/contract/watchContractEvent.html#onLogs). `watchContractEvent` will attempt to create an [Event Filter](https://viem.sh/docs/contract/createContractEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchContractEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs.html) instead. **`Example`** ```ts import { createPublicClient, http, parseAbi } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = client.watchContractEvent({ address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2', abi: parseAbi(['event Transfer(address indexed from, address indexed to, uint256 value)']), eventName: 'Transfer', args: { from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b' }, onLogs: (logs) => console.log(logs), }) ``` |
| › `parentChainPublicClient.watchEvent` | \<TAbiEvent, TAbiEvents, TStrict\>(`args`: `WatchEventParameters`\<`TAbiEvent`, `TAbiEvents`, `TStrict`\>) => `WatchEventReturnType` | Watches and returns emitted [Event Logs](https://viem.sh/docs/glossary/terms.html#event-log). - Docs: https://viem.sh/docs/actions/public/watchEvent.html - JSON-RPC Methods: - **RPC Provider supports `eth_newFilter`:** - Calls [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) to create a filter (called on initialize). - On a polling interval, it will call [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges). - **RPC Provider does not support `eth_newFilter`:** - Calls [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) for each block between the polling interval. **`Remarks`** This Action will batch up all the Event Logs found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/actions/public/watchEvent.html#onLogs). `watchEvent` will attempt to create an [Event Filter](https://viem.sh/docs/actions/public/createEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs.html) instead. **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = client.watchEvent({ onLogs: (logs) => console.log(logs), }) ``` |
| › `parentChainPublicClient.watchPendingTransactions` | (`args`: `WatchPendingTransactionsParameters`\<`Transport`\>) => `WatchPendingTransactionsReturnType` | Watches and returns pending transaction hashes. - Docs: https://viem.sh/docs/actions/public/watchPendingTransactions.html - JSON-RPC Methods: - When `poll: true` - Calls [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) to initialize the filter. - Calls [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getFilterChanges) on a polling interval. - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newPendingTransactions"` event. **`Remarks`** This Action will batch up all the pending transactions found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#pollinginterval-optional), and invoke them via [`onTransactions`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#ontransactions). **`Example`** ```ts import { createPublicClient, http } from 'viem' import { mainnet } from 'viem/chains' const client = createPublicClient({ chain: mainnet, transport: http(), }) const unwatch = await client.watchPendingTransactions({ onTransactions: (hashes) => console.log(hashes), }) ``` |
| › `retryableGasOverrides?` | `TransactionRequestRetryableGasOverrides` | - |
| › `tokenBridgeCreatorAddressOverride?` | \`0x$\{string}\` | Specifies a custom address for the TokenBridgeCreator. By default, the address will be automatically detected based on the provided chain. |

#### Returns

`Promise`\<\{ `accessList?`: `undefined` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `bigint` ; `maxFeePerGas?`: `undefined` ; `maxPriorityFeePerGas?`: `undefined` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"legacy"`` ; `value?`: `bigint`  } \| \{ `accessList?`: `AccessList` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `bigint` ; `maxFeePerGas?`: `undefined` ; `maxPriorityFeePerGas?`: `undefined` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"eip2930"`` ; `value?`: `bigint`  } \| \{ `accessList?`: `AccessList` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `undefined` ; `maxFeePerGas?`: `bigint` ; `maxPriorityFeePerGas?`: `bigint` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"eip1559"`` ; `value?`: `bigint`  }\>

#### Defined in

[src/createTokenBridgePrepareTransactionRequest.ts:37](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/createTokenBridgePrepareTransactionRequest.ts#L37)

___

### prepareChainConfig

**prepareChainConfig**(`params`): [`ChainConfig`](modules.md#chainconfig)

#### Parameters

| Name | Type |
| :------ | :------ |
| `params` | [`PrepareChainConfigParams`](modules.md#preparechainconfigparams) |

#### Returns

[`ChainConfig`](modules.md#chainconfig)

#### Defined in

[src/prepareChainConfig.ts:39](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/prepareChainConfig.ts#L39)

___

### prepareKeyset

**prepareKeyset**(`publicKeys`, `assumedHonest`): \`0x$\{string}\`

#### Parameters

| Name | Type |
| :------ | :------ |
| `publicKeys` | `string`[] |
| `assumedHonest` | `number` |

#### Returns

\`0x$\{string}\`

#### Defined in

[src/prepareKeyset.ts:19](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/prepareKeyset.ts#L19)

___

### prepareNodeConfig

**prepareNodeConfig**(`«destructured»`): [`NodeConfig`](modules.md#nodeconfig)

#### Parameters

| Name | Type |
| :------ | :------ |
| `«destructured»` | `Object` |
| › `batchPosterPrivateKey` | `string` |
| › `chainConfig` | [`ChainConfig`](modules.md#chainconfig) |
| › `chainName` | `string` |
| › `coreContracts` | [`CoreContracts`](modules.md#corecontracts) |
| › `parentChainId` | `number` |
| › `parentChainRpcUrl` | `string` |
| › `validatorPrivateKey` | `string` |

#### Returns

[`NodeConfig`](modules.md#nodeconfig)

#### Defined in

[src/prepareNodeConfig.ts:54](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/prepareNodeConfig.ts#L54)

___

### setValidKeyset

**setValidKeyset**(`«destructured»`): `Promise`\<`TransactionReceipt`\>

#### Parameters

| Name | Type |
| :------ | :------ |
| `«destructured»` | [`SetValidKeysetParams`](modules.md#setvalidkeysetparams) |

#### Returns

`Promise`\<`TransactionReceipt`\>

#### Defined in

[src/setValidKeyset.ts:15](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/setValidKeyset.ts#L15)

___

### setValidKeysetPrepareTransactionRequest

**setValidKeysetPrepareTransactionRequest**(`«destructured»`): `Promise`\<\{ `accessList?`: `undefined` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `bigint` ; `maxFeePerGas?`: `undefined` ; `maxPriorityFeePerGas?`: `undefined` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"legacy"`` ; `value?`: `bigint`  } \| \{ `accessList?`: `AccessList` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `bigint` ; `maxFeePerGas?`: `undefined` ; `maxPriorityFeePerGas?`: `undefined` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"eip2930"`` ; `value?`: `bigint`  } \| \{ `accessList?`: `AccessList` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `undefined` ; `maxFeePerGas?`: `bigint` ; `maxPriorityFeePerGas?`: `bigint` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"eip1559"`` ; `value?`: `bigint`  }\>

#### Parameters

| Name | Type |
| :------ | :------ |
| `«destructured»` | [`SetValidKeysetPrepareTransactionRequestParams`](modules.md#setvalidkeysetpreparetransactionrequestparams) |

#### Returns

`Promise`\<\{ `accessList?`: `undefined` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `bigint` ; `maxFeePerGas?`: `undefined` ; `maxPriorityFeePerGas?`: `undefined` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"legacy"`` ; `value?`: `bigint`  } \| \{ `accessList?`: `AccessList` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `bigint` ; `maxFeePerGas?`: `undefined` ; `maxPriorityFeePerGas?`: `undefined` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"eip2930"`` ; `value?`: `bigint`  } \| \{ `accessList?`: `AccessList` ; `account`: \`0x$\{string}\` \| `Account` ; `chain`: `undefined` \| ``null`` \| `Chain` ; `chainId`: ``1`` \| ``1337`` \| ``17000`` \| ``42161`` \| ``42170`` \| ``333333`` \| ``412346`` \| ``421614`` \| ``11155111`` ; `data?`: \`0x$\{string}\` ; `from`: \`0x$\{string}\` ; `gas?`: `bigint` ; `gasPrice?`: `undefined` ; `maxFeePerGas?`: `bigint` ; `maxPriorityFeePerGas?`: `bigint` ; `nonce?`: `number` ; `to?`: ``null`` \| \`0x$\{string}\` ; `type?`: ``"eip1559"`` ; `value?`: `bigint`  }\>

#### Defined in

[src/setValidKeysetPrepareTransactionRequest.ts:15](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/setValidKeysetPrepareTransactionRequest.ts#L15)

___

### upgradeExecutorEncodeFunctionData

**upgradeExecutorEncodeFunctionData**\<`TFunctionName`\>(`«destructured»`): \`0x$\{string}\`

#### Type parameters

| Name | Type |
| :------ | :------ |
| `TFunctionName` | extends ``"execute"`` \| ``"executeCall"`` |

#### Parameters

| Name | Type |
| :------ | :------ |
| `«destructured»` | \{ [K in string \| number \| symbol]: Omit\<EncodeFunctionDataParameters\<readonly [Object, Object], TFunctionName\>, "abi"\>[K] } |

#### Returns

\`0x$\{string}\`

#### Defined in

[src/upgradeExecutor.ts:14](https://github.com/offchainlabs/arbitrum-orbit-sdk/blob/e229109/src/upgradeExecutor.ts#L14)
